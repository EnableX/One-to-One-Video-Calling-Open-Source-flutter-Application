var EnxRtc =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 159);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js

;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                __webpack_require__(161)("./" + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(160)(module)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* global console */
var moment = __webpack_require__(0);
/*
 * API to write logs based on traditional logging mechanisms: debug, trace, info, warning, error
 */

const Logger = (() => {
    const DEBUG = 0;
    const TRACE = 1;
    const INFO = 2;
    const WARNING = 3;
    const ERROR = 4;
    const NONE = 5;
    let logPrefix = '';
    let outputFunction;
    const setLogIE = () => {
        if(!window.console) {
            var console = {
                log : function(){},
                warn : function(){},
                error : function(){},
                time : function(){},
                timeEnd : function(){}
            }
        }
    }
    setLogIE();
    // It sets the new log level. We can set it to NONE if we do not want to print logs
    const setLogLevel = (level) => {
        let targetLevel = level;
        if (level > Logger.NONE) {
            targetLevel = Logger.NONE;
        } else if (level < Logger.DEBUG) {
            targetLevel = Logger.DEBUG;
        }
        Logger.logLevel = targetLevel;
    };

    outputFunction = (args) => {
        // eslint-disable-next-line no-console
        console.log(...args);
    };

    const setOutputFunction = (newOutputFunction) => {
        outputFunction = newOutputFunction;
    };

    const setLogPrefix = (newLogPrefix) => {
        logPrefix = newLogPrefix;
    };
    const setLogCache = (keyValue,arg) => {
        var logData = (localStorage.getItem("vcxRTCLib-log") !== null)?JSON.parse(localStorage.getItem("vcxRTCLib-log")):{};

        var length = Object.keys(logData).length;
        if(length > 500){
            delete (Object.keys(logData)[0]);
        }
        var logString = '';
        for(var i in arg){
            if(typeof arg[i] == 'object'){
                logString += JSON.stringify(arg[i], null, 2);
            }else{
                logString += arg[i];
            }
        }
        logData[keyValue] = logString;
        if(localStorage.getItem("vcxRTCLib-log") !== null)
            localStorage.removeItem("vcxRTCLib-log");
        localStorage.setItem("vcxRTCLib-log",JSON.stringify(logData, null, 2));

    }
    // Generic function to print logs for a given level:
    //  Logger.[DEBUG, TRACE, INFO, WARNING, ERROR]
    const log = (level, ...args) => {
        setLogPrefix(moment().format('YYMMDDHHmmss')+'::');
        let out = logPrefix;
        if (level < Logger.logLevel) {
            return;
        }
        if (level === Logger.DEBUG) {
            out = `${out}D`;
        } else if (level === Logger.TRACE) {
            out = `${out}T`;
        } else if (level === Logger.INFO) {
            out = `${out}I`;
        } else if (level === Logger.WARNING) {
            out = `${out}W`;
        } else if (level === Logger.ERROR) {
            out = `${out}E`;
        }
        out = `${out}::WB::`;
        out += ((localStorage.getItem('logID') !== null)?localStorage.getItem('logID')+'::':'');
        const tempArgs = [out].concat(args);
        setLogCache(out,args);
        if (Logger.panel !== undefined) {
            let tmp = '';
            for (let idx = 0; idx < tempArgs.length; idx += 1) {
                tmp += tempArgs[idx];
            }
            Logger.panel.value = `${Logger.panel.value}\n${tmp}`;
        } else {
            outputFunction.apply(Logger, [tempArgs]);
        }
    };

    const debug = (...args) => {
        Logger.log(Logger.DEBUG, ...args);
    };

    const trace = (...args) => {
        Logger.log(Logger.TRACE, ...args);
    };

    const info = (...args) => {
        Logger.log(Logger.INFO, ...args);
    };

    const warning = (...args) => {
        Logger.log(Logger.WARNING, ...args);
    };

    const error = (...args) => {
        Logger.log(Logger.ERROR, ...args);
    };

    return {
        DEBUG,
        TRACE,
        INFO,
        WARNING,
        ERROR,
        NONE,
        setLogLevel,
        setOutputFunction,
        setLogPrefix,
        log,
        debug,
        trace,
        info,
        warning,
        error,
    };
})();

/* harmony default export */ __webpack_exports__["a"] = (Logger);

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Events__ = __webpack_require__(4);
/*
 * View class represents a HTML component
 * Every view is an EventDispatcher.
 */



const View = () => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["b" /* EventDispatcher */])({});

  // Variables

  // URL where it will look for icons and assets
  that.url = '';
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (View);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
This file is for handle DOM Element.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/

/* global document */


/*
 * Class Stream represents a HTML DOM Element. It will handle the element properties
 */
const Element = (spec) =>
{
    const that = {};

    that.name = spec.name;
    that.src = spec.src;
    that.srcObject = spec.srcObject;
    that.href = spec.href;
    that.rel = spec.rel;
    that.type = spec.type;
    that.target = spec.target;
    that.autoplay = spec.autoplay;
    that.alt = spec.alt;
    that.title = spec.title;
    that.id = spec.id;
    that.class = spec.class;
    that.style = Element.getStyle(spec.style);
    that.object = null;
    if (that.name && that.name != "" && that.name != null) {
        that.object = document.createElement(that.name);
        if (that.src && that.src != "" && that.src != null)
            that.object.setAttribute("src", that.src);
        if (that.srcObject && that.srcObject != "" && that.srcObject != null)
            that.object.setAttribute("srcObject", that.srcObject);
        if (that.href && that.href != "" && that.href != null)
            that.object.setAttribute("href", that.href);
        if (that.target && that.target != "" && that.target != null)
            that.object.setAttribute("target", that.target);
        if (that.alt && that.alt != "" && that.alt != null)
            that.object.setAttribute("alt", that.alt);
        if (that.title && that.title != "" && that.title != null)
            that.object.setAttribute("title", that.title);
        if (that.rel && that.rel != "" && that.rel != null)
            that.object.setAttribute("rel", that.rel);
        if (that.type && that.type != "" && that.type != null)
            that.object.setAttribute("type", that.type);
        if (that.autoplay && that.autoplay != "" && that.autoplay != null)
            that.object.setAttribute("autoplay", that.autoplay);
        if (that.id && that.id != "" && that.id != null)
            that.object.setAttribute("id", that.id);
        if (that.class && that.class != "" && that.class != null)
            that.object.setAttribute("class", that.class);
        if (that.style && that.style != "" && that.style != null)
            that.object.setAttribute("style", that.style);
    }
    return that.object;
};
Element.getStyle = (styles) =>
{
    var style = '';
    for (var key in styles) {
        style += key + ":" + styles[key] + ';';
    }
    return style;
}
Element.getById = (id) =>
{
    var elem = document.getElementById(id);
    return elem;
}


Element.getByClass = (className) =>
{
    var elem = document.getElementsByClassName(className)[0];
    return elem;
}
Element.getByTag = (tagName) =>
{
    var elem = document.getElementsByTagName(tagName)[0];
    return elem;
}
Element.getTagByDOM = (tagName, DOM) =>
{
    var elem = DOM.getElementsByTagName(tagName)[0];
    return elem;
}
Element.getByClass = (className, DOM) =>
{
    var elem = DOM.getElementsByClassName(className)[0];
    return elem;
}
Element.append = (childDOM, parentDOM) =>
{
    var elem = parentDOM.appendChild(childDOM);
    return elem;
}
Element.setStyle = (DOM, property, value) =>
{
    DOM.style[property] = value;
}
Element.addCssFile = (DOM) =>
{
    Element.getByTag('head').appendChild(DOM);
}
Element.checkParam = (elem) =>
{
    var ret = false;
    if (elem && (elem != null) && (elem != ''))
        ret = true;
    return ret;
}

/* harmony default export */ __webpack_exports__["a"] = (Element);


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return RoomEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return StreamEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return PublisherEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return UserEvent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Pair__ = __webpack_require__(10);
/*
This file is to store all events in a constant property variable.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 28/11/2017 04:13 PM
*/

/* global */
 // This package is for manage console log.


/*
 * Class EventDispatcher provides event handling to sub-classes.
 * It is inherited from Publisher, Room, etc.
 */
const EventDispatcher = () => {
    const that = {};
    // Private vars
    const dispatcher = {
        eventListeners: {},
    };

    // Public functions

    // It adds an event listener attached to an event type.
    that.addEventListener = (eventType, listener) => {
        if (dispatcher.eventListeners[eventType] === undefined) {
            dispatcher.eventListeners[eventType] = [];
        }
        dispatcher.eventListeners[eventType].push(listener);
    };

    // It removes an available event listener.
    that.removeEventListener = (eventType, listener) => {
        if (!dispatcher.eventListeners[eventType]) {
            return;
        }
        const index = dispatcher.eventListeners[eventType].indexOf(listener);
        if (index !== -1) {
            dispatcher.eventListeners[eventType].splice(index, 1);
        }
    };

    // It dispatch a new event to the event listeners, based on the type
    // of event. All events are intended to be Events.
    if(__WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].browserEngineCheck() !== 'IE'){
        that.dispatchEvent = (event) => {
            if (!event || !event.type) {				// Checking : If EventDispatcher is called with wrong event object or not
                throw new Error('Undefined event');
            }
            if(event.type !== 'onStatSubscription' )
                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug(`Event: ${event.type}`);
            const listeners = dispatcher.eventListeners[event.type] || [];
            for (let i = 0; i < listeners.length; i += 1) {
                listeners[i](event);
            }
        };
    }else{
        function CustomEvent ( event, params ) {
            params = params || { bubbles: false, cancelable: false, detail: undefined };
            var evt = document.createEvent( 'CustomEvent' );
            evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
            evt.data = params.detail;
            return evt;
        }
        CustomEvent.prototype = window.Event.prototype;
        window.CustomEvent = CustomEvent;
        that.dispatchEvent = (event) =>{
            if(event.type !== 'onStatSubscription' )
                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug('Event: '+event.type);
            var evt = CustomEvent(event.type,{ bubbles: false, cancelable: false, detail:event});
            var plugin = document.getElementById('WebrtcEverywherePluginId');
            plugin.dispatchEvent(evt);
        }
    }
    /*
    coping a function defination to another variable to use
    */
    that.on = that.addEventListener;
    that.off = that.removeEventListener;
    that.emit = that.dispatchEvent;
    that.eventsList = dispatcher.eventListeners;

    return that;
};

// **** EVENTS ****

/*
 * Class Event represents a generic Event in the library.
 * It handles the type of event, that is important when adding
 * event listeners to EventDispatchers and dispatching new events.
 * A Event can be initialized this way:
 * var event = Event({type: "room-connected"});
 */
const Event = (spec) => {
    const that = {};

    // Event type. Examples are: 'room-connected', 'stream-added', etc.
    that.type = spec.type;

    return that;
};

/*
 * Class RoomEvent represents an Event that happens in a Room. It is a
 * Event.
 * It is usually initialized as:
 * var roomEvent = RoomEvent({type:"room-connected", streams:[stream1, stream2]});
 * Event types:
 * 'room-connected' - points out that the user has been successfully connected to the room.
 * 'room-disconnected' - shows that the user has been already disconnected.
 */
const RoomEvent = (spec) => {
    const that = Event(spec);

    // A list with the streams that are published in the room.
    that.streams = spec.streams;
    that.message = spec.message;
    that.room = spec.room;
    that.users = spec.users;
    that.type = spec.type;
    that.bandwidth = spec.bandwidth;
    that.TalkerCount = spec.TalkerCount;
    that.me = spec.me;
    that.mediaRecord = spec.mediaRecord;
    that.error = spec.error;
    return that;
};

/*
 * Class StreamEvent represents an event related to a stream. It is a Event.
 * It is usually initialized this way:
 * var streamEvent = StreamEvent({type:"stream-added", stream:stream1});
 * Event types:
 * 'stream-added' - indicates that there is a new stream available in the room.
 * 'stream-removed' - shows that a previous available stream has been removed from the room.
 */
const StreamEvent = (spec) => {
    const that = Event(spec);

    // The stream related to this event.
    that.stream = spec.stream;

    that.msg = spec.msg;
    that.bandwidth = spec.bandwidth;
    that.attrs = spec.attrs;

    return that;
};

/*
 * Class PublisherEvent represents an event related to a publisher. It is a Event.
 * It usually initializes as:
 * var publisherEvent = PublisherEvent({})
 * Event types:
 * 'media-access-allowed' - indicates that the user has accepted to share his camera and microphone
 */
const PublisherEvent = (spec) => {
    const that = Event(spec);

    return that;
};

const UserEvent = (spec) => {
    const that = Event(spec);
    that.name = spec.name;
    that.role = spec.role;
    that.clientId = spec.clientId;
    that.permissions = spec.permission;
    return that;
};
/*const PublishStream = (spec) => {

  const that = Event(spec);
  return that;
};*/
/*export { EventDispatcher, Event, RoomEvent, StreamEvent, PublisherEvent,PublishStream };*/



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
This file is to store all events in a constant property variable.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 27/11/2017 05:14 PM
*/

const VcxEventProperties = {};
VcxEventProperties.SocketEvent = {};
VcxEventProperties.RoomEvent = {};
VcxEventProperties.UserEvent = {};
VcxEventProperties.StreamEvent = {};

VcxEventProperties.SocketEvent.onAddStream='onAddStream';
VcxEventProperties.SocketEvent.onRemoveTrack='onRemoveTrack';
VcxEventProperties.SocketEvent.media_engine_connecting='media_engine_connecting';
VcxEventProperties.SocketEvent.signaling_message_peer='signaling_message_peer';
VcxEventProperties.SocketEvent.publish_me='publish_me';
VcxEventProperties.SocketEvent.unpublish_me='unpublish_me';
VcxEventProperties.SocketEvent.onBandwidthAlert='onBandwidthAlert';
VcxEventProperties.SocketEvent.onSelfBandwidthAlert='onSelfBandwidthAlert';
VcxEventProperties.SocketEvent.onDataStream='onDataStream';
VcxEventProperties.SocketEvent.onUpdateAttributeStream='onUpdateAttributeStream';
VcxEventProperties.SocketEvent.onRemoveStream='onRemoveStream';
VcxEventProperties.SocketEvent.disconnect='disconnect';
VcxEventProperties.SocketEvent.connection_failed='connection_failed';
VcxEventProperties.SocketEvent.error='error';
VcxEventProperties.SocketEvent.connect_error='connect_error';
VcxEventProperties.SocketEvent.connect_timeout='connect_timeout';
VcxEventProperties.SocketEvent.reconnecting='reconnecting';
VcxEventProperties.SocketEvent.reconnect='reconnect';
VcxEventProperties.SocketEvent.reconnected='reconnected';
VcxEventProperties.SocketEvent.reconnect_attempt='reconnect_attempt';
VcxEventProperties.SocketEvent.reconnect_error='reconnect_error';
VcxEventProperties.SocketEvent.reconnect_failed='reconnect_failed';
VcxEventProperties.SocketEvent.user_connected='user-connected';
VcxEventProperties.SocketEvent.user_disconnected='user-disconnected';
VcxEventProperties.SocketEvent.user_subscribed='user-subscribed';
VcxEventProperties.SocketEvent.user_unsubscribed='user-unsubscribed';
VcxEventProperties.SocketEvent.floor_requested='floorRequested';
VcxEventProperties.SocketEvent.floor_granted='floorGranted';
VcxEventProperties.SocketEvent.floor_not_granted='floorDenied';
VcxEventProperties.SocketEvent.floor_released='floorReleased';
VcxEventProperties.SocketEvent.dial_state_events='dialStateEvents';
VcxEventProperties.RoomEvent.user_role_changed='userRoleChanged';
// manu stats
VcxEventProperties.SocketEvent.onStatSubscription='onStatSubscription';
// end manu stats
VcxEventProperties.SocketEvent.data_stream_room = 'onDataStreamToRoom';

VcxEventProperties.UserEvent.user_awaited='user-awaited';
VcxEventProperties.UserEvent.user_joined='user-joined';

VcxEventProperties.RoomEvent.room_connected='room-connected';
VcxEventProperties.RoomEvent.room_awaited='room-awaited';
VcxEventProperties.RoomEvent.room_record_on='room-record-on';
VcxEventProperties.RoomEvent.room_record_off='room-record-off';
VcxEventProperties.RoomEvent.new_active_talker='active-talkers-updated';
VcxEventProperties.RoomEvent.hard_mute_audio='hardmute-user-audio';
VcxEventProperties.RoomEvent.hard_unmute_audio='hardunmute-user-audio';
VcxEventProperties.RoomEvent.hard_mute_video='hardmute-user-video';
VcxEventProperties.RoomEvent.hard_unmute_video='hardunmute-user-video';
VcxEventProperties.RoomEvent.get_active_talker='getNumberOfTalker';
VcxEventProperties.RoomEvent.set_active_talker='setNumberOfTalker';
VcxEventProperties.RoomEvent.get_active_max_talker = 'getMaxNumberOfTalker';
VcxEventProperties.RoomEvent.set_adavanced_options = 'setAdvancedOptions';
VcxEventProperties.RoomEvent.get_adavanced_options = 'getAdvancedOptions';
VcxEventProperties.RoomEvent.client_stats = 'clientStats';
VcxEventProperties.RoomEvent.switch_user_role = 'switchUserRole';
VcxEventProperties.RoomEvent.hard_unmute_video='hardunmute-user-video';
VcxEventProperties.RoomEvent.share_started='shareStarted';
VcxEventProperties.RoomEvent.share_stopped='shareStopped';
VcxEventProperties.RoomEvent.share_state_events='shareStateEvents';
VcxEventProperties.RoomEvent.subscriber_video_mute='subscriber-video-mute';
VcxEventProperties.RoomEvent.switch_codec = 'switch-publish-media-codec';

VcxEventProperties.RoomEvent.canvas_started='canvasStarted';
VcxEventProperties.RoomEvent.canvas_stopped='canvasStopped';
VcxEventProperties.RoomEvent.canvas_state_events='canvasStateEvents';

VcxEventProperties.RoomEvent.generic_events='genericEvents';
VcxEventProperties.RoomEvent.network_reconnected='network-reconnected';
VcxEventProperties.RoomEvent.network_disconnected='network-disconnected';
VcxEventProperties.RoomEvent.network_reconnectiontimeout='network-reconnect-timeout';
VcxEventProperties.RoomEvent.network_reconnectfailed='network-reconnect-failed';
// file sharing room level events
// to do remove unused file sharing events
VcxEventProperties.RoomEvent.fs_upload_started='fs-upload-started';
VcxEventProperties.RoomEvent.fs_file_uploaded='fs-file-uploaded';
VcxEventProperties.RoomEvent.fs_file_uploaded='fs-file-available';
VcxEventProperties.RoomEvent.fs_download_started='fs-download-started';
VcxEventProperties.RoomEvent.fs_file_downloaded='fs-file-downloaded';
VcxEventProperties.RoomEvent.fs_file_downloaded = 'fs-upload-success';
VcxEventProperties.RoomEvent.fs_file_upload_result = 'fs-upload-result';
VcxEventProperties.RoomEvent.fs_file_download_result = 'fs-download-result';






VcxEventProperties.UserEvent.user_audio_muted ='user-audio-muted';
VcxEventProperties.UserEvent.user_audio_unmuted='user-audio-unmuted';
VcxEventProperties.UserEvent.user_video_muted ='user-video-muted';
VcxEventProperties.UserEvent.user_video_unmuted='user-video-unmuted';

VcxEventProperties.SocketEvent.hard_mute='hardMute';
VcxEventProperties.SocketEvent.hard_mute_room='room-muted';
VcxEventProperties.SocketEvent.hard_unmute_room='room-unmuted';


VcxEventProperties.SocketEvent.switched_room='roomSwitched';

VcxEventProperties.constant = {};
VcxEventProperties.constant.H264_CODEC = "H264_AND_OPUS";
VcxEventProperties.constant.default = "default";

VcxEventProperties.constant.SAFARI_VERSION_NOT_SUPPORTING_VP8 = '12.0';
VcxEventProperties.constant.SAFARI_VERSION_SUPPORTING_VP8 = '12.1';
VcxEventProperties.constant.FIREFOX_VERSION_VIDEO_MUTE_SUPPORT = '60.0';
VcxEventProperties.constant.CHROME_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT  = '72.0';
VcxEventProperties.constant.FIREFOX_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT  = '66.0';
VcxEventProperties.constant.FIREFOX_VERSION_SENDER_ENCODINGS_PARAM_SUPPORT = '64.0';
/* harmony default export */ __webpack_exports__["a"] = (VcxEventProperties);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const customEvents = {
    "event_ice_failed" : {event_code: "000", severity: "critical", event_name: "ice-failed"},
    "event_stream_subscribe_failed" : {event_code: "000", severity: "critical", event_name: "stream-subscribe-failed"},
    "event_stream_unsubscribe_failed" : {event_code: "000", severity: "critical", event_name: "stream-unsubscribe-failed"},
    "event_socket_connect_failed": {event_code: "000", severity: "critical", event_name: "socket-connect-failed"},
    "event_stream_publish_failed": {event_code: "000", severity: "critical", event_name: "stream-publish-failed"},
    "event_stream_unpublish_failed": {event_code: "000", severity: "critical", event_name: "stream-unpublish-failed"},
    "event_start_recording_failed": {event_code: "000", severity: "critical", event_name: "start-recording-failed"},
    "event_stop_recording_failed": {event_code: "000", severity: "critical", event_name: "stop-recording-failed"},
    "event_start_screenshare_failed": {event_code: "000", severity: "critical", event_name: "start-screenshare-failed"},
    "event_stop_screenshare_failed": {event_code: "000", severity: "critical", event_name: "stop-screenshare-failed"},
    "event_start_canvas_failed": {event_code: "000", severity: "critical", event_name: "start-canvas-failed"},
    "event_stop_canvas_failed": {event_code: "000", severity: "critical", event_name: "stop-canvas-failed"},
    "event_send_message_failed": {event_code: "000", severity: "high", event_name: "send-message-failed"},
    "event_send_data_failed": {event_code: "000", severity: "high", event_name: "send-data-failed"},
    "event_media_access_denied": {event_code: "000", severity: "critical", event_name: "media-access-denied"},
    "event_gum_failed": {event_code: "000", severity: "critical", event_name: "gum-failed"},
    "event_audio_device_access_failed": {event_code: "000", severity: "critical", event_name: "audio-device-access-failed"},
    "event_video_device_access_failed": {event_code: "000", severity: "critical", event_name: "video-device-access-failed"},
    "event_remote_canvas_stream_failed": {event_code: "000", severity: "high", event_name: "remote-canvas-stream-failed"},
    "event_capture_canvas_stream_failed": {event_code: "000", severity: "critical",  event_name: "capture-canvas-stream-failed"},
    "event_set_local_description": {event_code: "000", severity: "none", event_name: "set-local-description"},
    "event_set_remote_description": {event_code: "000", severity: "none", event_name: "set-remote-description"}
}

/* harmony default export */ __webpack_exports__["a"] = (customEvents);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(1);
/* Import Global Libraries */


/**************************************
 * Class: EventLogger
 * Description: This class represents EventLogger.
 * Author: Gagandeep
 * Las Edit Date: 24/09/2019
 * Relase Version: 1.0
 **************************************/

const EventLogger = () => {
    const DEBUG = 1;
    const TRACE = 2;
    const INFO = 3;
    const WARNING = 4;
    const ERROR = 5;

    const that = {};
    that.eventLoggerToken = undefined;
    that.eventServer = {};
    that.logID = undefined;
    that.eventBuffer = new Array();
    that.uniqueSequence = 1;
    that.clientId = undefined;

    // ************************************
    // Public function: init()
    // Intializes EventLogger
    // ************************************

    that.init = (token) => {
        // conference token will be short lived and not persist here, as after validation, its life will expire
        // So this token will only passthrough for validation
        try {
            // let tokenObj = JSON.parse(window.atob(token));
            var tokenObj = token;

            // If server sent back Event Server details(url and port) with token, logging is turned ON else it is turned OFF
            if (tokenObj.eventServer && tokenObj.eventServer.url && tokenObj.eventServer.port){
                that.eventServer.url = tokenObj.eventServer.url;
                that.eventServer.port = tokenObj.eventServer.port;
                that.logID =  tokenObj.logId;
                /*
                if(tokenObj.eventServer.url && tokenObj.eventServer.port){

                    xhttp.onreadystatechange = function() {
                        //console.log("readystate: " + this.readyState + " status: " + this.status + " responseText: " + this.responseText );
                        if (this.readyState == 4 && this.status == 200) {
                            //Logger.info(this.responseText);
                            that.eventLoggerToken = JSON.parse(this.responseText).eventLoggerToken;

                            //console.log('that.eventLoggerToken = ' + that.eventLoggerToken);
                            //localStorage.setItem('eventToken', that.eventLoggerToken);
                            that.processBufferEvents();

                        } else {
                            //Logger.error('Connection to Event Server did not establish. Status: ' + this.status + ' responseText' + this.responseText);
                        }
                    }
                    xhttp.open("POST", "https://" + tokenObj.eventServer.url + ":" + tokenObj.eventServer.port + "/init", true);

                    //xhttp.setRequestHeader("authorization", "123");
                    //xhttp.setRequestHeader("content-type", "application/json");
                    xhttp.setRequestHeader("token", window.btoa(JSON.stringify(token)));

                    xhttp.send();
                }
                */
            }

        } catch (e) {
            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].error(`Error! Failed to send auth request to Event Server. Error: ${e}.`);
        }
        // console.log("EVENT SERVER URL: " + that.eventServer.url + " Port: " + that.eventServer.port);
    };


    that.log = (level0, logEvent) => {
        try{
            // If server sent back Event Server details(url and port), logging is turned ON else it is turned OFF
                // console.log('EventLogger.log event ' + JSON.stringify(logEvent));

                // Create Event Object
                var sourceTimeStamp = new Date().toISOString();
                var level0Label = 'info';
                var eventObj = {};

                switch (level0) {
                    case DEBUG:
                        level0Label = 'debug';
                        break;
                    case TRACE:
                        level0Label = 'trace';
                        break;
                    case INFO:
                        level0Label = 'info';
                        break;
                    case WARNING:
                        level0Label = 'warning';
                        break;
                    case ERROR:
                        level0Label = 'error';
                        break;
                    default:
                        level0Label = 'info';
                }

                // Event Object structure that will eventually be published to the event server
                // Caution: If you are modifying this object's prototype (members),
                //    take care of the filtering and structuring of the information at the backend (event server and further) as well

                eventObj.key = {
                    logID: that.logID,
                    endpointType: 'client',
                    instanceID: that.logID, // ToDo - TBD, This field is for Servers, TBD for clients, for now keep it as logID
                    uniqueSequence: that.uniqueSequence++
                    //clientId: that.clientId? that.clientId: "undef"
                };

                if (logEvent.event) {
                    eventObj.severity = logEvent.event.severity; // ToDo - Devise logic to auto determine severity. E.g. Critical, high, medium, low, none
                } else {
                    eventObj.severity = "none"; // default severity if no severity is available
                }

                eventObj.eventLevel = [];
                eventObj.eventLevel.push(level0Label);
                eventObj.eventLevel.push(logEvent.source);

                // eventMeta is a generic object, structure of which is left to the client and end-consumer of event logs
                // eventObj.eventMeta = logEvent;
                eventObj.eventMeta = {};
                eventObj.eventMeta.event = logEvent.event;
                eventObj.eventMeta.meta = logEvent.meta;

                eventObj.isAnonymousInfo = true;
                eventObj.sourceTimeStamp = sourceTimeStamp;

                if (that.eventServer.url && that.eventServer.port && that.eventLoggerToken) {
                    // POST event object to Event server if event server url port and Eventlogger token in available
                    var xhttp = new XMLHttpRequest();
                    xhttp.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(this.responseText);
                        } else {
                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].error('Connection to Event Server did not establish. Status: ' + this.status);
                        }
                    }
                    xhttp.open("POST", "https://" + that.eventServer.url + ":" + that.eventServer.port + "/event", true);
                    xhttp.setRequestHeader("Content-Type", "application/json");
                    xhttp.setRequestHeader("eventToken", that.eventLoggerToken);

                    xhttp.send(JSON.stringify(eventObj));
                } else {
                    // Else, store the log in a buffer till the time the token is available and POST once event server responds
                    that.eventBuffer.push(eventObj);
                }

        } catch (e){
            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].error(`Error! Failed to post log event to Event Server. Error: ${e}.`);
        }

    };

    that.debug = (source, event, meta) => {
        var logEvent = {source:source, event:event, meta:meta};
        that.log(DEBUG, logEvent);
    };

    that.trace = (source, event, meta) => {
        var logEvent = {source:source, event:event, meta:meta};
        that.log(TRACE, logEvent);
    };

    that.info = (source, event, meta) => {
        var logEvent = {source:source, event:event, meta:meta};
        that.log(INFO, logEvent);
    };

    that.warn = (source, event, meta) => {
        var logEvent = {source:source, event:event, meta:meta};
        that.log(WARNING, logEvent);
    };

    that.error = (source, event, meta) => {
        var logEvent = {source:source, event:event, meta:meta};
        that.log(ERROR, logEvent);
    };

    // ************************************
    // Public function: close()
    // Closes the logger. No use case of this yet, but need to check.
    // ************************************

    that.close = () => {
        // ToDO TBD - reset all event logger properties such as eventLoggerToken, logID(risks?), uniqueSequence. Check risks.
    };

    that.revalidate = () => {
        // ToDO TBD - revalidate the eventLoggerToken by either reissuing another token or extending the current token validity
        // Need to check if logId and uniqueSequence should be preserved
    };

    that.processBufferEvents = () => {
        for(var i=0; i< that.eventBuffer.length; i++){
            var postEvent = that.eventBuffer[i];
            /*
            if(that.clientId && postEvent && postEvent.key){
               postEvent.key.clientId = that.clientId;
            }
            */
            var xhttpBuffer = new XMLHttpRequest();
            xhttpBuffer.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(this.responseText);
                } else {
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].error('Connection to Event Server did not establish. Status: ' + this.status);
                }
            }
            xhttpBuffer.open("POST", "https://" + that.eventServer.url + ":" + that.eventServer.port + "/event", true);
            xhttpBuffer.setRequestHeader("Content-Type", "application/json");
            xhttpBuffer.setRequestHeader("eventToken", that.eventLoggerToken);
            xhttpBuffer.send(JSON.stringify(postEvent));
        }
    }

    that.setClientId = (clientId) => {
        that.clientId = clientId;
    }

    that.setEventLoggerToken = (token) => {
        if(token) {
            that.eventLoggerToken = token;
            if(that.eventLoggerToken && that.eventServer && that.eventServer.url && that.eventServer.port){
                that.processBufferEvents();
            }
        }
    }

    return that;
}

const EL = EventLogger();

/* harmony default export */ __webpack_exports__["a"] = (EL);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const defaultSkin = {
    vcx_player: {
        width: 'inherit',
        height: 'inherit',
        position: 'relative',
        'background-color': 'black',
        overflow: 'hidden',

    },
    vcx_player_loader: {
        width: '100%',
        height: '100%',
        position: 'absolute',
    },
    vcx_player_screen_saver: {
        width: '100%',
        height: '100%',
        position: 'absolute',
        'z-index': '1',
    },
    vcx_stream: {
        width: 'inherit !important',
        height: 'inherit !important',
        position: 'absolute',
        'object-fit': 'cover',
    },
    default_vcx_bar: {
        height: '100%',
        width: '100%',
        position: 'absolute',
    },
    vcx_subbar_bottom: {
        width: '100%',
        height: '15%',
        'max-height': '33px',
        color: '#aaa',
        position: 'absolute',
        bottom: 0,
        'background-repeat': 'repeat-x;',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'bottom',
        'padding-top': '50px',
        'z-index': 2,
    },
    vcx_subbar_top: {
        width: '100%',
        height: '15%',
        'max-height': '30px',
        color: '#aaa',
        position: 'absolute',
        top: 0,
        'background-repeat': 'repeat-x',
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'top !important',
        'padding-bottom': '50px',
        'z-index': 2,
        //'background-position': 'bottom',
    },
    vcx_subbar_left: {
        width: '15%',
        height: '100%',
        'max-width': '30px',
        color: '#aaa',
        position: 'absolute',
        left: 0,
        'background-repeat': 'repeat-x',
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'bottom',
    },
    vcx_subbar_right: {
        width: '15%',
        height: '100%',
        'max-width': '30px',
        color: '#aaa',
        position: 'absolute',
        right: 0,
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'bottom',
    },
    brand_logo: {
        'max-width': '30px',
        'max-height': '30px',
        cursor: 'pointer',
        position: 'absolute',
        right: '0px',
        margin: '5px',
    },
    theater_view: {
        width: '100% !important',
        height: '80% !important',
    },
    full_view: {
        width: '100% !important',
        height: '100% !important',
        top: '0px',
        left: '0px',
        position: 'fixed !important',
        'z-index': 3,
    },
    icon: {
        margin: '7px',
        'max-width': '30px',
        cursor: 'pointer',
    },
    icon_record: {
        color: '#f00',
    },
    icon_volume: {
        color: '#aaa'
    },
    icon_play: {color: '#aaa'},
    icon_mic: {color: '#aaa'},
    icon_zoom: {color: '#aaa'},
    icon_share: {color: '#aaa'},
};

/* harmony default export */ __webpack_exports__["a"] = (defaultSkin);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

const b64 = __webpack_require__(155);
function arrayToB64(array) {
  return b64
    .fromByteArray(array)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

function b64ToArray(str) {
  return b64.toByteArray(str + '==='.slice((str.length + 3) % 4));
}


function isFile(id) {
  return /^[0-9a-fA-F]{10,16}$/.test(id);
}

function copyToClipboard(str) {
  const aux = document.createElement('input');
  aux.setAttribute('value', str);
  aux.contentEditable = true;
  aux.readOnly = true;
  document.body.appendChild(aux);
  if (navigator.userAgent.match(/iphone|ipad|ipod/i)) {
    const range = document.createRange();
    range.selectNodeContents(aux);
    const sel = getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    aux.setSelectionRange(0, str.length);
  } else {
    aux.select();
  }
  const result = document.execCommand('copy');
  document.body.removeChild(aux);
  return result;
}

const LOCALIZE_NUMBERS = !!(
  typeof Intl === 'object' &&
  Intl &&
  typeof Intl.NumberFormat === 'function' &&
  typeof navigator === 'object'
);

const UNITS = ['bytes', 'kb', 'mb', 'gb'];
function bytes(num) {
  if (num < 1) {
    return '0B';
  }
  const exponent = Math.min(Math.floor(Math.log10(num) / 3), UNITS.length - 1);
  const n = Number(num / Math.pow(1024, exponent));
  const decimalDigits = Math.floor(n) === n ? 0 : 1;
  let nStr = n.toFixed(decimalDigits);
  if (LOCALIZE_NUMBERS) {
    try {
      nStr = n.toLocaleString(locale(), {
        minimumFractionDigits: decimalDigits,
        maximumFractionDigits: decimalDigits
      });
    } catch (e) {
      // fall through
    }
  }
  return translate('fileSize', {
    num: nStr,
    units: translate(UNITS[exponent])
  });
}

function percent(ratio) {
  if (LOCALIZE_NUMBERS) {
    try {
      return ratio.toLocaleString(locale(), { style: 'percent' });
    } catch (e) {
      // fall through
    }
  }
  return `${Math.floor(ratio * 100)}%`;
}

function number(n) {
  if (LOCALIZE_NUMBERS) {
    return n.toLocaleString(locale());
  }
  return n.toString();
}

function allowedCopy() {
  const support = !!document.queryCommandSupported;
  return support ? document.queryCommandSupported('copy') : false;
}

function delay(delay = 100) {
  return new Promise(resolve => setTimeout(resolve, delay));
}

function fadeOut(selector) {
  const classes = document.querySelector(selector).classList;
  classes.remove('effect--fadeIn');
  classes.add('effect--fadeOut');
  return delay(300);
}

function openLinksInNewTab(links, should = true) {
  links = links || Array.from(document.querySelectorAll('a:not([target])'));
  if (should) {
    links.forEach(l => {
      l.setAttribute('target', '_blank');
      l.setAttribute('rel', 'noopener noreferrer');
    });
  } else {
    links.forEach(l => {
      l.removeAttribute('target');
      l.removeAttribute('rel');
    });
  }
  return links;
}

function browserName() {
  try {
    if (/firefox/i.test(navigator.userAgent)) {
      return 'firefox';
    }
    if (/edge/i.test(navigator.userAgent)) {
      return 'edge';
    }
    if (/trident/i.test(navigator.userAgent)) {
      return 'ie';
    }
    if (/chrome/i.test(navigator.userAgent)) {
      return 'chrome';
    }
    if (/safari/i.test(navigator.userAgent)) {
      return 'safari';
    }
    if (/send android/i.test(navigator.userAgent)) {
      return 'android-app';
    }
    return 'other';
  } catch (e) {
    return 'unknown';
  }
}
async function streamToArrayBuffer(stream, size) {
  const reader = stream.getReader();
  let state = await reader.read();

  if (size) {
    const result = new Uint8Array(size);
    let offset = 0;
    while (!state.done) {
      result.set(state.value, offset);
      offset += state.value.length;
      state = await reader.read();
    }
    return result.buffer;
  }

  const parts = [];
  let len = 0;
  while (!state.done) {
    parts.push(state.value);
    len += state.value.length;
    state = await reader.read();
  }
  let offset = 0;
  const result = new Uint8Array(len);
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result.buffer;
}

function list(items, ulStyle = '', liStyle = '') {
  const lis = items.map(
    i =>
      html`
        <li class="${liStyle}">${i}</li>
      `
  );
  return html`
    <ul class="${ulStyle}">
      ${lis}
    </ul>
  `;
}

function secondsToL10nId(seconds) {
  if (seconds < 3600) {
    return { id: 'timespanMinutes', num: Math.floor(seconds / 60) };
  } else if (seconds < 86400) {
    return { id: 'timespanHours', num: Math.floor(seconds / 3600) };
  } else {
    return { id: 'timespanDays', num: Math.floor(seconds / 86400) };
  }
}

function timeLeft(milliseconds) {
  if (milliseconds < 1) {
    return { id: 'linkExpiredAlt' };
  }
  const minutes = Math.floor(milliseconds / 1000 / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (days >= 1) {
    return {
      id: 'expiresDaysHoursMinutes',
      days,
      hours: hours % 24,
      minutes: minutes % 60
    };
  }
  if (hours >= 1) {
    return {
      id: 'expiresHoursMinutes',
      hours,
      minutes: minutes % 60
    };
  } else if (hours === 0) {
    if (minutes === 0) {
      return { id: 'expiresMinutes', minutes: '< 1' };
    }
    return { id: 'expiresMinutes', minutes };
  }
  return null;
}

function platform() {
  if (typeof Android === 'object') {
    return 'android';
  }
  return 'web';
}

const ECE_RECORD_SIZE = 1024 * 64;
const TAG_LENGTH = 16;
function encryptedSize(size, rs = ECE_RECORD_SIZE, tagLength = TAG_LENGTH) {
  const chunk_meta = tagLength + 1; // Chunk metadata, tag and delimiter
  return 21 + size + chunk_meta * Math.ceil(size / (rs - chunk_meta));
}

let translate = function() {
  throw new Error('uninitialized translate function. call setTranslate first');
};
function setTranslate(t) {
  translate = t;
}

module.exports = {
  fadeOut,
  delay,
  allowedCopy,
  bytes,
  percent,
  number,
  copyToClipboard,
  arrayToB64,
  b64ToArray,
  isFile,
  openLinksInNewTab,
  browserName,
  streamToArrayBuffer,
  list,
  secondsToL10nId,
  timeLeft,
  platform,
  encryptedSize,
  setTranslate
};


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webrtc_stacks_FirefoxStack__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webrtc_stacks_FcStack__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_ErrorHandler__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__customErrors__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__customEvents__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__EventLogger__ = __webpack_require__(7);
/*
*Author: Sohom
*Description: class to handale RTC connection related functionality
*              Like Brwoser compatibilty and borrowing it's appropriate stack,
*              calling getUserMedia feature,screen share extension conifiguration etc.
*Version: V 1.0
 */
/*
global import RTC stack Refewrence by including file from ./webrtc-stacks/* */











let VcxRtcSessionId = 103;
var getUserMediaDelayed;
const that = {};
that.deviceList = undefined;
const browserEngineCheck = () => {
    let browser = 'none';

    if ((typeof module !== 'undefined' && module.exports)) {
        browser = 'fake';
    } else if (window.navigator.userAgent.match('Firefox') !== null) {
        // Firefox
        browser = 'mozilla';
    } else if (window.navigator.userAgent.match('Chrome') !== null) {
        browser = 'chrome-stable';
        if (window.navigator.userAgent.match('Electron') !== null) {
            browser = 'electron';
        }
        else if (window.navigator.userAgent.match('Edge') !== null) {
            browser = 'edge';
        }
    } else if (window.navigator.userAgent.match('Safari') !== null) {
        browser = 'safari';
    } else if (window.navigator.userAgent.match('AppleWebKit') !== null) {
        browser = 'safari';
    }else if (window.navigator.userAgent.match('.NET') !== null) {
        browser = 'IE';
    }
    return browser;
};


const getBrowserVersion = () => {
    var userAgent = navigator.userAgent,
        temp,
        Match = userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(Match[1])) {
        temp = /\brv[ :]+(\d+)/g.exec(userAgent) || [];
        return 'IE ' + (temp[1] || '');
    }
    if (Match[1] === 'Chrome') {
        temp = userAgent.match(/\b(OPR|Edge)\/(\d+)/);
        if (temp != null) return temp.slice(1).join(' ').replace('OPR', 'Opera');
    }

    Match = Match[2] ? Match[2] : navigator.appVersion;
    if ((temp = userAgent.match(/version\/([^\s]+)/i)) != null) Match = temp[1];
    return Match;
}
const isCurrentVerLess = (verToCheck) => {
  let currVer = getBrowserVersion();
    if (typeof verToCheck !== 'string') return false;
    let v1 = currVer.split('.');
    let v2 = verToCheck.split('.');
    const k = Math.min(v1.length, v2.length);
    for (let i = 0; i < k; ++ i) {
        v1[i] = parseInt(v1[i], 10);
        v2[i] = parseInt(v2[i], 10);
        if (v1[i] > v2[i]) return false;
        if (v1[i] < v2[i]) return true;
    }
    return v1.length == v2.length ?  false : (v1.length < v2.length ? false : true);
}
const processDevice = (deviceList) => {
    var devices = {"cam":[],"mic":[]};
    for(var count=0;count<deviceList.length;count++){
        if(deviceList[count].kind === "audioinput"){
            devices.mic.push(deviceList[count]);
        }else if(deviceList[count].kind === "videoinput"){
            devices.cam.push(deviceList[count]);
        }
    }
    return devices;
}

const checkNewDevice = (dvcList) =>{
    if(that.deviceList===undefined){
        return undefined;
    }else{
        var devices = {"cam":[],"mic":[]};
        for(var camC in dvcList.cam){
            var chkFlag = false;
            for(var camS in that.deviceList.cam){
                if(dvcList.cam[camC].deviceId === that.deviceList.cam[camS].deviceId){
                    chkFlag = true;
                }
            }
            if(chkFlag===false){
                devices.cam.push(dvcList.cam[camC]);
            }
        }
        for(var micC in dvcList.mic){
            var chkFlag = false;
            for(var micS in that.deviceList.mic){
                if(dvcList.mic[micC].deviceId === that.deviceList.mic[micS].deviceId){
                    chkFlag = true;
                }
            }
            if(chkFlag===false){
                devices.mic.push(dvcList.mic[micC]);
            }
        }
       if(devices.cam.length ===0 && devices.mic.length===0){
            return undefined;
       }else{
            that.deviceList = dvcList;
            return devices;
       }
    }
}

const mediaDeviceUpdate = (callback) =>{
    if(browserEngineCheck() ==='safari'){
        setInterval(function(){
            getDeviceList(function (dvL) {
                if(that.deviceList===undefined){
                    that.deviceList = dvL;
                }else{
                    var newDvList = checkNewDevice(dvL);
                    if(newDvList!==undefined){
                        callback(newDvList);
                    }
                }
            });
        },3000);
    }else{
        navigator.mediaDevices.ondevicechange = function(event) {
            getDeviceList(function (dvL) {
                if(that.deviceList===undefined){
                    that.deviceList = dvL;
                }else{
                    var newDvList = checkNewDevice(dvL);
                    if(newDvList!==undefined){
                        callback(newDvList);
                    }
                }
            });
        }
    }
}
const getMediaPermission = (callback) => {
    if(browserEngineCheck() === 'IE' || browserEngineCheck() === 'edge'){
        callback(null, __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1153);
        return;
    }
    navigator.mediaDevices.getUserMedia({ audio: true, video: true })
        .then((stream) => {
            callback(stream, null);
        }).catch((err) => {
            err = Object(__WEBPACK_IMPORTED_MODULE_4__utils_ErrorHandler__["a" /* default */])(err);
            callback(null, err);
            __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error(`Failed to get media devices permission: ${JSON.stringify(err)}`);
            __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_gum_failed, {error:err});
        });
}
const getList = (callback) =>{
    navigator.mediaDevices.enumerateDevices()
        .then(function(dv){
            callback(dv);
        })
        .catch(function(err){
            err = Object(__WEBPACK_IMPORTED_MODULE_4__utils_ErrorHandler__["a" /* default */])(err);
            callback(err);
            __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error(`Cannot get device list:  ${JSON.stringify(err)}`);
            __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_gum_failed, {error:err});
        });
}
const getDeviceList = (callback) => {
    getMediaPermission(function(stream, error){
        if(stream || (error && (error.result === __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1145.result))) {
            getList(function (deviceList, errorList) {
                if(deviceList) {
                    var dvc = processDevice(deviceList);
                    callback({result: 0, devices: dvc});
                }
                else{
                    callback(((error && (error.result === __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1145.result)) ? error : errorList));
                }
            });
        }
        else {
            callback(error)
        }
    });
}
const buildPair = (specInput) => {
    let that = {};
    const spec = specInput;
    VcxRtcSessionId += 1;
    spec.sessionId = VcxRtcSessionId;

    // Check which WebRTC Stack is installed.
    that.browser = browserEngineCheck();
    if (that.browser === 'fake') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].warning('Publish/subscribe video/audio streams not supported in media yet');
        that = Object(__WEBPACK_IMPORTED_MODULE_2__webrtc_stacks_FcStack__["a" /* default */])(spec);
    } else if (that.browser === 'mozilla') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Firefox Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_1__webrtc_stacks_FirefoxStack__["a" /* default */])(spec);
    } else if (that.browser === 'safari') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Safari using Chrome Stable Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__["a" /* default */])(spec);
    } else if (that.browser === 'chrome-stable' || that.browser === 'electron') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Chrome Stable Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__["a" /* default */])(spec);
    }else if (that.browser === 'IE') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('IE using Chrome Stable Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__["a" /* default */])(spec);
    }else {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error('No stack available for this browser');
        throw new Error('WebRTC stack not available');
    }
    if (!that.updateSpec) {
        that.updateSpec = (newSpec, callback = () => {}) => {
            __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error('Update Configuration not implemented in this browser');
            callback('unimplemented');
        };
    }

    return that;
};
const getPlugin = () => {
    return document.getElementById('WebrtcEverywherePluginId');
}
var attachEventListener = function (video, type, listener, useCapture) {
    video.addEventListener(type, listener, useCapture);
}
const GetUserMedia = (config, callback = () => {}, error = () => {}) => {
    let screenConfig;
    let getUserMedia;
    let getDisplayMedia;
    let browser = browserEngineCheck();
    if(browser === 'chrome-stable' || browser === 'electron' || browser === 'mozilla' || browser === 'safari' ){
        getUserMedia = (userMediaConfig, cb, errorCb) => {
            navigator.mediaDevices.getUserMedia(userMediaConfig).then(cb).catch(errorCb);
         };
        getDisplayMedia = (userMediaConfig, cb, errorCb) => {
            navigator.mediaDevices.getDisplayMedia(userMediaConfig).then(cb).catch(errorCb);
         };

    }else{
        getUserMedia = navigator.getUserMedia =  (userMediaConfig, cb, errorCb) => {
            if (document.readyState !== "complete") {
                if (!getUserMediaDelayed) {
                    getUserMediaDelayed = true;
                    attachEventListener(document, "readystatechange", function () {
                        if (getUserMediaDelayed && document.readyState == "complete") {
                            getUserMediaDelayed = false;
                            getPlugin().getUserMedia(userMediaConfig, cb, errorCb);
                        }
                    });
                }
            }
           else {
                getPlugin().getUserMedia(userMediaConfig, cb, errorCb);
           }
        }
    }

    /*Author:Sohom
    *Description: configure screen sharing method/extension
    * */
    const configureScreensharing = () => {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Screen access requested');
        switch (browserEngineCheck()) {
            case 'electron' :
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Screen sharing in Electron');
                screenConfig = {};
                screenConfig.video = config.video || {};
                screenConfig.video.mandatory = config.video.mandatory || {};
                screenConfig.video.mandatory.chromeMediaSource = 'screen';
                getUserMedia(screenConfig, callback, error);
                break;
            case 'mozilla':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Screen sharing in Firefox');
                screenConfig = {};
                if (config.video !== undefined) {
                    screenConfig.video = config.video;
                    screenConfig.video.mediaSource = 'window' || 'screen';
                } else {
                    screenConfig = {
                        audio: config.audio,
                        video: { mediaSource: 'window' || 'screen' },
                    };
                }
                if(isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__["a" /* default */].constant.FIREFOX_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT)){
                  getUserMedia(screenConfig, callback, error);
                }else{
                    screenConfig.video = true;
                    getDisplayMedia(screenConfig,callback,error);
                }
                break;

            case 'chrome-stable':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Screen sharing in Chrome');
                screenConfig = {};
                if (config.desktopStreamId) {
                    screenConfig.video = config.video || { mandatory: {} };
                    screenConfig.video.mandatory = screenConfig.video.mandatory || {};
                    screenConfig.video.mandatory.chromeMediaSource = 'desktop';
                    screenConfig.video.mandatory.chromeMediaSourceId = config.desktopStreamId;
                    getUserMedia(screenConfig, callback, error);
                } else {
                  if (isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__["a" /* default */].constant.CHROME_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT)){
                    let extensionId = 'apedaiecomcfkjdjbnkfcdafaikkdkeo';
                    if (config.extensionId) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug(`extensionId supplied, using ${config.extensionId}`);
                        extensionId = config.extensionId;
                    }
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Screen access on chrome stable, looking for extension');
                    try {
                        chrome.runtime.sendMessage(extensionId,{getStream: true}, (response) => {
                            if (response === undefined) {
                                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error('Access to screen denied');
                                const theError = { code: 'Access to screen denied' };
                                error(theError);
                            }
                            else {
                                    const theId = response.streamId;
                                    if (config.video.mandatory !== undefined) {
                                        screenConfig.video = config.video;
                                        screenConfig.video.mandatory.chromeMediaSource = 'desktop';
                                        screenConfig.video.mandatory.chromeMediaSourceId = theId;
                                    } else {
                                        screenConfig = {
                                            video: {
                                                mandatory: {
                                                    maxFrameRate: 5,
                                                    chromeMediaSource: 'desktop',
                                                    chromeMediaSourceId: theId
                                                }
                                            }
                                        };
                                    }
                                    getUserMedia(screenConfig, callback, error);
                                }
                         });
                    } catch (e) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Screensharing plugin is not accessible ');
                        const theError = { code: 'no_plugin_present' };
                        error(theError);
                    }
                  }else {
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Screen sharing in Chrome without extension');
                    screenConfig.video = true;
                    getDisplayMedia(screenConfig,callback,error);
                  }
                }
                break;

            default:
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error('This browser does not support ScreenSharing');
        }
    };

    if (config.screen) {
        configureScreensharing();
    } else if (typeof module !== 'undefined' && module.exports) {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error('Video/audio streams not supported in controller yet');
    } else {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Calling getUserMedia with config', JSON.stringify(config));
        getUserMedia(config, callback, error);
    }
};



const GetCanvasStream =  (config, callback = () => {}, error = () => {}) => {
    let CaptureStream;
    let canvas = null, stream = null;
    let browser = browserEngineCheck();
    if(browser === 'chrome-stable' || browser === 'mozilla' || browser === 'safari' ){
        CaptureStream = (config, cb, errorCb) => {
            let canvasFps = config.canvas.fps;
            __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].info('canvas fps: ', canvasFps);
            console.log('captureStream called...');
            let canvasId = config.canvas.canvasId;
            canvas = document.querySelector('#' + canvasId);
            if(canvas === null && typeof(canvas) === 'object' ){
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].info('DOM Element does not exists. DomId is: ', canvasId);
                errorCb(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1157);
            }
            else if(canvasFps < 0){
                errorCb(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1154)
            }
            else{
                stream = canvas.captureStream(canvasFps);
                if(stream){
                    cb(stream);
                }
                else {
                    // stream not found
                    errorCb(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1159);
                }
            }
        };
    }else{
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1158);
    }


    const configureCanvasSharing = () => {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Canvas initiating..');
        switch (browserEngineCheck()) {
            case 'electron' :
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Canvas sharing in Electron');
                break;
            case 'mozilla':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Canvas sharing in Firefox');
                try{
                    CaptureStream(config, callback, error);
                }
                catch (e){
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].info('Canvas ff err: ', e);
                    error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1154);
                }
                break;
            case 'chrome-stable':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Canvas sharing in Chrome');
                try{
                    CaptureStream(config, callback, error);
                }
                catch (e){
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].info('Canvas chrome err: ', JSON.stringify(e));
                    error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1154);
                }
                break;
            case 'safari':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].debug('Canvas sharing in safari');
                try{
                    CaptureStream(config, callback, error);
                }
                catch (e){
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].info('Canvas safari err: ', JSON.stringify(e));
                    error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1154);
                }
                break;
            default:
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error('This browser does not support canvas');
                error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1158);
        }
    };
    if(config.canvas){
        configureCanvasSharing();
    }
    else if (typeof module !== 'undefined' && module.exports) {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["a" /* default */].error('Canvas streams not supported in controller yet');
    }

}


const Connection = { GetUserMedia, buildPair, browserEngineCheck , mediaDeviceUpdate , getDeviceList, getBrowserVersion, GetCanvasStream, isCurrentVerLess};

/* harmony default export */ __webpack_exports__["a"] = (Connection);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(162)(module)))

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const customErrors = {
    "error_000": {
        "result": 0,
        "msg": "success"
    },
    "error_1140": {
        "result": 1140,
        "error": "Previous media device operation in process",
        "desc": ""
    },
    "error_1141": {
        "result": 1141,
        "error": "Remote streams can't be muted",
        "desc": ""
    },
    "error_1142": {
        "result": 1142,
        "error": "Invalid Device Id",
        "desc": "OverconstrainedError: Invalid device id provided"
    },
    "error_1143": {
        "result": 1143,
        "error": "Requested device not found",
        "desc": "NotFoundError: Requested device was not found"
    },
    "error_1144": {
        "result": 1144,
        "error": "Permission denied",
        "desc": "NotAllowedError: The request is not allowed by the user agent or the platform in the current context"
    },
    "error_1145": {
        "result": 1145,
        "error": "Could not start video source",
        "desc": "NotReadableError: Could not start video source"
    },
    "error_1146": {
        "result": 1146,
        "error": "Failed to execute getUserMedia on MediaDevices",
        "desc": "TypeError: At least one of audio and video must be requested"
    },
    "error_1147": {
        "result": 1147,
        "error": "Constraints could be not satisfied",
        "desc": "OverconstrainedError: Video width constraint could not be satisfied"
    },
    "error_1148": {
        "result": 1148,
        "error": "Constraints could be not satisfied",
        "desc": "OverconstrainedError: Video height constraint could not be satisfied"
    },
    "error_1149": {
        "result": 1149,
        "error": "Constraints could be not satisfied",
        "desc": "One of the constraints (Height, Width, DeviceId) is not satisfied."
    },
    "error_1150": {
        "result": 1150,
        "error": "Reason unknown",
        "desc": "Reason unknown"
    },
    "error_1151": {
        "result": 1151,
        "error": "A screen share is already running",
        "desc": ""
    },
    "error_1152": {
        "result": 1152,
        "error": "Audio only calls are allowed with your current browser version",
        "desc": ""
    },
    "error_1153": {
        "result": 1153,
        "error": "Unsupported browser",
        "desc": ""
    },
    "error_1154": {
        "result": 1154,
        "error": "Given frame rate is not supported",
        "desc": "Frame rate might be negative or not a number which is not accepted by captureStream method"
    },
    "error_1155": {
        "result": 1155,
        "error": "Invalid options/parameters",
        "desc": "Invalid options parameters "
    },
    "error_1156": {
        "result": 1156,
        "error": "Invalid streamType",
        "desc": " streamType  should be set as canvas for canvas streams and talker for talker streams"
    },
    "error_1157": {
        "result": 1157,
        "error": "The given canvas element does not exist in the DOM",
        "desc": "The canvas element you have provided does not exist in the DOM"
    },
    "error_1158": {
        "result": 1158,
        "error": "This browser does not support canvas",
        "desc": "This browser does not support canvas"
    },
    "error_1159": {
        "result": 1159,
        "error": "Stream not found",
        "desc": "Stream not found"
    },
    "error_1160": {
        "result": 1160,
        "error": "Media connection failure",
        "desc": "Media connection failure"
    },
    "error_1161": {
        "result": 1161,
        "error": "Server connection failure",
        "desc": "Server connection failure"
    },
    "error_1162": {
        "result": 1162,
        "error": "The DOM element does not exist",
        "desc": "The element with DOM reference provided does not exist"
    },
    "error_1163": {
        "result": 1163,
        "error": "Network disconnected",
        "desc": "Socket or media connection has failed due to network error"
    },
    "error_1164": {
        "result": 1164,
        "error": "Network reconnected",
        "desc": "Network reconnected"
    },
    "error_1165": {
        "result": 1165,
        "error": "Reconnect attempt exceeded",
        "desc": "Reconnection failed"
    },
    "error_1166": {
        "result": 1166,
        "error": "Reconnection timed out",
        "desc": "Reconnection failed"
    },
    "error_1167": {
        "result": 1167,
        "error": "Publish or subscribe failed",
        "desc": "After reconnection publish or subscibe failed"
    },
    "error_1168": {
        "result": 1168,
        "error": "Not allowed",
        "desc": "Only moderator has rights to excercise this transaction"
    },
    "error_1169": {
        "result": 1169,
        "msg": "No listener for event",
        "desc": ""
    },
    "error_1170": {
        "result": 1170,
        "error": "Not supported",
        "desc": "Feature is not enabled with Current licence "
    },
    "error_1171": {
        "result": 1171,
        "error": "Room not connected",
        "desc": "Room not connected"
    },
    "error_1172": {
        "result": 1172,
        "error": "Room connect failed",
        "desc": "Room connect failed"
    },
    "error_1173": {
        "result": 1173,
        "error": "Floor not granted for participant",
        "desc": "Floor not granted"
    },
    "error_1174": {
        "result": 1174,
        "error": "Local Recording started already",
        "desc": ""
    },
    "error_1175": {
        "result": 1175,
        "error": "Local Recording not started /stream not having media",
        "desc": ""
    },
	"error_1176": {
        "result": 1176,
        "error": "Moderator declined right to control media devices ",
        "desc": ""
    },
    "error_1177": {
        "result": 1177,
        "error": "MediaDevice state is already in same state",
        "desc": ""
    },
    "error_1178": {
        "result": 1178,
        "error": "Reconnection for a single participant in the room is not allowed",
        "desc": "Reconnection not allowed"
    },
    "error_1179": {
        "result": 1179,
        "error": " files to upload input array size is 0",
        "desc": " empty file transfer is not allowed"
    },
    "error_1180": {
        "result": 1180,
        "error": " room is disconected",
        "desc": " file sharing is not allowed on disconnected rooms"
    },
    "error_1181": {
        "result": 1181,
        "error": " Recieve file operation is not permitted.",
        "desc": " File which you are trying to receive  does not exist."
    },
    "error_1182": {
        "result": 1182,
        "error": "file upload failed",
        "desc": "file upload failed "
    },
    "error_1183": {
        "result": 1183,
        "error": " file download failed ",
        "desc": " file download failed"
    },
    "error_1184": {
        "result": 1184,
        "error": " user video resolution inavlid range",
        "desc": " "
    },
    "error_1185": {
        "result": 1185,
        "error": "file upload failed ",
        "desc": "file upload failed because provided file list is empty"
    },
    "error_1186": {
        "result": 1186,
        "error": "file upload failed ",
        "desc": "file size is zero bytes"
    },
    "error_1187": {
        "result": 1187,
        "error": "file upload failed ",
        "desc": "file upload failed because it exceeded max upload limit"
    },
}

/* harmony default export */ __webpack_exports__["a"] = (customErrors);


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
This file is for View Properties.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/
/*
 * ViewProperties class stores some default constant value of View
 */
const ViewProperties = () => {
const that = { 'player' : {
        'default': {
            'autoplay': 'autoplay',
            'name': '',
            'nameDisplayMode': '',
            'frameFitMode': 'bestFit',
            'skin': 'default',
            'class': '',
            'height': '240px',
            'width': '320px',
            'minHeight': '200px',
            'minWidth': '250px',
            'aspectRatio': '16:9',
            'volume': 5,
            'media': '',
            'loader': {
                'show': true,
                'style':'default',
                'class': ''
            }
        }
    },
    'brand' : {
        'default': {
            'display': true,
            'url': 'http://www.vcloudx.com',
            'logo': '/assets/favicon.png',
            'show': true,
            'target': '_blank',
            'title': 'VCloudX Infotech'
        }
    },
    'toolbar' : {
        'default': {
            'skin': 'default',
            'buttons': {
                'play': true,
                'resize': true,
                'share': true,
                'mic': true,
                'volume': true,
                'mute': true,
                'record': true,
                'playtime': true,
                'zoom': true
            },
            'position': 'bottom',
            'class': '',
            'displayMode': true,
            'autoDisplayTimeout': 0
        }
    }
};

return that;
};
/* harmony default export */ __webpack_exports__["a"] = (ViewProperties);

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export setFileProtocolWssUrl */
/* unused harmony export getFileProtocolWssUrl */
/* harmony export (immutable) */ __webpack_exports__["d"] = getApiUrl;
/* unused harmony export setApiUrlPrefix */
/* unused harmony export getApiCallInfoParams */
/* unused harmony export setApiCallInfoParams */
/* harmony export (immutable) */ __webpack_exports__["f"] = setFileShareServiceEndPoint;
/* unused harmony export parseNonce */
/* harmony export (immutable) */ __webpack_exports__["a"] = del;
/* harmony export (immutable) */ __webpack_exports__["g"] = setParams;
/* harmony export (immutable) */ __webpack_exports__["c"] = fileInfo;
/* harmony export (immutable) */ __webpack_exports__["e"] = metadata;
/* harmony export (immutable) */ __webpack_exports__["h"] = setPassword;
/* harmony export (immutable) */ __webpack_exports__["i"] = uploadWs;
/* unused harmony export downloadStream */
/* harmony export (immutable) */ __webpack_exports__["b"] = downloadFile;
/* unused harmony export getFileList */
/* unused harmony export setFileList */
/* unused harmony export sendMetrics */
/* unused harmony export getConstants */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ece__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Logger__ = __webpack_require__(1);





var fileShareService = {};
let fileProtocolWssUrl = null;
var host = '';
var port = '';

if (!fileProtocolWssUrl) {
  // fileProtocolWssUrl = 'wss://vc-manu.vcloudx.com:9090/api/ws';
  fileProtocolWssUrl = '';
}

class ConnectionError extends Error {
  constructor(cancelled, duration, size) {
    super(cancelled ? '0' : 'connection closed');
    this.cancelled = cancelled;
    this.duration = duration;
    this.size = size;
  }
}
/* unused harmony export ConnectionError */




function setFileProtocolWssUrl(url) {
  fileProtocolWssUrl = url;
}

function getFileProtocolWssUrl() {
  return fileProtocolWssUrl;
}

//let apiUrlPrefix = 'https://vc-manu.vcloudx.com:9090'
let apiUrlPrefix = '';
function getApiUrl(path) {
  return apiUrlPrefix + path;
}

function setApiUrlPrefix(prefix) {
  apiUrlPrefix = prefix;
}

// callInfo params for every fsAPI call info
// currently setting callinfo from client , we may need to change it and once utality token comes in picture we can fetch at server side from dapi
let callInfo = {};
/*
callInfo ={
  "userName":'',
  "trans_dt":'',
  "room_id":'',
  "service_id":"",
  "conf_num":"",
  "call_num":"",
  "file_meta":{}
} */
function getApiCallInfoParams(file_meta = {}) {
  callInfo.file_meta = file_meta;
  callInfo.trans_dt = Date.now();
  // Logger.info('getApiCallInfoParams ', callInfo);
  return callInfo;
}
function setApiCallInfoParams(callDetails) {
  __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info(' file sharing service call details', callDetails);
  callInfo.userName = callDetails.userName;
  callInfo.room_id = callDetails.room_id;
  callInfo.conf_num = callDetails.conf_num;
  callInfo.call_num = callDetails.call_num;
  callInfo.service_id = callDetails.service_id;

}
function setFileShareServiceEndPoint(fileShareService) {
  if (fileShareService != undefined && fileShareService.url != undefined && fileShareService.hostName != undefined && fileShareService.port != undefined) {
    setApiUrlPrefix(fileShareService.url);
    host = fileShareService.hostName;
    port = fileShareService.port;
    setFileProtocolWssUrl('wss' + ':' + '//' + host + ':' + port + '/api/ws');
   // Logger.info(' file server end points ' + host + port + apiUrlPrefix + fileProtocolWssUrl);
    setApiCallInfoParams(fileShareService.callInfo);
  }
}



function post(obj, bearerToken) {
  const h = {
    'Content-Type': 'application/json'
  };
  if (bearerToken) {
    h['Authentication'] = `Bearer ${bearerToken}`;
  }
  return {
    method: 'POST',
    headers: new Headers(h),
    body: JSON.stringify(obj)
  };
}

function parseNonce(header) {
  header = header || '';
  return header.split(' ')[1];
}

async function fetchWithAuth(url, params, keychain) {
  const result = {};
  params = params || {};
  const h = await keychain.authHeader();
  params.headers = new Headers({ Authorization: h });
  //params.mode = 'cors';
  const response = await fetch(url, params);
  result.response = response;
  result.ok = response.ok;
  const nonce = parseNonce(response.headers.get('WWW-Authenticate'));
  result.shouldRetry = response.status === 401 && nonce !== keychain.nonce;
  keychain.nonce = nonce;
  return result;
}

async function fetchWithAuthAndRetry(url, params, keychain) {
  const result = await fetchWithAuth(url, params, keychain);
  if (result.shouldRetry) {
    return fetchWithAuth(url, params, keychain);
  }
  return result;
}

async function del(id, owner_token) {
  const response = await fetch(
    getApiUrl(`/api/delete/${id}`),
    post({ owner_token })
  );
  return response.ok;
}

async function setParams(id, owner_token, bearerToken, params) {
  const response = await fetch(
    getApiUrl(`/api/params/${id}`),
    post(
      {
        owner_token,
        dlimit: params.dlimit
      },
      bearerToken
    )
  );
  return response.ok;
}

async function fileInfo(id, owner_token) {
  const response = await fetch(
    getApiUrl(`/api/info/${id}`),
    post({ owner_token })
  );

  if (response.ok) {
    const obj = await response.json();
    return obj;
  }

  throw new Error(response.status);
}

async function metadata(id, keychain) {

  const result = await fetchWithAuthAndRetry(
    getApiUrl(`/api/metadata/${id}`),
    { method: 'GET' },
    keychain
  );
  if (result.ok) {
    const data = await result.response.json();
    const meta = await keychain.decryptMetadata(Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(data.metadata));
    return {
      size: meta.size,
      ttl: data.ttl,
      iv: meta.iv,
      name: meta.name,
      type: meta.type,
      manifest: meta.manifest
    };
  }
  throw new Error(result.response.status);
}

async function setPassword(id, owner_token, keychain) {
  const auth = await keychain.authKeyB64();
  const response = await fetch(
    getApiUrl(`/api/password/${id}`),
    post({ owner_token, auth })
  );
  return response.ok;
}

function asyncInitWebSocket(server) {
  return new Promise((resolve, reject) => {
    try {
      const ws = new WebSocket(server);
      ws.addEventListener('open', () => resolve(ws), { once: true });
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info('asyncInitWebSocket exception while creating websocket', e);
      reject(new ConnectionError(false));
    }
  });
}

function listenForResponse(ws, canceller) {
  return new Promise((resolve, reject) => {
    function handleClose(event) {
      // a 'close' event before a 'message' event means the request failed
      ws.removeEventListener('message', handleMessage);
      reject(new ConnectionError(canceller.cancelled));
    }
    function handleMessage(msg) {
      ws.removeEventListener('close', handleClose);
      try {
        const response = JSON.parse(msg.data);
        if (response.error) {
          __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error(' listenForResponse throw exception ', response.error);
          throw new Error(response.error);
        } else {
          resolve(response);
        }
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error(' listenForResponse exception ', e);

        reject(e);
      }
    }
    ws.addEventListener('message', handleMessage, { once: true });
    ws.addEventListener('close', handleClose, { once: true });
  });
}

async function upload(
  stream,
  metadata,
  verifierB64,
  timeLimit,
  dlimit,
  bearerToken,
  file_info,
  onprogress,
  canceller
) {
  let size = 0;
  const start = Date.now();

  //const host ='vc-manu.vcloudx.com';//'192.168.200.110';
  //const port = '9090'
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const endpoint =
    window.location.protocol === 'file:'
      ? fileProtocolWssUrl
      : `${protocol}//${host}${port ? ':' : ''}${port}/api/ws`;

  //Logger.info('web socket end point for file server ',endpoint);
  const ws = await asyncInitWebSocket(endpoint);

  try {
    const metadataHeader = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["arrayToB64"])(new Uint8Array(metadata));
    // get the room meta
    let callInfo = {};
    callInfo = getApiCallInfoParams(file_info);

    const fileMeta = {
      fileMetadata: metadataHeader,
      authorization: `send-v1 ${verifierB64}`,
      bearer: bearerToken,
      timeLimit,
      dlimit,
      callInfo
    };
    const uploadInfoResponse = listenForResponse(ws, canceller);
    ws.send(JSON.stringify(fileMeta));
    const uploadInfo = await uploadInfoResponse;

    const completedResponse = listenForResponse(ws, canceller);

    const reader = stream.getReader();
    let state = await reader.read();
    while (!state.done) {
      if (canceller.cancelled) {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info(' websocket upload cancelled');
        ws.close();
      }
      if (ws.readyState !== WebSocket.OPEN) {
        break;
      }
      const buf = state.value;
      ws.send(buf);
      onprogress(size);
      size += buf.length;
      state = await reader.read();
      while (
        ws.bufferedAmount > __WEBPACK_IMPORTED_MODULE_1__ece__["a" /* ECE_RECORD_SIZE */] * 2 &&
        ws.readyState === WebSocket.OPEN &&
        !canceller.cancelled
      ) {
        await Object(__WEBPACK_IMPORTED_MODULE_0__utils__["delay"])();
      }
    }
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(new Uint8Array([0])); //EOF
    }

    await completedResponse;
    uploadInfo.duration = Date.now() - start;
    return uploadInfo;
  } catch (e) {
    e.size = size;
    e.duration = Date.now() - start;
    __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info(' websocket upload failed', e);
    throw e;
  } finally {
    if (![WebSocket.CLOSED, WebSocket.CLOSING].includes(ws.readyState)) {
      ws.close();
    }
  }
}

function uploadWs(
  encrypted,
  metadata,
  verifierB64,
  timeLimit,
  dlimit,
  bearerToken,
  file_info,
  onprogress
) {
  const canceller = { cancelled: false };

  return {
    cancel: function () {
      canceller.cancelled = true;
    },

    result: upload(
      encrypted,
      metadata,
      verifierB64,
      timeLimit,
      dlimit,
      bearerToken,
      file_info,
      onprogress,
      canceller
    )
  };
}

////////////////////////

async function downloadS(id, keychain, signal) {
  const auth = await keychain.authHeader();

  const response = await fetch(getApiUrl(`/api/download/${id}`), {
    signal: signal,
    method: 'GET',
    headers: { Authorization: auth }
  });

  const authHeader = response.headers.get('WWW-Authenticate');
  if (authHeader) {
    keychain.nonce = parseNonce(authHeader);
  }

  if (response.status !== 200) {
    throw new Error(response.status);
  }

  return response.body;
}

async function tryDownloadStream(id, keychain, signal, tries = 2) {
  try {
    const result = await downloadS(id, keychain, signal);
    return result;
  } catch (e) {
    if (e.message === '401' && --tries > 0) {
      return tryDownloadStream(id, keychain, signal, tries);
    }
    if (e.name === 'AbortError') {
      throw new Error('0');
    }
    throw e;
  }
}

function downloadStream(id, keychain) {
  const controller = new AbortController();
  function cancel() {
    controller.abort();
  }
  return {
    cancel,
    result: tryDownloadStream(id, keychain, controller.signal)
  };
}

//////////////////

async function download(id, keychain, onprogress, canceller) {
  const auth = await keychain.authHeader();
  const xhr = new XMLHttpRequest();
  canceller.oncancel = function () {
    xhr.abort();
  };
  return new Promise(function (resolve, reject) {
    xhr.addEventListener('loadend', function () {
      canceller.oncancel = function () { };
      const authHeader = xhr.getResponseHeader('WWW-Authenticate');
      if (authHeader) {
        keychain.nonce = parseNonce(authHeader);
      }
      if (xhr.status !== 200) {
        return reject(new Error(xhr.status));
      }

      const blob = new Blob([xhr.response]);
      resolve(blob);
    });

    xhr.addEventListener('progress', function (event) {
      if (event.target.status === 200) {
        onprogress(event.loaded);
      }
    });
    xhr.open('get', getApiUrl(`/api/download/blob/${id}`));
    xhr.setRequestHeader('Authorization', auth);
    xhr.responseType = 'blob';
    xhr.send();
    onprogress(0);
  });
}

async function tryDownload(id, keychain, onprogress, canceller, tries = 2) {
  try {
    const result = await download(id, keychain, onprogress, canceller);
    return result;
  } catch (e) {
    if (e.message === '401' && --tries > 0) {
      return tryDownload(id, keychain, onprogress, canceller, tries);
    }
    throw e;
  }
}

function downloadFile(id, keychain, onprogress) {
  const canceller = {
    oncancel: function () { } // download() sets this
  };
  function cancel() {
    canceller.oncancel();
  }
  return {
    cancel,
    result: tryDownload(id, keychain, onprogress, canceller)
  };
}

async function getFileList(bearerToken, kid) {
  const headers = new Headers({ Authorization: `Bearer ${bearerToken}` });
  const response = await fetch(getApiUrl(`/api/filelist/${kid}`), { headers });
  if (response.ok) {
    const encrypted = await response.blob();
    return encrypted;
  }
  throw new Error(response.status);
}

async function setFileList(bearerToken, kid, data) {
  const headers = new Headers({ Authorization: `Bearer ${bearerToken}` });
  const response = await fetch(getApiUrl(`/api/filelist/${kid}`), {
    headers,
    method: 'POST',
    body: data
  });
  return response.ok;
}

function sendMetrics(blob) {
  if (!navigator.sendBeacon) {
    return;
  }
  try {
    navigator.sendBeacon(getApiUrl('/api/metrics'), blob);
  } catch (e) {
    console.error(e);
  }
}

async function getConstants() {
  const response = await fetch(getApiUrl('/config'));

  if (response.ok) {
    const obj = await response.json();
    return obj;
  }

  throw new Error(response.status);
}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(155)
var ieee754 = __webpack_require__(179)
var isArray = __webpack_require__(180)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(157)))

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Pair__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Socket__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Stream__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__views_Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_VcxRtcMap__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_Base64__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__customErrors__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Enx_config_js__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Enx_config_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__Enx_config_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__customEvents__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__EventLogger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__fileShare_app_api__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__fileShare_app_fileSender__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__fileShare_app_archive__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__fileShare_app_fileReceiver__ = __webpack_require__(187);
/*
*Author: Sohom
*Description: Class Room represents a VCX Room. It will handle the connection, local stream publication and
 *            remote stream subscription.
 * Typical Room shall initilized: var room = Client.Room({token:'213h8012hwduahd-321ueiwqewq'});
 * It also handles RoomEvents and StreamEvents. For example:
 * Event 'room-connected' refers that the user has been successfully connected to the room.
 * Event 'room-disconnected' refers that the user has been already disconnected.
 * Event 'stream-added' refers that there is a new stream available in the room.
 * Event 'stream-removed' refers that a previous available stream has been removed from the room.
 *Version: V 1.0
 */













// file sharing





let statsIcon = `<svg  viewBox="0 0 16 16" width="16" height="16" xml:space="preserve" fill="green"><rect height="6" width="4" y="10"/><rect height="10" width="4" x="6" y="6"/><rect height="16" width="4" x="12"/></svg>`;

window.statsIcon = statsIcon;

const Room = (altIo, altConnection, specInput) => {

    const that = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["b" /* EventDispatcher */])(specInput);
    const DISCONNECTED = 0;
    const CONNECTING = 1;
    const CONNECTED = 2;
    let detectInternetStatus = undefined;
    // default reconnectInfo parameters
    const defReconnectInfo = { 'allow_reconnect': true, 'number_of_attempts': 3, 'timeout_interval': 45000 };
    // file receive test
    that.filesToUpload = [];
    that.f2rec = {};
    that.availableFiles = [];
    let uploadsInProgress = new Map ();
    let downloadsInProgress = new Map();

    let shFileList = [];
    let maxFileSize = 10 * 1024 * 1024 ;
    let fileShareUI = {
        enable: false,
        uploadElToAppend: '',
        recvElToAppend: '',
    }
    that.showFsUi = false;
    // end ft test
    const spec = specInput;
    that.internetDetectionUrl = "https://api.enablex.io/"; // ajax resource url to detect the network
    that.remoteStreams = Object(__WEBPACK_IMPORTED_MODULE_5__utils_VcxRtcMap__["a" /* default */])();
    that.localStreams = Object(__WEBPACK_IMPORTED_MODULE_5__utils_VcxRtcMap__["a" /* default */])();
    that.roomID = '';
    that.talkerCount = 0;
    that.userTalkerCount = 0;
    that.state = DISCONNECTED;
    that.Connection = altConnection === undefined ? __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */] : altConnection;
    that.receiveVideoQuality = new Map();
    that.receiveVideoQuality.set("talker", "Auto");
    that.receiveVideoQuality.set("canvas", "HD");

    let socket = Object(__WEBPACK_IMPORTED_MODULE_2__Socket__["a" /* Socket */])(altIo);
    that.socket = socket;
    that.userList = new Map();
    that.cControlReq = undefined;
    that.cCrequest = [];
    that.awaitedParticipants = new Map();
    that.floorGranted = false;
    that.roomJson = undefined;
    that.clientId = undefined;
    that.activeTalker = false;
    that.shareStatus = false;
    that.canvasStatus = false;
    that.activeTalkerList = new Map();
    let token = JSON.parse(__WEBPACK_IMPORTED_MODULE_6__utils_Base64__["a" /* default */].decodeBase64(spec.token));
    that.reconnectionState = false; //  reconnection
    that.reconnectAttempt = 0;
    let MAXRECONNECTIONATTEMPT = 3;//  kept high value for testing it needs to be changed
    that.sendRecvBitrateStats = false;
    let localRecord = "none";
    let avOptions = {"publish" : {"forceTurn" : false},
                     "subscribe" : {"forceTurn" : false, "imageOnVideoMute":false}};
    let sharePublishOptions = {"forceTurn" : false};
    let canvasPublishOptions = {"forceTurn" : false};
    if (spec.hasOwnProperty('reconnectInfo')) {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('reconnect parameter', spec.reconnectInfo)
        that.reconnectionAllowed = spec.reconnectInfo.allow_reconnect;
        that.reconnectionTimeOutInterval = spec.reconnectInfo.timeout_interval;
        MAXRECONNECTIONATTEMPT = spec.reconnectInfo.number_of_attempts;
    }
    else {
        //  if reconnect params are not  present in the spec info
        that.reconnectionAllowed = defReconnectInfo.allow_reconnect;
        that.reconnectionTimeOutInterval = defReconnectInfo.timeout_interval;
        MAXRECONNECTIONATTEMPT = defReconnectInfo.number_of_attempts;
    }
    let reconStartTime = 0;
    let roomRecordStatus = false;
    let prefNumTakler = -1;
    that.localStreamsBeforeReconnect = Object(__WEBPACK_IMPORTED_MODULE_5__utils_VcxRtcMap__["a" /* default */])();// store all local streams in this before reconnect
    that.oldSpecInfo = undefined;
    that.mediaConfiguration = token.roomMeta.settings.media_configuration ?
        token.roomMeta.settings.media_configuration : 'Default';
    that.maxVideoLayers = 0;
    that.defaultBandwidth = new Map();
    that.defaultBandwidth.set(1, 200000);
    that.defaultBandwidth.set(2, 300000);
    that.defaultBandwidth.set(3, 400000);
    that.defaultBandwidth.set(4, 600000);
    that.defaultBandwidth.set(5, 800000);
    that.defaultBandwidth.set(6, 1000000);
    that.defaultBandwidth.set(7, 1200000);

    that.videoMutedUsers = {};
    let remoteStreams = that.remoteStreams;
    let localStreams = that.localStreams;
    var locStrm = undefined;
    that.hardMuteRoom = false;
    that.me = {};
    that.roomSettings = {};
    that.mute = false;
    that.muteAudioOnJoin = false;
    that.muteVideoOnJoin = false;
    //that.mute = {room: false, audioOnJoin: false, videoOnJoin: false};
    that.cCapprovedHands = [];
    that.externalIp = '';
    let peerStatsInterval;
    that.subscribeSessionStats = false; // session stats display

    that.canvasOptions = { width: 1280, height: 720, domHandle: '' };
    that.inputContext = null;
    that.canvasVideoPlayer = '';
    let videoResolutionRange = __WEBPACK_IMPORTED_MODULE_10__Enx_config_js___default.a.video_resolution_range[token.roomMeta.settings.quality];
    let statsStyle = document.createElement('style');
    let statsCss = `.stats-container{
                        position: absolute;
                        z-index: 5;
                        padding: 2px;
                        top: 2px;
                        right: 2px;
                        font-size: 12px;
                        width: 22px;
                        height: 22px;
                        text-align: center;
                        background: white;
                        border-radius: 10px;
                    }
                    .stats-button{
                        cursor:pointer;
                        width: 15px;
                        height: 15px;
                        padding: 0 0 0 2px;
                    }
                    .stats-detail{ height: 100%;}
                    .stats-overlay-inner{
                        display: flex;
                        flex-direction: row;
                        justify-content: space-between;
                        padding: 8px 2px 6px 10px;
                    }
                    .stats-right-partition, .stats-left-partition {}
                    .stats-left-partition {margin-right: 10px;}
                    .stats-button svg {width: 12px;height: 12px;}
                        `;
    statsStyle.innerHTML = statsCss;

    let bwNotificationStyle = document.createElement('style');
    let bwNotificationCSS = `.bw-notification{
                                position: absolute;
                                //z-index: 5;
                                top:50%;
                                left:50%;
                                margin-top:-50px;
                                margin-left:-100px;
                                padding: 5px;
                                color: #fff;
                                background: rgba(50,50,50,0.5);
                                }`;
    bwNotificationStyle.innerHTML = bwNotificationCSS;


    /*Descirption: Private functions removeStream used to release a strem from a socket
      * Used in: socketOnRemoveStream
      * */
    const removeStream = (streamInput) => {
        const stream = streamInput;
        if (stream.stream) {
            // Remove HTML element
            stream.hide();

            stream.stop();
            stream.close();
            delete stream.stream;
        }

        // Close PC stream
        if (stream.pc) {
            stream.pc.close();
            delete stream.pc;
        }
    };


    const onStreamFailed = (streamInput, message) => {
        const stream = streamInput;
        if ((that.socket.state !== DISCONNECTED) && (that.reconnectionState === false)) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('ICE failed close the socket and wait for reconnection');
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_ice_failed, { stream: stream });

            if (stream.local) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Local stream ICE failed close the socket and wait for reconnection');

                that.socket.disconnect();

            }
        }
        if ((that.state !== DISCONNECTED) && (stream) && (!stream.failed) && (that.reconnectionAllowed === false)) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('ICE failed ---------unpublishing and unsubscibing the stream');
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_ice_failed, { stream: stream });

            stream.failed = true;
            const streamFailedEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])(
                {
                    type: 'stream-failed',
                    msg: message || 'Stream failed after connection',
                    stream
                });
            that.dispatchEvent(streamFailedEvt);
            if (stream.local) {
                that.unpublish(stream);
            } else {
                that.unsubscribe(stream);
            }
        }
    };

    /*
     *Descirption: Private functions dispatchStreamSubscribed used
     * to notify when stream get subscribed
     * Used in: createRemoteStreamConnection
     * */
    const dispatchStreamSubscribed = (streamInput, evt) => {
        const stream = streamInput;
        let peerStatsIntervalSubs;
        // Draw on html
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream subscribed');
        if (evt.stream) {
            stream.initRemoteStream(evt.stream)
            that.remoteStreams.remove(stream.getID());
            that.remoteStreams.add(stream.getID(), stream);
        }

        const evt2 = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])({ type: 'stream-subscribed', stream });
        that.dispatchEvent(evt2);

        // put reconnect condition
        // Play the stream if player is available but stream is paused
        stream.room = that;
        if (stream.screen === true || stream.canvas === true) {
            stream.updateVideo(stream.getID());
        }

        let getPeerData = (result) => {
            if (result) {
                //    clearInterval(peerStatsIntervalSubs);
                let additionalOptions = {
                    streamType: stream.ifScreen() ? 'share' : 'main',
                    streamId: stream.getID(),
                    selectedCandidates: result.selectedCandidates,
                    negotiatedCodecs: {
                        video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                        audio: { codec: 'OPUS' }
                    },
                    externalIp: that.externalIp,
                };
                that.createEventLog('clientStreamSubscribeSuccess', additionalOptions)
            }
        };
        /*   if(stream.pc) {
               peerStatsIntervalSubs = setInterval(() => {
                   getPeerStats(stream.pc.peerConnection, getPeerData);
               }, 1000);
           } */
    };

    /*
          *Descirption: Private functions removeLocalStreamConnection used
          * to release local stream connection i.e socket
          * Used in: socketOnUnpublishMe
          * */

    const getVcxRtcConnectionOptions = (stream, options, isRemote) => {

        var connectionOpts = {
            callback(message) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Sending message', message);
                socket.sendSDP('signaling_message', {
                    streamId: stream.getID(),
                    msg: message,
                    browser: stream.pc.browser
                }, undefined, () => { });
            },
            nop2p: true,
            audio: options.audio && stream.ifAudio(),
            video: options.video && stream.ifVideo(),
            maxAudioBW: options.maxAudioBW,
            maxVideoBW: options.maxVideoBW,
            limitMaxAudioBW: spec.maxAudioBW,
            limitMaxVideoBW: spec.maxVideoBW,
            iceServers: that.iceServers,
            forceTurn: stream.forceTurn
        };
        if (!isRemote) {
            connectionOpts.simulcast = options.simulcast;
        }
        return connectionOpts;
    };

    const createRemoteStreamVcxRtcConnection = (streamInput, options) => {
        const stream = streamInput;
        stream.pc = that.Connection.buildPair(getVcxRtcConnectionOptions(stream, options, true));
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("Create remote connection for subscribe:-" + JSON.stringify(options));
        stream.pc.onaddstream = dispatchStreamSubscribed.bind(null, stream);
        stream.pc.oniceconnectionstatechange = (state) => {
            if (state === 'failed') {
                onStreamFailed(stream);
                // do not send network failed
                //    let networkFailed = RoomEvent({ type: 'network-failed', error: customErrors.error_1160.result,  message: customErrors.error_1160.error });
                //    that.dispatchEvent(networkFailed);
                //    clearAll();
            }
        };

        stream.pc.createOffer(true);
    };
    that.notifyDeviceUpdate = () => {
        __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].mediaDeviceUpdate(function (res) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'user-media-device-list-change', message: res });
            that.dispatchEvent(evt);
        });
    }
    const createLocalStreamVcxRtcConnection = (streamInput, options) => {
        const stream = streamInput;
        stream.pc = that.Connection.buildPair(getVcxRtcConnectionOptions(stream, options));
        if (stream.audioStream) {
            for (const track of stream.audioStream.getAudioTracks()) {
                stream.pc.addTrack(track);
            }
        }
        if (stream.videoStream) {
            for (const track of stream.videoStream.getVideoTracks()) {
                stream.pc.addTrack(track);
            }
        }
        stream.pc.oniceconnectionstatechange = (state) => {
            if (state === 'failed') {
                onStreamFailed(stream);
            }
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('oniceconnectionstatechange state:', state);
        };
        if (!options.createOffer) { stream.pc.createOffer(); }
    };

    // We receive an event with a new stream in the room.
    // type can be "media" or "data"

    const socketOnAddStream = (arg) => {
        const stream = Object(__WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */])(that.Connection, {
            streamID: arg.id,
            local: false,
            clientId: arg.clientId,
            audio: arg.audio,
            video: arg.video,
            data: arg.data,
            screen: arg.screen,
            attributes: arg.attributes
        });
        stream.room = that;
        remoteStreams.add(arg.id, stream);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])({ type: 'stream-added', stream });
        that.dispatchEvent(evt);
    };

    const socketOnRemoveTrack = (arg) => {
        const streamID = arg.id.streamId;
        const updatedSTream = Object(__WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */])(that.Connection, { streamID: streamID });
        videoStop(streamID);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'track-removed', streams: [updatedSTream], message: 'tracked removed from stream: ' + streamID });
        that.dispatchEvent(evt);
    };
    const userConnect = (arg) => {
        const userName = arg.name;
        const userRole = arg.role;
        const userPermissions = arg.permissions;
        const user = { name: arg.name, permissions: arg.permissions, role: arg.role, user_ref: arg.user_ref, videoMuted: arg.videoMuted, audioMuted: arg.audioMuted };
        that.userList.set(arg.clientId, user);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* UserEvent */])({ type: 'user-connected', name: userName, clientId: arg.clientId, role: userRole, permission: userPermissions, user: user });
        that.dispatchEvent(evt);
    };
    const userDisConnect = (arg) => {
        const userName = arg.name;
        const userRole = arg.role;
        const userPermissions = arg.permissions;
        const clientId = arg.clientId;
        that.userList.delete(arg.clientId);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* UserEvent */])({ type: 'user-disconnected', name: userName, clientId: clientId, role: userRole, permission: userPermissions });
        that.dispatchEvent(evt);
    };
    const userSubcribe = (arg) => {
        const userName = arg.name;
        const userRef = arg.user_ref;
        const userRole = arg.role;
        const socket = arg.socket;
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["c" /* PublisherEvent */])({ type: 'user-subscribed', name: userName, role: userRole, user_ref: userRef, socket: socket });
        that.dispatchEvent(evt);
    };
    const userUnSubcribe = (arg) => {
        const userName = arg.name;
        const userRef = arg.user_ref;
        const userRole = arg.role;
        const socket = arg.socket;
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["c" /* PublisherEvent */])({ type: 'user-subscribed', name: userName, role: userRole, user_ref: userRef, socket: socket });
        that.dispatchEvent(evt);
    };
    const videoStop = (id) => {
        var screenSaver = __WEBPACK_IMPORTED_MODULE_4__views_Element__["a" /* default */].getById('screen_saver_' + id);
        var playBtn = __WEBPACK_IMPORTED_MODULE_4__views_Element__["a" /* default */].getByClass('icon_play', screenSaver.parentNode);
        playBtn.disabled = true;
        if (screenSaver && screenSaver.style.display === 'none')
            screenSaver.style.display = 'block'
        else if (screenSaver && screenSaver.style.display === 'block')
            screenSaver.style.display = 'none'
    }
    const socketOnVcxRtcMessage = (arg) => {
        let stream;
        if (arg.peerId) {
            stream = remoteStreams.get(arg.peerId);
        } else {
            stream = localStreams.get(arg.streamId);
        }
        if (stream && !stream.failed && stream.pc) {
            stream.pc.processSignalingMessage(arg.msg, that.mediaConfiguration);
            if (arg.msg && (typeof arg.msg === 'object') && (arg.msg.type === 'ready') &&
                stream.local && !stream.ifScreen()) {
                let audioInfo, videoInfo;
                if (that.mute && that.me.role === 'participant') {
                    // hard-mute-room event not sending to app as  room mute sent in room-connected event
                    audioInfo = { mute: true, hard: true, eventInfo: undefined };
                    videoInfo = { mute: false, hard: false, eventInfo: undefined };
                }
                if (!that.reconnectionState && (stream.config.audioMuted || stream.config.videoMuted)) {
                    if (audioInfo === undefined)
                        audioInfo = { mute: stream.config.audioMuted ? true : false, hard: false, eventInfo: undefined };
                    videoInfo = { mute: stream.config.videoMuted ? true : false, hard: false, eventInfo: undefined };
                }
                if (audioInfo || videoInfo) mediaDeviceMuteOnJoin(audioInfo, videoInfo);
            }
        }
    };
    const socketOnPeerMessage = (arg) => {
        let stream = localStreams.get(arg.streamId);

        if (stream && !stream.failed) {
            stream.pc.get(arg.peerSocket).processSignalingMessage(arg.msg);
        } else {
            stream = remoteStreams.get(arg.streamId);
            stream.pc.processSignalingMessage(arg.msg);
        }
    };

    const socketOnPublishMe = (arg) => {
        const myStream = localStreams.get(arg.streamId);
    };

    const socketOnUnpublishMe = (arg) => {
        const myStream = localStreams.get(arg.streamId);
    };

    const socketOnSelfBandwidthAlert = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('set publisher bandwidth in range ', arg.bandwidth);
        localStreams.forEach((stream, id) => {
            if (arg.bandwidth === 1) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('mute publisher video due to low bandwidth');
                stream.muteVideo();
            }
            else {
                stream.setMaxVideoBitarte(arg.bandwidth);
            }
        });
    };


    const socketOnBandwidthAlert = (arg) => {
        console.log('OnbandwidthAlert:', arg);
        for (let i = 0; i < arg.length; i++) {
            let stream = that.remoteStreams.getAll()[arg[i].streamId];
            if (stream == null) {
                console.log("Stream not found");
                continue;
            }
            stream.setBandwidthAlert(arg[i]);
        }
    };



    // We receive an event of new data in one of the streams
    const socketOnDataStream = (arg) => {
        if (!that.activeTalker) {
            const stream = remoteStreams.get(arg.id);
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])({ type: 'stream-data-in', msg: arg.msg, stream });
            stream.dispatchEvent(evt);
        } else {
            if ((that.eventsList && that.eventsList !== undefined) && ("message-received" in that.eventsList)) {
                const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'message-received', message: arg.msg });
                that.dispatchEvent(evt);
            }
            else {
                const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'active-talker-data-in', message: arg.msg });
                that.dispatchEvent(evt);
            }
        }
    };


    // method to inject file share UI in any given element
    // to do set position , style , UI configurable
    var inFileShareUI = (dat, elToAppend, command, style) => {
        let fsInfoContainer = document.createElement('div');
        fsInfoContainer.setAttribute('id', `fs-notif-id-${Math.random()}`);
        fsInfoContainer.setAttribute('class', 'fs-notification');
        fsInfoContainer.setAttribute('style', 'display:block;position:relative;z-index:3;padding:5px 10px;top:50%;right:50%;transform:translateX(50%);background:rgba(0,0,0,0.29);border-radius:5px;color:rgb(255,255,255)');
        elToAppend.appendChild(fsInfoContainer);
        elToAppend = fsInfoContainer;
        switch (command) {
            case 'fs-upload-init': {
                let minfo = 'upload started for file ' + dat.data[dat.data.length - 1].name + '  of size ' + dat.data[dat.data.length - 1].size / 1000 + ' KB';
                let fileInfo = dat.message;
                let br = document.createElement("br");
                elToAppend.appendChild(br);
                let text = document.createTextNode(minfo);
                elToAppend.appendChild(text);
                elToAppend.appendChild(br);
                break;
            }
            case 'fs-file-uploaded': {
                let minfo = 'uploaded 100 % ' + dat.name + '  of size ' + dat.size / 1000 + ' KB';
                let fileInfo = dat.message;
                let br = document.createElement("br");
                elToAppend.appendChild(br);
                let text = document.createTextNode(minfo);
                elToAppend.appendChild(text);
                elToAppend.appendChild(br);
                break;
            }

            case 'fs-upload-started': {
                let minfo = dat.sender + ' is sharing file ' + dat.message.data[(dat.message.data.length - 1)].name + '  of size ' + dat.message.data[(dat.message.data.length - 1)].size / 1000 + ' KB';
                let fileInfo = dat.message;
                let br = document.createElement("br");
                elToAppend.appendChild(br);
                let text = document.createTextNode(minfo);
                elToAppend.appendChild(text);
                elToAppend.appendChild(br);
                break;
            }
            case 'fs-file-available': {
                let fileInfo = dat.message;
                let br = document.createElement("br");
                elToAppend.appendChild(br);
                let btn = document.createElement("BUTTON");
                let t = document.createTextNode(fileInfo.name);
                btn.setAttribute("style", "color:red;font-size:23px");
                btn.setAttribute("id", shFileList.length - 1);
                btn.appendChild(t);
                elToAppend.appendChild(btn);
                btn.onclick = function () {
                    //    that.recvFileWithUrl(btn.id);
                    that.recvFiles(btn.id);
                };
                elToAppend.appendChild(br);
                break;
            }
            default:
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('random data to fantom UI ');
        }
    };

    /**
 * socketOnDataStreamToRoom method bind to socket
 */
    const socketOnDataStreamToRoom = (dat, callback) => {
        let msgType;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('socketOnDataStreamToRoom', dat.type);
        switch (dat.type) {
            case 'chat':
                msgType = 'message-received';
                break;
            case 'data-internal-in':
                msgType = dat.message.type;
                processInternalDataIn(dat, callback);
                break;
            default:
                msgType = 'user-data-received';
        }

        if (that.eventsList && (msgType in that.eventsList)) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: msgType, message: dat });
            that.dispatchEvent(evt);
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000);
        } else {
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1169);
        }
    }

    const processInternalDataIn = (dat, callback) => {
      //  Logger.info('intenral  data received', dat);
        switch (dat.message.type) {
            case 'fs-upload-started': { /// file is being shared with you
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file is being shared with you fs-upload-started', dat.message);
                if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                    inFileShareUI(dat, document.getElementById(fileShareUI.recvElToAppend), 'fs-upload-started');
                }
                break;
            }
            case 'fs-file-available': {
                // file is available  to dowmload
                shFileList.push(dat.message);
                let favailable = {
                    name: dat.message.name,
                    size: dat.message.size,
                    speed: dat.message.speed,
                    createdAt: dat.message.createdAt,
                    dlimit: dat.message.dlimit,
                    time: dat.message.time,
                    expiresAt: dat.message.expiresAt,
                    timeLimit: dat.message.timeLimit,
                    index: shFileList.length - 1,
                };
                that.availableFiles.push(favailable);
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('file is available  to dowmload  fs-file-available', favailable);
                let fDownloadResult = {
                    messageType: 'download-available', result: 0, description: 'file-available', response: {
                        downloadStatus: 'available', jobId: favailable.index, downloadInfo: favailable,
                    }
                };
                let evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
                that.dispatchEvent(evt);

                if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                    inFileShareUI(dat, document.getElementById(fileShareUI.recvElToAppend), 'fs-file-available');
                }
                break;
            }
            case 'fs-upload-cancelled':
                break;

            default: {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('unknown internal data type from signaling server ', dat.type);
                break;
            }

        }

    }
    // We receive an event of new data in one of the streams
    const socketOnUpdateAttributeStream = (arg) => {
        const stream = remoteStreams.get(arg.id);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])({
            type: 'stream-attributes-updated',
            attrs: arg.attrs,
            stream
        });
        stream.updateLocalAttributes(arg.attrs);
        stream.dispatchEvent(evt);
    };

    // We receive an event of a stream removed from the room
    const socketOnRemoveStream = (arg) => {
        let stream = localStreams.get(arg.id);
        if (stream) {
            onStreamFailed(stream);
            return;
        }
        stream = remoteStreams.get(arg.id);
        if (stream) {
            remoteStreams.remove(arg.id);
            removeStream(stream);
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])({ type: 'stream-removed', stream });
            that.dispatchEvent(evt);
        }
    };

    // The socket has disconnected
    const socketOnDisconnect = () => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Socket disconnected, lost connection to ClientController, ');
        if (that.state !== DISCONNECTED) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Unexpected disconnection from Client Controller');
            const disconnectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-disconnected', message: 'unexpected-disconnection' });
            that.dispatchEvent(disconnectEvt);
        }
        // do not send network failed
        //    let networkFailed = RoomEvent({ type: 'network-failed', error: customErrors.error_1161.result,  message: customErrors.error_1161.error });
        //   that.dispatchEvent(networkFailed);
    };

    const socketOnICEConnectionFailed = (arg) => {
        let stream;
        if (!arg.streamId) {
            return;
        }
        const message = `ICE Connection Failed on ${arg.type} ${arg.streamId} ${that.state}`;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(message);
        __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_ice_failed, { arg: arg });

        if (arg.type === 'publish') {
            stream = localStreams.get(arg.streamId);
        } else {
            stream = remoteStreams.get(arg.streamId);
        }
        onStreamFailed(stream, message);
    };

    const socketOnError = (e) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Cannot connect to client Controller');
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-error', message: e });
        that.dispatchEvent(connectEvt);
    };

    const sendDataSocketFromStreamEvent = (evt) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('sendDataSocketFromStreamEvent');
        const stream = evt.stream;
        const msg = evt.msg;
        if (stream.local) {
            socket.sendMessage('sendDataStream', { id: stream.getID(), msg });
        } else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('You can not send data through a remote stream');
        }
    };

    const validateSendUserData = (msg, broadcast, clients, type, callback) => {
        if (!msg || (broadcast === undefined) || (typeof broadcast !== "boolean") ||
            ((broadcast === false) && (!clients || (!Array.isArray(clients)) || !clients.length))) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('message: invalid parameter, msg/broadcast/clients undefined or type mistmatch');
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
            return;
        }
        let tempMsg = {};
        tempMsg.msg = msg;
        tempMsg.broadcast = broadcast;
        tempMsg.clients = clients;
        tempMsg.type = type;
        that.socket.emitEvent('sendDataStreamToRoom', tempMsg, callback);
    }

    /* send user data */
    that.sendUserData = (msg, broadcast, clientList, callback) => {
        validateSendUserData(msg, broadcast, clientList, "user_data", callback);
    }
    // manu dummy FT testing
    /* send user data */
    that.sendFtData = (msg, type, broadcast, clientList, callback) => {
        msg.type = type;
        validateSendUserData(msg, broadcast, clientList, "data-internal-in", callback);


    }
    // end

    /**
     * Send message to room object
     */
    that.sendMessage = (msg, broadcast, clientList, callback) => {
        validateSendUserData(msg, broadcast, clientList, "chat", callback);
    }
    const displayVideoStats = (videoStats) => {
        let value = 0, resHeight = 0, resWidth = 0, bw = 0, bps = 0, fps = 0, loss = 0, keyPair = '';
        if (videoStats) {
            Object.keys(videoStats).forEach(function (key) {
                switch (key) {
                    case "bitrateCalculated":
                        bps = Math.round((videoStats[key]) / 1000);
                        break;
                    case "framerateCalculated":
                        fps = videoStats[key];
                        break;
                    case "bandwidth":
                        bw = Math.round((videoStats[key]) / 1000);
                        break;
                    case "packetsLost":
                        loss = videoStats[key];
                        break;
                    case "frameHeight":
                        resHeight = videoStats[key];
                        break;
                    case "frameWidth":
                        resWidth = videoStats[key];
                        break;
                    default:
                        break;
                }
            });
            keyPair += `<div> <strong style="color:black;" > ${resWidth}X${resHeight}p${fps}@${bps}Kbps</strong>:</div>`;
            if (bw || loss) {
                keyPair += `<div> <strong style="color:black;" > AvailBw:${bw}Kbps, loss:${loss}</strong>:</div>`;
            }
        }
        return keyPair;
    };
    const socketOnStatSubscription = (arg) => {
        var statNodes = arg.statData.stats;
        statNodes.forEach(function (statNode) {
            var streamType = statNode.streamType;
            // To DO : needs refactoring .. will do during QA
            if (streamType === 'actStat') {
                var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.subscriberStreamId}`);
                selecterStrings.forEach(function (selecterString) {
                    if ((selecterString !== undefined) && (selecterString !== null)) {
                        let keyPair = ``;
                        //keyPair += `<div>Publisher bitrate</div>`;
                        Object.keys(statNode.total).forEach(function (key) {
                            if (key === 'bitrateCalculated') {
                                let value = Math.round((statNode.total[key]) / 1000);
                                keyPair += `<div> <strong>Tx Total:</strong>:  ${value}Kbps </div>`;
                            }
                        });
                        keyPair += displayVideoStats(statNode.videoStats);
                        let totalDetails =
                            `<div id="" class="stats-detail">
                                ${keyPair}
                            </div>`;
                        selecterString.innerHTML = totalDetails;
                    }
                });

            } else if (streamType === 'selfPcStat') {

                let streamId = parseInt(statNode.streamId) + 1;
                var dataOnRightParts = document.querySelectorAll(`#stats-right-part-${statNode.subscriberStreamId}`);
                dataOnRightParts.forEach(function (dataOnRightPart) {
                    if ((dataOnRightPart !== undefined) && (dataOnRightPart !== null)) {
                        let keyPair = ``;
                        //keyPair += `<div> <strong>Subscriber stream ID</strong>:  ${streamId} </div>`;
                        Object.keys(statNode.total).forEach(function (key) {
                            if (key === 'bitrateCalculated') {
                                let value = Math.round((statNode.total[key]) / 1000);
                                keyPair += `<div> <strong>Rx ID: ${streamId}, Total:</strong>:  ${value}Kbps </div>`;                                //   keyPair += `<div> <strong>${key}</strong>:  ${value}kbps </div>`;
                            }
                        });
                        let totalDetails =
                            `<div id="" class="stats-detail">
                                    ${keyPair}
                                </div>`;
                        dataOnRightPart.innerHTML = totalDetails;
                        //keyPair += `<div> Peer connection Video stream stats </div>`;
                        keyPair += displayVideoStats(statNode.videoStats);
                        let videoDetails =
                            `<div id="" class="stats-detail">
                            ${keyPair}
                            </div>`;
                        dataOnRightPart.innerHTML = videoDetails;
                    }
                });
            } else if (streamType === 'selfPubStat') {
                var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.streamId}`);
                selecterStrings.forEach(function (selecterString) {
                    if ((selecterString !== undefined) && (selecterString !== null)) {
                        let keyPair = '';
                        //keyPair += `<div> Self upload bitrate </div>`;
                        Object.keys(statNode.total).forEach(function (key) {
                            if (key === 'bitrateCalculated') {
                                let value = Math.round((statNode.total[key]) / 1000);
                                keyPair += `<div> <strong>Tx Total</strong>: ${value}Kbps</div>`;
                            }
                        });
                        keyPair += displayVideoStats(statNode.videoStats);
                        let totalDetails =
                            `<div id="" class="stats-detail">
                                    ${keyPair}
                                </div>`;
                        selecterString.innerHTML = totalDetails;
                    }
                });

            }
            else if (streamType === 'canvasStat') {
                //    Logger.info('Canvas stream', parseInt(statNode.streamId) + 1, 'total', statNode.total, 'statNode', statNode);
                var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.subscriberStreamId}`);
                selecterStrings.forEach(function (selecterString) {
                    if ((selecterString !== undefined) && (selecterString !== null)) {
                        let keyPair = ``;
                        //keyPair += `<div>Canvas publisher bitrate</div>`;
                        Object.keys(statNode.total).forEach(function (key) {
                            if (key === 'bitrateCalculated') {
                                let value = Math.round((statNode.total[key]) / 1000);
                                keyPair += `<div> <strong>Tx Total:</strong>:  ${value}Kbps </div>`;
                            }
                        });
                        keyPair += displayVideoStats(statNode.videoStats);
                        let totalDetails =
                            `<div id="" class="stats-detail">
                                        ${keyPair}
                                    </div>`;
                        selecterString.innerHTML = totalDetails;
                    }
                });

            }
            else if (streamType === 'shareStat') {
                //   Logger.info('shareStat stream', parseInt(statNode.streamId) + 1, 'total', statNode.total);
                var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.subscriberStreamId}`);
                selecterStrings.forEach(function (selecterString) {
                    if ((selecterString !== undefined) && (selecterString !== null)) {
                        let keyPair = ``;
                        //keyPair += `<div>Share Publisher bitrate</div>`;
                        Object.keys(statNode.total).forEach(function (key) {
                            if (key === 'bitrateCalculated') {
                                let value = Math.round((statNode.total[key]) / 1000);
                                keyPair += `<div> <strong>Tx Total:</strong>:  ${value}Kbps </div>`;
                            }

                        });
                        keyPair += displayVideoStats(statNode.videoStats);
                        let totalDetails =
                            `<div id="" class="stats-detail">
                                        ${keyPair}
                                    </div>`;
                        selecterString.innerHTML = totalDetails;
                    }
                });
            }

        });
    }
    const updateAttributesFromStreamEvent = (evt) => {
        const stream = evt.stream;
        const attrs = evt.attrs;
        if (stream.local) {
            stream.updateLocalAttributes(attrs);
            socket.sendMessage('updateStreamAttributes', { id: stream.getID(), attrs });
        } else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('You can not update attributes in a remote stream');
        }
    };

    const socketEventToArgs = (func, event) => {
        if (event.args) {
            func(...event.args);
        } else {
            func();
        }
    };

    const createSdpConstraints = (type, stream, options) => ({
        state: type,
        data: stream.ifData(),
        audio: stream.ifAudio(),
        video: stream.ifVideo(),
        screen: stream.ifScreen(),
        canvas: stream.ifCanvas(),
        attributes: stream.getAttributes(),
        metadata: options.metadata,
        createOffer: options.createOffer,
        muteStream: options.muteStream,
    });

    const populateStreamFunctions = (id, streamInput, error, callback = () => { }) => {
        const stream = streamInput;

        if (id === null) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error when publishing the stream', error);
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_publish_failed, { error: error });
            // Unauth -1052488119
            // Network -5
            callback(undefined, error);
            return;
        }
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream published');
        stream.getID = () => id;
        stream.on('internal-send-data', sendDataSocketFromStreamEvent);
        stream.on('internal-set-attributes', updateAttributesFromStreamEvent);
        localStreams.add(id, stream);
        stream.room = that;
        callback(id);

        let onResult = (result) => {
            if (result) {
                //         clearInterval(peerStatsInterval);
                let additionalOptions = {
                    streamId: stream.getID(),
                    selectedCandidates: result.selectedCandidates,
                    negotiatedCodecs: {
                        video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                        audio: { codec: 'OPUS' }
                    },
                    selectedCam: stream.video.deviceId,
                    selectedMic: stream.audio.deviceId,
                    externalIp: that.externalIp,
                };
                that.createEventLog('clientStreamPublishSuccess', additionalOptions);
            }
        };

        /*   if(stream.pc) {
               peerStatsInterval = setInterval(() => {
                   getPeerStats(stream.pc.peerConnection, onResult);
               }, 1000);
           }*/
    };

    const publishExternal = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        let type;
        let arg;
        if (stream.url) {
            type = 'url';
            arg = stream.url;
        } else {
            type = 'recording';
            arg = stream.recording;
        }
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Checking publish options for', stream.getID());
        stream.checkOptions(options);
        socket.sendSDP('publish', createSdpConstraints(type, stream, options), arg,
            (id, error) => {
                populateStreamFunctions(id, stream, error, callback);
            });
    };

    const publishData = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        socket.sendSDP('publish', createSdpConstraints('data', stream, options), undefined, (id, error) => {
            populateStreamFunctions(id, stream, error, callback);
        });
    };

    const publishVcxRtc = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        if (((stream.screen === undefined) || (stream.screen == false)) &&
            ((stream.canvas === undefined) || (stream.canvas == false))) {
            var maxVideoLayers = options.maxVideoLayers ? options.maxVideoLayers : that.maxVideoLayers;
            if ((maxVideoLayers > 1) && (maxVideoLayers <= 3)) {
                options.simulcast = { numSpatialLayers: maxVideoLayers, spatialLayerBitrates: __WEBPACK_IMPORTED_MODULE_10__Enx_config_js___default.a.video_layer_bitrates };
            }
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Publishing Main ,createOffer', options.createOffer, ' Max video layers: ' + maxVideoLayers);
        } else if ((stream.canvas !== undefined) && (stream.canvas == true)) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Publishing Canvas   spatiallayesr 3 createOffer', options.createOffer);
            options.simulcast = { numSpatialLayers: 3 };
        } else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Publishing Share createOffer', options.createOffer);
        }
        const constraints = createSdpConstraints('media_engine', stream, options);
        constraints.minVideoBW = options.minVideoBW;
        constraints.maxVideoBW = options.maxVideoBW;
        constraints.scheme = options.scheme;

        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('publishVcxRtc constraints: ', constraints);
        socket.sendSDP('publish', constraints, undefined, (response) => {
            if (response && response.result === 0) {
                populateStreamFunctions(response.id, stream, undefined, undefined);
                createLocalStreamVcxRtcConnection(stream, options);
                stream.clientId = that.clientId;
            }
            callback(response);

        });
    };

    const getVideoConstraints = (stream, video) => {
        const ifVideo = video && stream.ifVideo();
        const width = video && video.width;
        const height = video && video.height;
        const frameRate = video && video.frameRate;
        if (width || height || frameRate) {
            return { width, height, frameRate };
        }
        return ifVideo;
    };

    const subscribeVcxRtc = (streamInput, optionsInput, callback = () => { }) => {
        const stream = streamInput;
        const options = optionsInput;
        options.maxVideoBW = options.maxVideoBW || spec.defaultVideoBW;
        if (options.maxVideoBW > spec.maxVideoBW) {
            options.maxVideoBW = spec.maxVideoBW;
        }
        options.audio = (options.audio === undefined) ? true : options.audio;
        options.video = (options.video === undefined) ? true : options.video;
        options.data = (options.data === undefined) ? true : options.data;
        options.canvas = (options.canvas === undefined) ? true : options.canvas;
        stream.checkOptions(options);
        const constraint = {
            streamId: stream.getID(),
            audio: options.audio && stream.ifAudio(),
            video: getVideoConstraints(stream, options.video),
            data: options.data && stream.ifData(),
            canvas: options.canvas && stream.ifCanvas(),
            browser: that.Connection.browserEngineCheck(),
            createOffer: options.createOffer,
            metadata: options.metadata,
            muteStream: options.muteStream,
            slideShowMode: options.slideShowMode
        };

        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("SOCKET EVENT subscribe:- " + JSON.stringify(constraint));

        socket.sendSDP('subscribe', constraint, undefined, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error subscribing to stream ', error);
                __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_subscribe_failed, { error: error });
                callback(undefined, error);
                return;
            }

            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Subscriber added');
            createRemoteStreamVcxRtcConnection(stream, options);

            callback(true);
        });
    };

    const subscribeData = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        socket.sendSDP('subscribe',
            {
                streamId: stream.getID(),
                data: options.data,
                metadata: options.metadata
            },
            undefined,
            (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error subscribing to stream ', error);
                    __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_subscribe_failed, { error: error });
                    callback(undefined, error);
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream subscribed');
                const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])({ type: 'stream-subscribed', stream });
                that.dispatchEvent(evt);
                callback(true);
            });
    };
    // detect internet connection
    const doesConnectionExist = () => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('detect doesConnectionExist');
        if (that.state === DISCONNECTED) {
            let onlyOnce = 0;
            let xhr = new XMLHttpRequest();
            let file = "https://api.enablex.io/"; // need to remove hardcoding , shall be passed from options ?
            xhr.timeout = 15000; // time in milliseconds
            let randomNum = Math.round(Math.random() * 10000);

            xhr.open('HEAD', file + "?rand=" + randomNum, true);
            xhr.ontimeout = function (e) {
                // XMLHttpRequest timed out. Do something here.
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('xhr timeout---------------');
            };

            xhr.addEventListener("readystatechange", processRequest, false);

            function processRequest(e) {
                if (xhr.readyState === 4) {
                    if (xhr.status >= 200 && xhr.status < 304) {
                        onlyOnce++;
                        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("internet is back connection exists !  ");
                        stopInternetDetection();
                        if (onlyOnce === 1) {
                            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('----------reconnect-rejoin room-----------');
                            if (that.reconnectAttempt < MAXRECONNECTIONATTEMPT) {
                                that.reJoinRoom();
                            }
                            else {
                                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' reconnect attempts exceed then max allowed limit');
                                that.reconnectionAllowed = false;
                                stopInternetDetection();
                                clearAll();
                                // send reconnection timeout event to application
                                let reconnectionTimedOut = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'network-reconnect-timeout', error: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1165.result, message: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1165.error });
                                that.dispatchEvent(reconnectionTimedOut);

                            }
                        }

                    } else {
                        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("internet connection doesn't exist!");
                        if (that.reconnectAttempt >= MAXRECONNECTIONATTEMPT) {// put a condition to check the reconnection timer also
                            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("connection doesn't exist and reconnect attempt exceeded");
                            that.reconnectionAllowed = false;
                            stopInternetDetection();
                            clearAll();
                            // send reconnection timeout event to application
                            let reconnectionTimedOut = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'network-reconnect-timeout', error: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1165.result, message: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1165.error });
                            that.dispatchEvent(reconnectionTimedOut);

                        }
                        let curTime = Date.now();
                        if ((curTime - that.reconStartTime) > that.reconnectionTimeOutInterval) {
                            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Internet did not resumed within timeout limits of ', that.reconnectionTimeOutInterval / 1000, 'seconds');
                            that.reconnectionAllowed = false;
                            stopInternetDetection();
                            clearAll();
                            let reconnectionTimedOut = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'network-reconnect-timeout', error: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1166.result, message: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1166.error });
                            that.dispatchEvent(reconnectionTimedOut);

                        }
                    }
                }
                else {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('ajax request readystate is ', xhr.readyState, 'status ', xhr.status, 'timer', detectInternetStatus);
                }
            }
            // send xhr request
            xhr.send();
        }


    }

    // stop the reconnection attempt

    const stopInternetDetection = () => {
        if (detectInternetStatus !== undefined) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("stopInternetDetection kill it");

            clearInterval(detectInternetStatus);
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("stopInternetDetection handle is undefined", detectInternetStatus);

        }
    }


    const clearAll = () => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('room-disconnected clear all ');
        // Remove all streams
        if (that.reconnectionAllowed === false) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('room-disconnected ---- reconnection not allowed---- clear all normal closer');
            remoteStreams.forEach((stream, id) => {
                removeStream(stream);
                remoteStreams.remove(id);
                if (stream && !stream.failed) {
                    const evt2 = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])({ type: 'stream-removed', stream });
                    that.dispatchEvent(evt2);
                }
            });
            remoteStreams = Object(__WEBPACK_IMPORTED_MODULE_5__utils_VcxRtcMap__["a" /* default */])();
            // Close Peer Connections
            localStreams.forEach((stream, id) => {
                if (stream.ifCanvas()) {
                    that.stopCanvas(() => { });
                }
                removeStream(stream);
                localStreams.remove(id);
            });
            localStreams = Object(__WEBPACK_IMPORTED_MODULE_5__utils_VcxRtcMap__["a" /* default */])();

            // Close socket
            try {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('normal socket closure, disconnect socket');
                socket.disconnect();
                that.state = DISCONNECTED;
                socket.state = socket.DISCONNECTED;
                socket = undefined;

            } catch (error) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('Socket already disconnected');
            }

        }
        else {
            /* unexpected socket closure caused the room disconnection
             handle the reconnection case and perform selective steps*/
            // Close PC stream
            //  that.localStreamsBeforeReconnect=localStreams; // store all existing local streams
            that.localStreamsBeforeReconnect = Object(__WEBPACK_IMPORTED_MODULE_5__utils_VcxRtcMap__["a" /* default */])();
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('in clear all - unexpected disconnection and the case for reconnect');
            remoteStreams.forEach((remoteStream, id) => {
                if (remoteStream !== undefined && remoteStream.stream !== undefined) {
                    remoteStream.stream.getTracks().forEach((trackInput) => {
                        const track = trackInput;
                        track.onended = null;
                        track.stop(); // Stops each track in the Stream
                    });
                }
                else{
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('remote stream is undefined ', remoteStream);
                }
                if (remoteStream.pc) {
                    remoteStream.pc.close();
                    delete remoteStream.pc;
                }
                remoteStreams.remove(id);
            });

            localStreams.forEach((localStream, id) => {
            /*    if (localStream !== undefined) {
                    if (!localStream.screen){
                        localStream.stream.getTracks().forEach((trackInput) => {
                            const track = trackInput;
                            track.onended = null;
                            track.stop(); // Stops each track in the Stream
                        });
                    }
                    else{
                        Logger.info('screen share stream , do not stop');
                    }

                } */
                if (localStream.pc) {
                    localStream.pc.close();
                    delete localStream.pc;
                }
                that.localStreamsBeforeReconnect.add(id, localStream); // populate the streams for reconnection
                if (localStream && localStream.local) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('stream off for internal send data')
                    localStream.off('internal-send-data', sendDataSocketFromStreamEvent);

                }

                localStreams.remove(id);
            });

            socket.state = socket.DISCONNECTED;
            that.state = DISCONNECTED;
            // Send Network disconnected event
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('send network disconnected event');
            let networkDisconnected = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'network-disconnected', error: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1163.result, message: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1163.error });
            that.dispatchEvent(networkDisconnected);
            // end dispatching the event
            that.reconStartTime = Date.now();
            doesConnectionExist();
            detectInternetStatus = setInterval(doesConnectionExist, 15000);


        }

    };




    // Public functions
    const reconnect = () => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].log('reconnect');
        if (socket === undefined && that.reconnectionState === true) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].log('reconnect creating a new socket');

            // get a new socket
            that.state = DISCONNECTED;// reconnection case , shall we use one more state at socket and room level ?
            console.log('reconnect force a new socket');
            socket = Object(__WEBPACK_IMPORTED_MODULE_2__Socket__["a" /* Socket */])(undefined);
            that.socket = socket;
            that.userList.clear();// clear up the userlist
            // register this socket for events
            if (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() !== 'IE') {
                that.on('room-disconnected', clearAll);
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream, socketEventToArgs.bind(null, socketOnAddStream));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting, socketEventToArgs.bind(null, socketOnVcxRtcMessage));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.signaling_message_peer, socketEventToArgs.bind(null, socketOnPeerMessage));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.publish_me, socketEventToArgs.bind(null, socketOnPublishMe));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.unpublish_me, socketEventToArgs.bind(null, socketOnUnpublishMe));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthAlert, socketEventToArgs.bind(null, socketOnBandwidthAlert));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onSelfBandwidthAlert, socketEventToArgs.bind(null, socketOnSelfBandwidthAlert));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onDataStream, socketEventToArgs.bind(null, socketOnDataStream));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onUpdateAttributeStream, socketEventToArgs.bind(null, socketOnUpdateAttributeStream));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream, socketEventToArgs.bind(null, socketOnRemoveStream));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, socketEventToArgs.bind(null, socketOnDisconnect));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.connection_failed, socketEventToArgs.bind(null, socketOnICEConnectionFailed));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.error, socketEventToArgs.bind(null, socketOnError));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveTrack, socketEventToArgs.bind(null, socketOnRemoveTrack));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_connected, socketEventToArgs.bind(null, userConnect));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected, socketEventToArgs.bind(null, userDisConnect));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed, socketEventToArgs.bind(null, userSubcribe));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_unsubscribed, socketEventToArgs.bind(null, userUnSubcribe));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_requested, socketEventToArgs.bind(null, floorRequest));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_granted, socketEventToArgs.bind(null, floorGrant));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_not_granted, socketEventToArgs.bind(null, floorNotGrnat));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_released, socketEventToArgs.bind(null, floorRelease));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.dial_state_events, socketEventToArgs.bind(null, onDialStateEvents));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_awaited, socketEventToArgs.bind(null, onUserAwaited));

                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_awaited, socketEventToArgs.bind(null, onRoomAwaited));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_connected, socketEventToArgs.bind(null, onRoomConnected));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_record_on, socketEventToArgs.bind(null, onRoomRecordStarted));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_record_off, socketEventToArgs.bind(null, onRoomRecordStopped));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.new_active_talker, socketEventToArgs.bind(null, onNewActiveTalker));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_audio, socketEventToArgs.bind(null, onHardMuteAudio));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_audio, socketEventToArgs.bind(null, onHardUnmuteAudio));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_video, socketEventToArgs.bind(null, onHardMuteVideo));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_video, socketEventToArgs.bind(null, onHardUnmuteVideo));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.share_started, socketEventToArgs.bind(null, onShareStarted));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.share_stopped, socketEventToArgs.bind(null, onShareStopped));

                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.canvas_started, socketEventToArgs.bind(null, onCanvasStarted));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.canvas_stopped, socketEventToArgs.bind(null, onCanvasStopped));

                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.switch_codec, socketEventToArgs.bind(null, onSwitchCodec));

                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_audio_muted, socketEventToArgs.bind(null, onUserAudioMuted));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_audio_unmuted, socketEventToArgs.bind(null, onUserAudioUnmuted));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_video_muted, socketEventToArgs.bind(null, onUserVideoMuted));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_video_unmuted, socketEventToArgs.bind(null, onUserVideoUnmuted));

                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute, socketEventToArgs.bind(null, onHardmuteOne));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute_room, socketEventToArgs.bind(null, onHardmuteRoom));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.hard_unmute_room, socketEventToArgs.bind(null, onHardUnmuteRoom));
                socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onStatSubscription, socketEventToArgs.bind(null, socketOnStatSubscription));

            } else {
                if (document.getElementById('WebrtcEverywherePluginId') === null)
                    that.installPlugin();
                var plugin = document.getElementById('WebrtcEverywherePluginId');

                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream, function (event) {
                    for (arg in event.data.args)
                        socketOnAddStream(event.data.args[arg]);
                });
                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream, function (event) {
                    for (arg in event.data.args)
                        socketOnRemoveStream(event.data.args[arg]);
                });
                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting, function (event) {
                    for (arg in event.data.args)
                        socketOnVcxRtcMessage(event.data.args[arg]);
                });
                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.publish_me, function (event) {
                    for (arg in event.data.args)
                        socketOnPublishMe(event.data.args[arg]);
                });
                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_connected, function (event) {
                    for (arg in event.data.args)
                        userConnect(event.data.args[arg]);
                });
                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected, function (event) {
                    for (arg in event.data.args)
                        userDisConnect(event.data.args[arg]);
                });
                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed, function (event) {
                    for (arg in event.data.args)
                        userSubcribe(event.data.args[arg]);
                });
                plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_unsubscribed, function (event) {
                    for (arg in event.data.args)
                        userUnSubcribe(event.data.args[arg]);
                });

            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('previous connection is still there or the reconnection state is false');
            that.userList.clear();// clear up the userlist

        }
    }
    // It stablishes a connection to the room.
    // Once it is done it throws a RoomEvent("room-connected")
    that.connect = (reconnectInfo = { 'allow_reconnect': true, 'number_of_attempts': 3, 'timeout_interval': 45000 }) => {
        var token = JSON.parse(__WEBPACK_IMPORTED_MODULE_6__utils_Base64__["a" /* default */].decodeBase64(spec.token));
        //set up reconnect parameters
        that.reconnectionAllowed = reconnectInfo.allow_reconnect;
        that.reconnectionTimeOutInterval = reconnectInfo.timeout_interval;
        MAXRECONNECTIONATTEMPT = reconnectInfo.number_of_attempts;

        if ((that.reconnectionState === true) && (that.reconnectAttempt < MAXRECONNECTIONATTEMPT)) {
            that.reconnectAttempt++; // increment reconnection attemp
            token['isReconnecting'] = true;
            token['reconnectAttempt'] = that.reconnectAttempt;
            token['oldClientIdForReconnect'] = that.clientId;
            token['room'] = that.roomID;
            token['role'] = that.me.role;
            token['name'] = that.me.name;
            console.log('new token request for the reconnection: ', token)
        }
        else {
            if (that.reconnectAttempt >= MAXRECONNECTIONATTEMPT) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('reconnection attempts exceeded, attempted', that.reconnectAttempt, 'max allowed', MAXRECONNECTIONATTEMPT);
                that.reconnectionAllowed = false;
                clearAll();
                let reconnectionTimedOut = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'network-reconnect-timeout', error: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1165.result, message: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1165.error });
                that.dispatchEvent(reconnectionTimedOut);


            }
            else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('not the case of reconnection ');

            }
        }
        if (that.state !== DISCONNECTED) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].warning('Room already connected');
        }
        if (token.logId) {
            localStorage.setItem("logID", token.logId)
        }
        // 1- Connect to Client-Controller
        that.state = CONNECTING;
        /* used the following code when dynamic codec was enabled
        if(Connection.browserEngineCheck() === 'safari' ){
            token.mediaConfiguration = VcxEvent.constant.H264_CODEC;
        }else{
            token.mediaConfiguration = VcxEvent.constant.default;
        }*/
        // host type is used by server for setting audio only recording for safari publisher. (safari video MKVs are corrupts)
        token.hostType = __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck();
        token.hostVersion = __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].getBrowserVersion();
        token.advancedOptions = spec.options;
        token.version = __WEBPACK_IMPORTED_MODULE_10__Enx_config_js___default.a.product.version;
        //token.advancedOptions = [{id: 'notify-video-resolution-change', enable : true}];
        socket.connect(token, (response) => {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('socket response: ', response);
            if (response.result === 0) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('socket.connect token accepted');
                that.externalIp = response.connectedIP;
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('connect error', response);
                if (response.result === 4119) {
                    // single participant is trying to reconnect
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Client is trying to reconnect in a room where all participants are gone', that.reconnectAttempt, 'max allowed', MAXRECONNECTIONATTEMPT);
                    that.reconnectionAllowed = false;
                    clearAll();
                    let reconnectionTimedOut = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'network-reconnect-timeout', error: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1178.result, message: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1178.error });
                    that.dispatchEvent(reconnectionTimedOut);
                }
                const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-error', error: response.result, message: response.msg });
                that.dispatchEvent(connectEvt);
                let additionalOptions = {
                    clientId: '',
                    hostType: that.Connection.browserEngineCheck(),
                    hostVersion: that.Connection.getBrowserVersion(),
                    error: response.msg,
                    externalIp: that.externalIp,
                };
                that.createEventLog('clientConnFailed', additionalOptions);
            }
        }, (error) => {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(`Not Connected! Error: ${error}`);
            const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-error', message: error });
            that.dispatchEvent(connectEvt);
            let additionalOptions = {
                clientId: '',
                hostType: that.Connection.browserEngineCheck(),
                hostVersion: that.Connection.getBrowserVersion(),
                error: error,
                externalIp: that.externalIp,
            };
            that.createEventLog('clientConnFailed', additionalOptions);
        });
    };

    ////////////////ReConnect////////////////////////
    ///////////Join Room/////////////
    that.reJoinRoom = () => {
        /* it is similar to forced rejoin for the room
          clear websocket and peer connections if somehow they  are still open, which should not be the case
          and proceed to rejoin while retaining previous room state  also dont mess up existing player state
          make sure to init all local streams( like share, canvas )*/
        console.log("=========== port of hope--- reconnect");
        that.reconnectionState = true; // toDO need to handle
        // initialize all  local streams ,including share and canvas if they were being published before reconnection
        reconnect();
        that.connect();
        return;
    }
    ///// End reconnect

    // It disconnects from the room, dispatching a new RoomEvent("room-disconnected")
    that.disconnect = () => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('Disconnection requested');
        // 1- Disconnect from room
        that.reconnectionAllowed = false;
        const disconnectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({
            type: 'room-disconnected',
            message: 'expected-disconnection'
        });
        that.dispatchEvent(disconnectEvt);
    };

    that.removeTrack = (streamID) => {
        socket.sendSDP('removeTrack', {
            streamId: streamID,
            msg: 'track-removed'
        }, undefined, () => { });
    };

    const floorRequest = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("Incoming request for floor has arrived");
        that.cControlReq = arg;
        //that.cCrequest.push(arg);
        var a = JSON.stringify(arg);
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(JSON.parse(a).clientId + "::::" + JSON.parse(a).name);
        that.cCrequest.push(arg);
        const floorReqEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'floor-requested', users: arg });
        that.dispatchEvent(floorReqEvt);
    };

    const floorGrant = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(arg.msg);
        that.floorGranted = true;
        const floorReqEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'floor-granted', users: arg });
        that.dispatchEvent(floorReqEvt);
    };

    const floorNotGrnat = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(arg.mess);
        const floorReqEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'floor-denied', users: arg });
        that.dispatchEvent(floorReqEvt);
        that.floorGranted = false;
    }
    const floorRelease = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(arg.msg);
        var lstrm = that.localStreams.getAll();
        localStreams.forEach((stream, id) => {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(stream.getID() + "::::" + id);
            that.unpublish(stream, function (arg) {
                if (arg == true) {
                    const floorReqEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'release-floor', users: arg });
                    that.dispatchEvent(floorReqEvt);
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("stream has been un-published");
                    that.floorGranted = false;
                } else {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("error during stream un-publishing");
                    __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_unpublish_failed, { stream: stream });
                    that.floorGranted = false;
                }

            });
        });

    }
    const onHardmuteOne = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(arg);
        const floorReqEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'hard-mute', users: arg });
        that.dispatchEvent(floorReqEvt);
    }
    const onHardUnmuteRoom = (arg, callback) => {
        hardMuteMediaDevices(false, true, false, true, callback, true, { type: 'hard-unmute-room', message: "room hard unmuted" });
    }
    const onHardmuteRoom = (arg, callback) => {
        hardMuteMediaDevices(true, true, false, true, callback, true, { type: 'hard-mute-room', message: "room hard muted" });
    }
    const onRoomAwaited = (arg) => {
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-awaited', message: "waiting for moderator approval" });
        that.dispatchEvent(evt);
    }
    const onUserAwaited = (arg) => {
        that.awaitedParticipants.set(arg.clientId, false);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'user-awaited', message: "user waiting to join", user: { clientId: arg.clientId } });
        that.dispatchEvent(evt);
    }
    that.approveAwaitedUser = (client, callback) => {
        that.socket.emitEvent('user-allowed', client, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on knock approve request', error);
                return;
            } else {
                that.awaitedParticipants.delete(client);
            }
            callback(result, error);
        });
    }
    that.denyAwaitedUser = (client, callback) => {
        that.socket.emitEvent('user-denied', client, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on knock deny request', error);
                return;
            } else {
                that.awaitedParticipants.delete(client);
            }
            callback(result, error);
        });
    }

    const onRoomConnected = (response) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('-----------onRoomConnected-----------');
        let stream;
        const streamList = [];
        const streams = response.streams || [];
        const roomId = response.id;
        const userList = response.userList;
        const roomJson = response.room;
        that.me = response.user || {};
        that.roomSettings = response.room.settings || {};
        that.mute = response.room.mute;
        that.mediaRecord = response.mediaRecord;
        that.subscription = response.subscription;
        document.head.append(statsStyle);
        if (response.room.settings.mode === 'lecture' && response.user.role === 'moderator') {
            if (response.raisedHands.length > 0) {
                response.raisedHands.forEach((item) => {
                    that.cCrequest.push(item);
                });
            }
            if (response.approvedHands.length > 0) {
                response.approvedHands.forEach((item) => {
                    that.cCapprovedHands.push(item);
                });
            }
        }
        that.activeTalker = roomJson.settings.active_talker;
        for (var key in response.awaitedParticipants)
            that.awaitedParticipants.set(response.awaitedParticipants[key].clientId, false);

        that.iceServers = response.iceServers;
        that.state = CONNECTED;
        that.mediaConfiguration = response.mediaConfiguration;
        that.videoMutedUsers = response.videoMutedUsers;
        spec.defaultVideoBW = response.defaultVideoBW;
        spec.maxVideoBW = response.maxVideoBW;
        that.clientId = response.clientId;
        that.maxVideoLayers = response.maxVideoLayers || 0;

        // Set clientId and utilToken in event logger if token is received
        __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].setClientId(response.clientId);
        if(response.utilToken) {
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].setEventLoggerToken(response.utilToken);
        }

        // if file sharing service and subscription is enabled then populate and setup file sharing service
        // ToDO  refactor ;- set completed object from signalling server itself , insted of manipulating here
        if (response.room.fileShareService !== undefined) {
            let fileShareService = {};
            fileShareService = response.room.fileShareService;
            let fsCallInfo = {};
            fsCallInfo.call_num = response.clientId;
            fsCallInfo.room_id = response.id;
            fsCallInfo.service_id = response.room.service_id;
            fsCallInfo.conf_num = response.room.conf_num;
            fsCallInfo.userName = response.user.name || '';
            maxFileSize  = response.room.fileShareService.maxSize ;
            fileShareService.callInfo = fsCallInfo;
            Object(__WEBPACK_IMPORTED_MODULE_13__fileShare_app_api__["f" /* setFileShareServiceEndPoint */])(fileShareService);
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(" server does not support file sharing ", response.room.fileShareService);
        }


        // 2- Retrieve list of streams
        const streamIndices = Object.keys(streams);
        for (let index = 0; index < streamIndices.length; index += 1) {
            const arg = streams[streamIndices[index]];
            stream = Object(__WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */])(that.Connection, {
                streamID: arg.id,
                local: false,
                audio: arg.audio,
                video: arg.video,
                data: arg.data,
                screen: arg.screen,
                canvas: (!(typeof arg.canvas === 'undefined' || arg.canvas === false)),
                attributes: arg.attributes
            });
            streamList.push(stream);
            remoteStreams.add(arg.id, stream);
        }
        // 3 - Update RoomID
        that.roomID = roomId;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(`Connected to room ${that.roomID}`);
        for (var user in userList) {
            that.userList.set(userList[user].clientId, userList[user]);
        }
        that.getMaxTalkers(function (callback) {
            that.talkerCount = callback.maxTalkers;
            that.userTalkerCount = callback.maxTalkers;
        });

        var roomMeta = {
            conf_num: roomJson.conf_num,
            name: roomJson.name,
            owner_ref: roomJson.owner_ref,
            mode: roomJson.settings.mode,
            moderators: roomJson.settings.moderators,
            participants: roomJson.settings.participants,
            auto_recording: roomJson.settings.auto_recording,
            canvas: roomJson.settings.canvas,
            description: roomJson.settings.description,
            created: roomJson.created,
            mute: roomJson.mute,
            quality: roomJson.settings.quality
        };


        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-connected', streams: streamList, users: userList, room: roomMeta, me: that.me, mediaRecord: that.mediaRecord });
        that.dispatchEvent(connectEvt);

        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('that.externalIp: ', that.externalIp);
        that.reconnectClientName = response.user.name;
        let additionalOptions = {
            clientId: response.clientId,
            clientName: response.user.name,
            hostType: that.Connection.browserEngineCheck(),
            hostVersion: that.Connection.getBrowserVersion(),
            externalIp: that.externalIp
        };
        that.createEventLog('clientConnSuccess', additionalOptions);
    }
    const hardMuteMic = (stream, muteOn, raiseEvent, callback) => {
        if (stream.hardAudioMuted != muteOn) {
            let muteMicCallback = (resp) => {
                // if local mute happend and hardmute is set, hardmute set the preference and send user indication
                callback(((resp.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1177.result) ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000 : resp));
            };
            stream.hardAudioMuted = muteOn;
            if (muteOn) stream.muteAudio(muteMicCallback, raiseEvent);
            else stream.unmuteAudio(muteMicCallback, raiseEvent);
        } else {
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1177);
        }
    }
    const hardMuteCam = (stream, muteOn, raiseEvent, callback) => {
        if (stream.hardVideoMuted != muteOn) {
            let muteCamCallback = (resp) => {
                // if local mute happend and hardmute is set, hardmute set the preference and send user indication
                callback(((resp.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1177.result) ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000 : resp));
            };
            stream.hardVideoMuted = muteOn;
            if (muteOn) stream.muteVideo(muteCamCallback, raiseEvent);
            else stream.unmuteVideo(muteCamCallback, raiseEvent);
        } else {
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1177);
        }
    }
    const setMediaDeviceMuteState = (muteOn, isHard, media, sendServerEvent, roomEvent, eventData, callback) => {
        if (!that.localStreams.size) { callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1159); return; }
        var checkAndDispatchEvent = (streamToSend, resp, eventData) => {
            if ((resp.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) && (eventData !== undefined)) {
                if (streamToSend) { const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])(eventData); stream.dispatchEvent(evt); }
                else { const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])(eventData); that.dispatchEvent(evt); }
            }
        };
        that.localStreams.forEach(function (stream, id) {
            if (((media === "audio") && stream.ifAudio() && (!isHard || (stream.hardAudioMuted != muteOn))) ||
                ((media === "video") && stream.ifVideo() && (!isHard || (stream.hardVideoMuted != muteOn)))) {

                if (media === "audio") {
                    if (isHard) stream.hardAudioMuted = muteOn;
                } else if (isHard) stream.hardVideoMuted = muteOn;

                stream.setMediaDeviceMuteState(muteOn, (media === "audio"), (media === "video"), sendServerEvent,
                    (resp) => { checkAndDispatchEvent((roomEvent ? undefined : stream), resp, eventData); callback(resp); });
                return;
            }
            if (((media === "audio") && stream.ifAudio()) || ((media === "video") && stream.ifVideo())) {
                callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1177);
                return;
            }
        });
    }
    const hardMuteMediaDevices = (muteOn, audio, video, sendServerEvent, callback, roomEvent, eventData) => {
        var checkAndDispatchStreamEvent = (stream, resp, roomEvent, eventData) => {
            if ((resp.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) && eventData) {
                if (roomEvent) { const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])(eventData); that.dispatchEvent(evt); }
                else { const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* StreamEvent */])(eventData); stream.dispatchEvent(evt); }
            }
        };
        that.localStreams.forEach(function (stream, id) {
            if (audio && stream.ifAudio()) {
                hardMuteMic(stream, muteOn, sendServerEvent, (resp) => {
                    checkAndDispatchStreamEvent(stream, resp, roomEvent, eventData); callback(resp);
                });
                return;
            }
            if (video && stream.ifVideo()) {
                hardMuteCam(stream, muteOn, sendServerEvent, (resp) => {
                    checkAndDispatchStreamEvent(stream, resp, roomEvent, eventData); callback(resp);
                });
                return;
            }
        });
        if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1159);
    }
    const mediaDeviceMuteOnJoin = (audioInfo, videoInfo) => {
        let logMessage = (callingFn, resp) => {
            if (resp.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result)
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(callingFn + " audio: " + JSON.stringify(audioInfo) + "video: " + JSON.stringify(videoInfo) + " success");
            else __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(callingFn + " audio: " + JSON.stringify(audioInfo) + "video: " + JSON.stringify(videoInfo) +
                " failed. result: " + JSON.stringify(resp));
        }
        let audioMuteCallback = (resp) => {
            logMessage("audioMuteCallback", resp);
            //do video unmute done after 1 sec to avoid blank video on both local view and remote subscribers
            if (!videoInfo.mute) {
                setTimeout(setMediaDeviceMuteState, 1000, false, videoInfo.hard, "video", false, true, undefined,
                    (resp) => { logMessage("videoUnmuteCallback", resp); });
            }
        };
        let videoMuteCallback = (resp) => {
            logMessage("videoMuteCallback", resp);
            //do audio hard mute
            if (audioInfo.mute)
                setMediaDeviceMuteState(true, audioInfo.hard, "audio", true, true, audioInfo.eventInfo, audioMuteCallback);
        };
        // hard-mute-room event not sending to app as  room mute sent in room-connected event
        //replace track for audio causing blank on remote. so in this case enable to false
        if (audioInfo.mute || videoInfo.mute)
            setMediaDeviceMuteState(true, videoInfo.hard, "video", false, true,
                (videoInfo.mute ? videoInfo.eventInfo : undefined), videoMuteCallback);
    }

    const onHardMuteAudio = (arg, callback) => {
        hardMuteMediaDevices(true, true, false, true, callback, true, { type: 'hardmute-user-audio', message: "hard muted audio" });
    }
    const onHardUnmuteAudio = (arg, callback) => {
        hardMuteMediaDevices(false, true, false, true, callback, true,
            { type: 'hardunmute-user-audio', message: "hard unmuted audio" });
    }
    const onHardMuteVideo = (arg, callback) => {
        hardMuteMediaDevices(true, false, true, true, callback, true, { type: 'hardmute-user-video', message: "hard muted video" });
    }

    const onHardUnmuteVideo = (arg, callback) => {
        hardMuteMediaDevices(false, false, true, true, callback, true,
            { type: 'hardunmute-user-video', message: "hard unmuted video" });
    }
    const onShareStarted = (arg) => {
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'share-started', message: { clientId: arg.clientId, name: arg.name, streamId: arg.streamId } });
        that.shareStatus = true;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug(" share-started event : " + JSON.stringify(evt));
        that.dispatchEvent(evt);

    }
    const onSwitchCodec = (arg) => {
        if (arg.result === 0 && arg.mediaConfiguration !== that.mediaConfiguration) {
            that.mediaConfiguration = arg.mediaConfiguration;
            that.localStreams.forEach(function (stream, streamID) {
                stream.resetMediaConfiguration(arg.mediaConfiguration);
            });
        }
    }
    const onShareStopped = (arg) => {
        let additionalOptions = {
            streamType: 'share',
            streamId: arg.streamId,
            negotiatedCodecs: {
                video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                audio: { codec: 'OPUS' }
            },
            externalIp: that.externalIp
        };

        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'share-stopped', message: { clientId: arg.clientId, name: arg.name, streamId: arg.streamId } });
        that.shareStatus = false;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug(" share-stopped event : " + JSON.stringify(evt));
        that.dispatchEvent(evt);
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('additionalOptions: ', additionalOptions)
        that.createEventLog('clientStreamShareStopped', additionalOptions);
    }

    const onUserAudioMuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-audio-muted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/
        var user = that.userList.get(arg.clientId);
        user.audioMuted = arg.user.audioMuted;
        that.userList.set(arg.clientId, arg.user);

        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* UserEvent */])({ type: 'user-audio-muted', clientId: arg.clientId });
        that.dispatchEvent(evt);
    }
    const onUserAudioUnmuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-audio-unmuted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/
        var user = that.userList.get(arg.clientId);
        user.audioMuted = arg.user.audioMuted;
        that.userList.set(arg.clientId, arg.user);

        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* UserEvent */])({ type: 'user-audio-unmuted', clientId: arg.clientId });
        that.dispatchEvent(evt);
    }
    const onUserVideoMuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-video-muted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/
        var user = that.userList.get(arg.clientId);
        user.videoMuted = arg.user.videoMuted;
        that.userList.set(arg.clientId, arg.user);

        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* UserEvent */])({ type: 'user-video-muted', clientId: arg.clientId });
        that.dispatchEvent(evt);
    }
    const onUserVideoUnmuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-video-unmuted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/

        var user = that.userList.get(arg.clientId);
        user.videoMuted = arg.user.videoMuted;
        that.userList.set(arg.clientId, arg.user);

        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* UserEvent */])({ type: 'user-video-unmuted', clientId: arg.clientId });
        that.dispatchEvent(evt);
    }
    // It publishes the stream provided as argument. Once it is added it throws a
    // StreamEvent("stream-added").

    that.publish = (streamInput, optionsInput = {}, callback = () => { }) => {
        const stream = streamInput;
        const options = optionsInput;
        if (that.subscription && ((!that.subscription.audio_video && streamInput.video) ||
            (!that.subscription.audio_only && !that.subscription.audio_video && streamInput.audio) ||
            (!that.subscription.audio_video && streamInput.canvas) ||
            (!that.subscription.audio_video && streamInput.share))) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error("Licence error : feature not supported subscription - av: " + that.subscription.audio_video +
                " audio: " + that.subscription.audio_only + " canvas: " + that.subscription.audio_video +
                " share: " + that.subscription.audio_video + " req audio: " + streamInput.audio + " video: " +
                streamInput.video + " share: " + streamInput.share + " canvas: " + streamInput.canvas);
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1170);
            return;
        }
        if (streamInput.video){
          let res = validateVideoResolution(streamInput,false);
          if (res.result !== __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) {
              __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(' Failed : room.publish video size invalid');
              errorCallback(res);
              return;
          }
        }
        locStrm = streamInput;
        if (that.reconnectionState === false){
          if (streamInput.ifScreen()){
            //sharePublishOptions.forceTurn =  options.forceTurn ? options.forceTurn :  false;
            options.forceTurn = sharePublishOptions.forceTurn;
          }else if (streamInput.ifCanvas()){
            //canvasPublishOptions.forceTurn =  options.forceTurn ? options.forceTurn :  false;
            options.forceTurn = canvasPublishOptions.forceTurn;
          }else {
            avOptions.publish.forceTurn =  options.forceTurn ? options.forceTurn :  false;
            sharePublishOptions.forceTurn =  avOptions.publish.forceTurn;
            canvasPublishOptions.forceTurn =  avOptions.publish.forceTurn;
          }
        }else{
          if (streamInput.ifScreen()){
            options.forceTurn = sharePublishOptions.forceTurn;
          }else if (streamInput.ifCanvas()){
            options.forceTurn = canvasPublishOptions.forceTurn;
          }else {
            options.forceTurn = avOptions.publish.forceTurn;
          }
        }
        options.maxVideoBW = options.maxVideoBW || spec.defaultVideoBW;
        if (options.maxVideoBW > spec.maxVideoBW) {
            options.maxVideoBW = spec.maxVideoBW;
        }

        if (options.minVideoBW === undefined) {
            options.minVideoBW = 0;
        }

        if (options.minVideoBW > spec.defaultVideoBW) {
            options.minVideoBW = spec.defaultVideoBW;
        }
        if (options.forceTurn)
            stream.forceTurn = options.forceTurn;

        options.simulcast = options.simulcast || false;

        options.muteStream = {
            audio: stream.ifCanvas() ? true : stream.audioMuted,
            video: stream.videoMuted,
        };
        that.muteAudioOnJoin = options.audioMuted ? true : false;
        that.muteVideoOnJoin = options.videoMuted ? true : false;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug("Publish forceTurn: ( " + options.forceTurn + "," + avOptions.publish.forceTurn + " ) reconnect state: " + that.reconnectionState);

        /*if(that.mute && that.me.role === 'participant' && !stream.ifScreen())
        {
            stream.muteAudioNotSelf();
        }*/

        // 1- If the stream is not local or it is a failed stream we do nothing.
        // if (stream && stream.local && !stream.failed && !localStreams.has(stream.getID())) {
        if (stream && stream.local && !stream.failed) {
            // 2- Publish Media Stream to Client-Controller
            if (stream.ifMedia()) {
                if (stream.ifExternal()) {
                    publishExternal(stream, options, callback);
                }
                else {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Publish stream options: ', options);
                    publishVcxRtc(stream, options, callback);
                }
            }
            else if (stream.ifData()) {
                publishData(stream, options, callback);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Trying to publish invalid stream');
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_publish_failed, { stream: stream });
            callback(undefined, 'Invalid Stream');
            let additionalOptions = {
                streamId: stream.getID(),
                selectedCandidates: { local: '', remote: '' },
                negotiatedCodecs: {
                    video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                    audio: { codec: 'OPUS' }
                },
                selectedCam: stream.video.deviceId,
                selectedMic: stream.audio.deviceId,
                error: 'Invalid stream',
                externalIp: that.externalIp
            };
            that.createEventLog('clientStreamPublishFailed', additionalOptions);
        }
    };

    const onRoomRecordStarted = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-record-on', message: "Room Recording Started" });
        that.dispatchEvent(connectEvt);
    }
    const onRoomRecordStopped = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'room-record-off', message: "Room Recording Stopped" });
        that.dispatchEvent(connectEvt);
    }

    const onNewActiveTalker = (res) => {
        // safari is not sending REMB for  subscriber channels.. workaround - read stats and send to server
        if ((__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'safari') && (that.sendRecvBitrateStats === false)) {
            sendSubscribersBitrate();
        }
        /*if(res.active === false){
            that.localStreams.forEach(function(value,key){
                if(value.ifVideo() && !value.ifScreen()){
                    value.muteNonATPubVideo();
                }
            });
        }else if(res.active === true){
            that.localStreams.forEach(function(value,key){
                if(value.ifVideo() && !value.ifScreen()){
                    value.unmuteNonATPubVideo();
                }
            });
        } */
        for (var list = 0; list < res.activeList.length; list++) {
            if (res.activeList[list].mediatype === 'audio' && that.videoMutedUsers[res.activeList[list].clientId]) {
                that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly = true;
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("Recieved active talker list, videomuted: " + res.activeList[list].videomuted + " reason: " + res.activeList[list].reason);
                that.remoteStreams.getAll()[res.activeList[list].streamId].setVideoMutedMessage(res.activeList[list]);
                delete that.videoMutedUsers[res.activeList[list].clientId];
            } else if (res.activeList[list].mediatype === 'audioOnly') {
                that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly = true;
            }
            if (that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly && res.activeList[list].mediatype === 'audiovideo') {
                delete that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly;
            }
            that.remoteStreams.getAll()[res.activeList[list].streamId].reloadPlayer(res.activeList[list],
                                                                                  avOptions.subscribe.imageOnVideoMute);
            let talkerEntry = that.activeTalkerList.get(res.activeList[list].streamId);
            if (talkerEntry && (talkerEntry.mediatype != res.activeList[list].mediatype)) {
                switch (res.activeList[list].mediatype) {
                    case 'audiovideo':
                    case 'video':
                        that.remoteStreams.getAll()[res.activeList[list].streamId].setVideoMutedMessage(res.activeList[list]);
                        if (that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet) {
                            that.remoteStreams.getAll()[res.activeList[list].streamId].muteSubscriberStreamVideo(false);
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].setBlankFrameOnSubscriberVideoStream(false);
                            delete that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet;
                        }
                        break;
                    case 'audio':
                    case 'audioOnly':
                        that.remoteStreams.getAll()[res.activeList[list].streamId].setVideoMutedMessage(res.activeList[list]);
                        if (!that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet) {
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].setBlankFrameOnSubscriberVideoStream(true);
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].setBlankFrameOnSubscriberVideoStream(false);
                            that.remoteStreams.getAll()[res.activeList[list].streamId].muteSubscriberStreamVideo(true);
                            that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet = true;
                        }
                        break;
                    default:
                        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('mediatype not handled entry:', JSON.stringify(res.activeList[list]));
                        break;
                }
                that.activeTalkerList.set(res.activeList[list].streamId, res.activeList[list]);
            } else if (!talkerEntry) {
                that.activeTalkerList.set(res.activeList[list].streamId, res.activeList[list]);
            }
        }
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'active-talkers-updated', message: { activeList: res.activeList, active: res.active } });
        that.dispatchEvent(evt);
    }

    that.startRecord = (callback = () => { }) => {
        that.startRecording(undefined, callback);
    }
    that.stopRecord = (callback = () => { }) => {
        that.stopRecording(undefined, callback);
    }

    //request floor (old chairControl)
    that.requestFloor = (callback = () => { }) => {

        that.socket.sendEvent('requestFloor', (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor request', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
            }

        });
    };
    //grant floor (grantFloor,relaseFloor,denyFloor)
    that.grantFloor = (options, callback = () => { }) => {
        var stats = "grantFloor";
        that.socket.sendSDP('processFloorRequest', options, stats, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor grant', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
                that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
            }

        });
    };
    //---
    that.denyFloor = (options, callback = () => { }) => {
        var stats = "denyFloor";
        that.socket.sendSDP('processFloorRequest', options, stats, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor grant', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
                that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
            }

        });
    };
    //---

    that.relaseFloor = (options, callback = () => { }) => {
        var stats = "releaseFloor";
        that.socket.sendSDP('processFloorRequest', options, stats, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor grant', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
            }

        });
    };
    //chairControl mute all
    that.chairControlMuteAll = (callback = () => { }) => {
        that.socket.sendEvent('room-muted', (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor request', error);
                callback(undefined, error);
                // return;
            } else {
                callback(result);
            }

        });
    };

    //chairControl un-mute all
    that.chairControlUnMuteAll = (callback = () => { }) => {
        that.socket.sendEvent('room-unmuted', (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor request', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
            }
        });
    };

    //chairControl mute single client (old chairControlMuteOne)
    that.muteOne = (clientId, callback = () => { }) => {
        that.socket.sendParamEvent('muteUser', clientId, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor request', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
            }
        });
    };

    //chairControl un-mute single client
    that.unMuteOne = (clientId, callback = () => { }) => {

        that.socket.sendParamEvent('unMuteUser', clientId, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor request', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
            }
        });
    };

    //chairControl Switch room_mode
    that.chairControlSwitchMode = (roomMode, callback = () => { }) => {
        that.socket.sendParamEvent('switchRoomMode', roomMode, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on floor request', error);
                callback(undefined, error);
                return;
            } else {
                callback(result);
            }
        });
    };
    // Returns callback(id, error)
    that.startRecording = (stream, callback = () => { }) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug("Trying to start recording...");
        var streamId = undefined;
        let allow = (that.subscription && (that.subscription.recording === false)) ? false : true
        if (allow && ((stream && stream.local === false) || !stream)) {
            if (stream) {
                streamId = stream.getID();
            }
            socket.sendMessage('startRecord', { to: streamId }, (success, error) => {
                if (success === null) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on start recording', error);
                    __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_start_recording_failed, { error: error });
                    callback(success, error);
                    let additionalOptions = {
                        error: error,
                        externalIp: that.externalIp
                    };
                    that.createEventLog('roomRecordingFailed', additionalOptions);
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Started recording');
                if (success.result === 0) {
                    success["result"] = 0;
                    roomRecordStatus = true;
                }
                callback(success, error);
                let additionalOptions = {
                    externalIp: that.externalIp,
                };
                that.createEventLog('roomRecordingSuccess', additionalOptions);
            });
        } else if (!allow) {
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1170);
        }
    };
    // reconnection case - manage recording status
    that.manageRecordingStatus = (recordStatus) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('reconnected manage recording status ', recordStatus);
        if (that.me.role === 'moderator' && roomRecordStatus == true && that.reconnectAttempt > 0 && that.reconnectionAllowed === true) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('room recording was enabled before  reconnect');
            that.startRecord(function (success, error) {
                if (success !== null) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('reconnected manage recording success ');
                } else {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("Failed to restart recording after reconnection.");
                }

            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('reenbling recording for this role  is not allowed ', that.me.role)
        }
    };

    // Returns callback(id, error)
    that.stopRecording = (recordingId, callback = () => { }) => {
        let allow = (that.subscription && (that.subscription.recording === false)) ? false : true;
        if (allow) {
            socket.sendMessage('stopRecord', { id: recordingId }, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error on stop recording', error);
                    __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stop_recording_failed, { error: error });
                    callback(result, error);
                    return;
                }
                roomRecordStatus = false;
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stop recording', recordingId);
                callback(result, error);
                let additionalOptions = {
                    externalIp: that.externalIp,
                };
                that.createEventLog('roomRecordingStopped', additionalOptions);
            });
        } else {
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1170);
        }
    };

    // It unpublishes the local stream in the room, dispatching a StreamEvent("stream-removed")
    that.unpublish = (streamInput, callback = () => { }) => {
        const stream = streamInput;
        // Unpublish stream from Client-Controller
        if (stream && stream.local) {
            // Media stream

            let streamTobeDeleted = localStreams.get(stream.getID());

            if (streamTobeDeleted !== undefined) {
                streamTobeDeleted.stream.getTracks().forEach((track) => {
                    track.stop();
                });
            }
            socket.sendMessage('unpublish', stream.getID(), (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error unpublishing stream', error);
                    __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_unpublish_failed, { error: error });
                    callback(undefined, error);
                    return;
                }

                delete stream.failed;
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream unpublished');
                callback(true);
            });
            stream.room = undefined;


            if (streamTobeDeleted !== undefined) {
                streamTobeDeleted.pc.close();
                streamTobeDeleted.pc = null;
            }

            localStreams.remove(stream.getID());
            stream.getID = () => { };
            stream.off('internal-send-data', sendDataSocketFromStreamEvent);
            stream.off('internal-set-attributes', updateAttributesFromStreamEvent);
        } else {
            const error = 'Cannot unpublish, stream does not exist or is not local';
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_unpublish_failed, { error: error });
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(error);
            callback(undefined, error);
        }
    };

    that.sendControlMessage = (stream, type, action) => {
        if (stream && stream.getID()) {
            const msg = { type: 'control', action };
            socket.sendSDP('signaling_message', { streamId: stream.getID(), msg });
        }
    };

    // It subscribe to a remote stream and draws it inside the HTML tag given by the ID='elementID'
    that.subscribe = (streamInput, optionsInput = {}, callback = () => { }) => {
        const stream = streamInput;
        const options = optionsInput;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream for subscribe in room.subscribe:- ' + (streamInput));
        if (stream && !stream.local && !stream.failed) {
            if (stream.ifMedia()) {
                // 1- Subscribe to Stream
                if (!stream.ifVideo() && !stream.ifScreen()) {
                    options.video = false;
                }
                if (!stream.ifAudio()) {
                    options.audio = false;
                }

                if (stream.ifCanvas()) {
                    options.data = false;
                }

                if (!stream.ifCanvas()) {
                    options.canvas = false;
                }
                if ((that.mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.H264_CODEC)
                    && (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'safari')
                    && __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].getBrowserVersion() <= __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_NOT_SUPPORTING_VP8) {
                    options.video = false;
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream for subscribe in room.subscribe:- SAFARI - false');
                }
                else if ((that.mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.H264_CODEC)
                    && (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'safari')
                    && __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].getBrowserVersion() >= __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_SUPPORTING_VP8) {
                    options.video = true;
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream publish in Init publish:- SAFARI - true');
                }

                options.muteStream = {
                    audio: stream.ifCanvas() ? true : stream.audioMuted,
                    video: stream.videoMuted,
                };
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("options ::: ", options);

                if (that.reconnectionState === false){
                  avOptions.subscribe.forceTurn =  options.forceTurn ? options.forceTurn :  false;
                  avOptions.subscribe.imageOnVideoMute =
                            options.imageOnVideoMute? options.imageOnVideoMute:  false;
                }else{
                  options.forceTurn = avOptions.subscribe.forceTurn;
                }
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug(" Subscribe forceTurn: ( " + options.forceTurn + "," + avOptions.subscribe.forceTurn + " ) reconnect state: " + that.reconnectionState);
                stream.forceTurn = options.forceTurn;
                subscribeVcxRtc(stream, options, callback);
            } else if (stream.ifData() && options.data !== false) {
                subscribeData(stream, options, callback);
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].warning('There\'s nothing to subscribe to');
                callback(undefined, 'Nothing to subscribe to');
                return;
            }
            // Subscribe to stream stream
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(`Subscribing to: ${stream.getID()}`);
        } else {
            let error = 'Error on subscribe';
            if (!stream) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].warning('Cannot subscribe to invalid stream');
                error = 'Invalid or undefined stream';
                __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_subscribe_failed, { error: error });
            } else if (stream.local) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].warning('Cannot subscribe to local stream, you should ' +
                    'subscribe to the remote version of your local stream');
                error = 'Local copy of stream';
                __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_subscribe_failed, { error: error, stream: stream });
            } else if (stream.failed) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].warning('Cannot subscribe to failed stream.');
                error = 'Failed stream';
                __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_subscribe_failed, { error: error, stream: stream });
            }
            callback(undefined, error);

            let additionalOptions = {
                streamType: stream.ifScreen() ? 'share' : 'main',
                streamId: stream.getID(),
                selectedCandidates: {
                    local: '',
                    remote: ''
                },
                negotiatedCodecs: {
                    video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                    audio: { codec: 'OPUS' }
                },
                error: error,
                externalIp: that.externalIp
            };
            that.createEventLog('clientStreamSubscribeFailed', additionalOptions);
        }
    };

    // It unsubscribes from the stream, removing the HTML element.
    that.unsubscribe = (streamInput, callback = () => { }) => {
        const stream = streamInput;
        // Unsubscribe from stream stream
        if (socket !== undefined) {
            if (stream && !stream.local) {
                socket.sendMessage('unsubscribe', stream.getID(), (result, error) => {
                    if (result === null) {
                        callback(undefined, error);
                        return;
                    }
                    removeStream(stream);
                    delete stream.failed;
                    callback(true);
                }, () => {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('Error calling unsubscribe.');
                    __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_unsubscribe_failed, { stream: stream });
                });
            }
        }
    };

    that.hardMute = (callback = () => { }) => {
        sendRemoteMediaDeviceControlRequest("room-muted", true, false, true, undefined, callback);
    }
    that.hardUnmute = (callback = () => { }) => {
        sendRemoteMediaDeviceControlRequest("room-unmuted", true, false, true, undefined, callback);
    }

    that.hardMuteUserAudio = (clientId, callback) => {
        sendRemoteMediaDeviceControlRequest("hardmute-user-audio", true, false, false, clientId, callback);
    }

    that.hardUnmuteUserAudio = (clientId, callback) => {
        sendRemoteMediaDeviceControlRequest("hardunmute-user-audio", true, false, false, clientId, callback);
    }

    that.hardMuteUserVideo = (clientId, callback) => {
        sendRemoteMediaDeviceControlRequest("hardmute-user-video", false, true, false, clientId, callback);
    }

    that.hardUnmuteUserVideo = (clientId, callback) => {
        sendRemoteMediaDeviceControlRequest("hardunmute-user-video", false, true, false, clientId, callback);
    }


    that.subscriberVideoMute = (streamId, callback) => {
        that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.subscriber_video_mute, { streamId: streamId }, (result) => {
            if (result.result == 0)
                callback(result);
        });
    }

    that.setTalkerCount = (numTalker, callback) => {
        prefNumTakler = numTalker;
        that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.set_active_talker, { numTalkers: numTalker }, (result) => {
            if (result.result == 0)
                that.userTalkerCount = result.numTalkers;
            callback(result);
        });
    }
    that.getTalkerCount = (callback) => {
        that.socket.sendEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.get_active_talker, (result) => {
            callback(result);
        });
    }
    that.getMaxTalkers = (callback) => {
        that.socket.sendEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.get_active_max_talker, (result) => {
            callback(result);
        });
    }
    that.setAdvancedOptions = (options, callback) => {
        if (options && options.length) {
            that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.set_adavanced_options, options, (result) => {
                callback(result);
            });
        } else {
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
        }
    }
    that.getAdvancedOptions = (callback) => {
        that.socket.sendEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.get_adavanced_options, (result) => {
            callback(result);
        });
    }
    that.switchUserRole = (newModeratorId, callback) => {
        if ((that.me.role === 'moderator') && newModeratorId && that.clientId &&
            (newModeratorId != that.clientId)) {
            that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.switch_user_role, newModeratorId, (result) => {
                callback(result);
            });
        } else {
            let error = (that.me.role !== 'moderator') ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1168 :
                !that.clientId ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1171 : __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155;
            callback(error);
        }
    }
    that.startLocalRecord = (type = "remote", timeoutSecs = 10, callback) => {
        if (localRecord === "none") {
            let promises = [];
            let index = 0;
            if ((type === "remote") || (type === "all")) {
                remoteStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.startLocalRecord(respCallback = (status) => {
                            resolve({ "id": stream.getID(), "status": status });
                        });
                    });
                    index++;
                });
                localRecord = type;
            }
            if ((type === "local") || (type === "all")) {
                localStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.startLocalRecord(respCallback = (status) => {
                            resolve({ "id": stream.getID(), "status": status });
                        });
                    });
                    index++;
                });
                localRecord = type;
            }
            if (localRecord !== "none") {
                if (timeoutSecs !== 0) {
                    promises[index] = new Promise((resolve, reject) => {
                        setTimeout(() => {
                            that.stopLocalRecord(respCallback = (status, info) => {
                                resolve(info);
                            });
                        }, timeoutSecs * 1000);
                    });
                }
                Promise.all(promises).then(values => {
                    if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000, values);
                });
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error("invalid param type");
                __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_start_recording_failed, { error: "invalid param type" });
                if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error("recording already in progress");
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_start_recording_failed, { error: "recording already in progress" });
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1174);
        }
    }
    that.stopLocalRecord = (callback) => {
        if (localRecord !== "none") {
            let promises = [];
            let index = 0;
            if ((localRecord === "remote") || (localRecord === "all")) {
                remoteStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.stopLocalRecord(respCallback = (status) => {
                            resolve({ "id": stream.getID(), "status": status });
                        });
                    });
                    index++;
                });
            }
            if ((localRecord === "local") || (localRecord === "all")) {
                localStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.stopLocalRecord(respCallback = (status) => {
                            resolve({ "id": stream.getID(), "status": status });
                        });
                    });
                    index++;
                });
            }
            localRecord = "none";
        } else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error("recoding not started");
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1175);
        }
    }
    that.setReceiveVideoQuality = (opts, callback) => {
        var config = {};
        var video = {};
        var res = {};
        var videoQuality = opts['videoQuality'];
        var streamType = opts['streamType'];
        if (videoQuality === undefined) {
            videoQuality = "Auto";
        }
        if (streamType === undefined) {
            streamType = "talker";
        }
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Dumping opts in setReceiveVideoQuality' + JSON.stringify(opts) + ' streamType' + streamType);
        if ((streamType != "talker") && (streamType != "canvas")) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('setReceiveVideoQuality Failed Invalid Param -StreamType: ' + streamType);
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
            return;
        }
        switch (videoQuality) {
            case "HD":
                video.width = 960;
                video.height = 720;
                break;
            case "SD":
                video.width = 640;
                video.height = 480;
                break;
            case "LD":
                video.width = 320;
                video.height = 240;
                break;
            case "Auto":
                // leave width and height undefined
                break;
            default:
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('setReceiveVideoQuality for ' + streamType + '. Failed Invalid Param -videoQuality: ' + videoQuality);
                callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
                return;
                break;
        }
        video.frameRate = 30;
        config.video = video;
        if (((streamType == "talker") && (that.receiveVideoQuality.get("talker") !== videoQuality)) ||
            ((streamType == "canvas") && (that.receiveVideoQuality.get("canvas") !== videoQuality))) {
            remoteStreams.forEach((stream) => {
                if ((streamType === "talker") && (stream.canvas === false) && (stream.screen === false)) {
                    stream.updateConfiguration(config, function (result) {
                        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('stream.updateConfiguration  for talker stream result : ' + result);
                    });
                } else if ((streamType === "canvas") && (stream.canvas === true)) {
                    stream.updateConfiguration(config, function (result) {
                        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('stream.updateConfiguration  for canvas stream result : ' + result);
                    });
                }
            });
            that.receiveVideoQuality.set(streamType, videoQuality);
        }
        res = { "result": 0, "msg": "Video quality successfully updated." };
        callback(res);
        return;
    }


    /**
     * Function to Get Receive Video Quality
     */
    that.getReceiveVideoQuality = (streamType) => {
        var res = {};
        if ((streamType === "talker") || (streamType === "canvas")) {
            let quality = that.receiveVideoQuality.get(streamType);
            res = { result: 0, videoQuality: quality };
        } else {
            res = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1156;
        }
        return res;
    }

    that.getStreamStats = (stream, callback = () => { }) => {
        if (!socket) {
            return 'Error getting stats - no socket';
        }
        if (!stream) {
            return 'Error getting stats - no stream';
        }

        socket.sendMessage('getStreamStats', stream.getID(), (result) => {
            if (result) {
                callback(result);
            }
        });
        return undefined;
    };

    // It searchs the streams that have "name" attribute with "value" value
    that.getStreamsByAttribute = (name, value) => {
        const streams = [];

        remoteStreams.forEach((stream) => {
            if (stream.getAttributes() !== undefined && stream.getAttributes()[name] === value) {
                streams.push(stream);
            }
        });

        return streams;
    };
    that.installPlugin = () => {
        if (document.getElementById("WebrtcEverywherePluginId")) {
            return;
        }
        var isInternetExplorer = !!((Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(window, "ActiveXObject")) || ("ActiveXObject" in window));
        var isSafari = !!navigator.userAgent.indexOf('Safari');
        var pluginObj = document.createElement('object');
        if (isInternetExplorer) {
            pluginObj.setAttribute('classid', 'CLSID:7FD49E23-C8D7-4C4F-93A1-F7EACFA1EC53');
            isInternetExplorer = true;
        } else {
            pluginObj.setAttribute('type', 'application/webrtc-everywhere');
        }
        pluginObj.setAttribute('id', 'WebrtcEverywherePluginId');
        document.body.appendChild(pluginObj);
        pluginObj.setAttribute('width', '0');
        pluginObj.setAttribute('height', '0');


        if (pluginObj.isWebRtcPlugin || (typeof navigator.plugins !== "undefined" && (!!navigator.plugins["WebRTC Everywhere"] || navigator.plugins["WebRTC Everywhere Plug-in for Safari"]))) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Installed WEBRTC plugin for IE');
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("Browser does not appear to be WebRTC-capable");
            window.open("/assets/plugin/VCXIE_PLUGINS.exe", "new");
        }
    }
    //processes log
    that.postClientLogs = (tokenRef, callback = () => { }) => {
        /* */
        var token = __WEBPACK_IMPORTED_MODULE_6__utils_Base64__["a" /* default */].decodeBase64(tokenRef);

        var myData = localStorage.getItem('vcxRTCLib-log');
        var logId = JSON.parse(token).logId;
        var dat = JSON.parse(myData);

        var s = JSON.stringify(myData).replace(',', ', ').replace('{', '').replace('}', '');

        that.socket.sendSDP('clientLogPosted', logId, myData, (result, error) => {
            if (result) {
                if (result) {
                    var res = {
                        "result": 0,
                        "message": "Log posted successfully"
                    };
                    callback(res);
                }

            } else {
                var res = {
                    "result": 1340,
                    "message": "Error in posing log"
                }
                callback(res);
            }
        });
    };

    //get the loacl(calling) user detail
    that.whoAmI = (callback = (arg) => { }) => {
        var currntUserDetails = undefined;
        that.userList.forEach(findMe);
        function findMe(item, index) {
            if (index === that.clientId) {
                currntUserDetails = item;
            }
        }
        callback(currntUserDetails);
    };

    that.startScreenShare = (callback) => {
        var localStream;
        if (that && (!that.subscription || that.subscription.audio_video)) {
            localStream = startShare(function (res) {
                if (res === true) {
                    that.publish(localStream, { share: true }, function (response) {
                        callback(response);
                        if (response.result === 0) {
                            let additionalOptions = {
                                streamId: localStream.getID(),
                                negotiatedCodecs: {
                                    video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                                    audio: { codec: 'OPUS' }
                                },
                                externalIp: that.externalIp
                            };
                            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('additionalOptions:', additionalOptions)
                            localStreams.forEach((stream, id) => {
                                if (stream && stream.ifVideo()) {
                                    stream.setQualityLayers(2);
                                }
                            });
                            that.createEventLog('clientStreamShareSuccess', additionalOptions);
                        }
                        else if (response.result === 4108) {
                            let additionalOptions = {
                                streamId: localStream.getID(),
                                negotiatedCodecs: {
                                    video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                                    audio: { codec: 'OPUS' }
                                },
                                externalIp: that.externalIp,
                                error: response.msg
                            };
                            that.createEventLog('clientStreamShareFailed', additionalOptions);
                            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_start_screenshare_failed, { additionalOptions: additionalOptions });
                            localStream.stream.getTracks().forEach((track) => {
                                track.stop();
                            });
                        }
                    });
                } else {
                    callback(res);
                }
            });
        } else {
            let error = !that ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1171 : __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1170;
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Room not connected../ licence error');
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_start_screenshare_failed, { error: error });
            callback(error);
        }
        return localStream;
    }

    /**
     * method to stop screen share
     */
    that.stopScreenShare = (callback) => {
        if (that && (!that.subscription || that.subscription.audio_video)) {
            that.localStreams.forEach((stream) => {
                if (stream.ifScreen() && stream.local) {
                    stream.close();
                } else if (stream && stream.ifVideo()) {
                    stream.setQualityLayers(3);
                }
            });
        } else {
            let error = !that ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1171 : __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1170;
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Room not connected../ licence error');
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stop_screenshare_failed, { error: error });
            callback(error);
        }
    }

    /**
     *Send socket event
     * @param options Object of  options supplied | object
     * @param callback callback function
     */
    that.sendSocketEvent = (options, callback = () => { }) => {
        const event = 'logClientEvents';
        that.socket.emitEvent(event, options, (result, error) => {
            if (error) {
                callback(error, 'error')
            }
            else {
                callback(result, 'success')
            }
        });
    }

    /**
     * Create Event logs for various events
     * @param eventType Type of event
     * @param additionalOptions Json provided to merge with the common options
     */
    that.createEventLog = (eventType, additionalOptions) => {
        // Common options
        let options = {
            eventType: eventType,
            roomId: that.roomID,
            logId: token.logId,
            timestamp: new Date(),
        };

        // adding the additional-options to options object,  provided by the event
        Object.assign(options, additionalOptions);

        // Event callback
        let eventCallback = (resp, type) => {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(`Logging ${eventType} response:  ${JSON.stringify(resp)} , ${type} `)
        };

        // Logging event options
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(`${eventType} :`, options);
        // send event to socket
        that.sendSocketEvent(options, eventCallback);
    };
    const sendSubscribersBitrate = () => {
        if (that.reconnectionState === false) {
            if (!that.sendRecvBitrateStats) that.sendRecvBitrateStats = true;
            let promises = [];
            let index = 0;
            remoteStreams.forEach((stream) => {
                if (stream.pc && stream.pc.peerConnection) {
                    promises[index] = stream.pc.peerConnection.getStats(null)
                        .then((results) => {
                            let bwInfo;
                            results.forEach(report => {
                                if ((report.type === 'candidate-pair') && (report.availableIncomingBitrate !== undefined)) {
                                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug("incoming bitrate: " + report.availableIncomingBitrate);
                                    bwInfo = { streamId: stream.getID(), availableRecvBitrate: parseInt(report.availableIncomingBitrate) };
                                }
                            });
                            return (bwInfo ? bwInfo : { streamId: stream.getID(), availableRecvBitrate: 0 });
                        }, (err) => {
                            console.log(err);
                            return ({ streamId: stream.getID(), availableRecvBitrate: 0 });
                        });
                    index++;
                }
            });
            Promise.all(promises).then(values => {
                let bw = 0;
                for (let i = 0; i < values.length; i++) {
                    bw += values[i].availableRecvBitrate;
                }
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("Bitrates Total:" + bw + " streamInfo: " + JSON.stringify(values));
                let stats = { media: { subscribers: { totalAvailableBw: bw } } };
                //send to server
                that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.client_stats, stats, (result) => {
                });
            });
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug("Setting timeout again to execute ");
            setTimeout(sendSubscribersBitrate, 5000);
        } else {
            that.sendRecvBitrateStats = false;
        }
    };
    /**
     * Get Peer connection stats
     * @param streamPeerConnection Stream peerConnection
     * @param callback
     */
    const getPeerStats = (streamPeerConnection, callback) => {
        streamPeerConnection.getStats(null)
            .then((results) => {
                getResults(results, (result) => {
                    callback(result);
                })
            }, err => console.log(err));
    };

    /**
     *  Get candidate list and codecs
     * @param results
     * @param callback
     */
    let successIndex = 0;
    function getResults(results, callback) {
        let activeCandidatePair = null;
        let localCandidate = {};
        let remoteCandidate = {};
        let result = {};
        let codecsList = {};
        results.forEach(report => {
            if (report.type === 'transport') {
                activeCandidatePair = results.get(report.selectedCandidatePairId);
            }
            /**
             *  transportId = RTCTransport_audio_1, in new style
             *  earlier it was Conn-Audio-1
             *  */
            if (report.transportId == 'RTCTransport_audio_1' && report.ssrc && report.mediaType === 'audio') {
                var codea = '';
                results.forEach((item) => {
                    if (item.id === report.codecId) codea = item;
                });
                codecsList.audio = { codec: codea.mimeType };
            }

            if (report.transportId == 'RTCTransport_audio_1' && report.ssrc && report.mediaType === 'video') {
                var codev = '';
                results.forEach((item) => {
                    if (item.id === report.codecId) codev = item;
                });
                codecsList.video = { codec: codev.mimeType };
            }
        });

        // Fallback for Firefox.
        if (!activeCandidatePair) {
            results.forEach(report => {
                if (report.type === 'candidate-pair' && report.selected) {
                    activeCandidatePair = report;
                }
            });
        }

        if (activeCandidatePair && activeCandidatePair.remoteCandidateId) {
            remoteCandidate = results.get(activeCandidatePair.remoteCandidateId).ip;
        }

        if (activeCandidatePair && activeCandidatePair.localCandidateId) {
            localCandidate = results.get(activeCandidatePair.localCandidateId).ip;
        }


        if ((localCandidate && Object.keys(localCandidate).length > 0) && (remoteCandidate && Object.keys(remoteCandidate).length > 0)) {
            successIndex++;
            result.selectedCandidates = {
                local: localCandidate,
                remote: remoteCandidate
            }
        }

        if (Object.keys(codecsList).length > 0) {
            successIndex++;
            result.negotiatedCodecs = codecsList
        }

        if (successIndex === 2) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('result data: ', result);
            successIndex = 0;
            callback(result);
        }
    }
    const validateVideoResolution = (specInput , assignDefault) => {
      if (specInput.videoSize == undefined) {
        if (assignDefault){
          specInput.videoSize = [videoResolutionRange.min.width,videoResolutionRange.min.height,
                                  videoResolutionRange.max.width,videoResolutionRange.max.height];
        }else{
          __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(' Failed : video size undefined');
          return __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1184;
        }
    }else {
      const minPixelsSet = specInput.videoSize[0]*specInput.videoSize[1];
      const maxPixelsSet = specInput.videoSize[2]*specInput.videoSize[3];
      const minPixelsConfig = videoResolutionRange.min.width*videoResolutionRange.min.height;
      const maxPixelsConfig = videoResolutionRange.max.width*videoResolutionRange.max.height;
      if (minPixelsSet < minPixelsConfig || minPixelsSet > maxPixelsConfig ||
          maxPixelsSet > maxPixelsConfig || maxPixelsSet < minPixelsConfig ||
          minPixelsSet > maxPixelsSet){
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(' Failed : video size invalid');
        return __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1184;
      }
    }
    return __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000;
  }

    //////////////Publish Stream///////////////////
    that.initPublishStream = (domPlayerId, specInput, successCallback, errorCallback) => {
        var stream;
        if (specInput !== undefined) {
            if (specInput.audio || specInput.video || specInput.screen || specInput.canvas) {
                if (specInput.video && (that.mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.H264_CODEC)
                    && (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'safari')
                    && __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].getBrowserVersion() <= __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_NOT_SUPPORTING_VP8) {
                    specInput.video = false;
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Stream publish in Init publish:- SAFARI - false');
                }
                if (specInput.video){
                  let res = validateVideoResolution(specInput,true);
                  if (res.result !== __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) {
                      __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(' Failed : initPublishStream(): video size invalid');
                      errorCallback(res);
                      return;
                  }
                }
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('specInput: ', specInput);
                //   that.oldSpecInfo=specInput;
                stream = EnxRtc.EnxStream(specInput);
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(' Failed : all stream opions (audio/video/screen/canvas)  false/undefined');
                errorCallback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
            }
        } else {
            stream = EnxRtc.EnxStream({ audio: true, video: true, data: true,
                                       videoSize: [videoResolutionRange.min.width,videoResolutionRange.min.height,
                                       videoResolutionRange.max.width,videoResolutionRange.max.height] });
        }
        if (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
            var plugin = document.getElementById('WebrtcEverywherePluginId');
            plugin.addEventListener("media-access-allowed", function (event) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("got media access:- " + JSON.stringify(event));
                if (document.getElementById(domPlayerId) !== null)
                    stream.play(domPlayerId)
                successCallback();
            });
        } else {
            stream.addEventListener('media-access-denied', errorCallback);
            stream.addEventListener('media-access-allowed', function (event) {
                if (document.getElementById(domPlayerId) !== null)
                    stream.play(domPlayerId, specInput.options);
                successCallback(event.stream);
            });
        }
        stream.init();
        return stream;
    };

    /**
     * Start Share method
     * @param callback
     */
    const startShare = (callback) => {
        if (that.shareStatus && that.reconnectionState === false) {
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1151);
            return;
        }
        var config = { video: true, data: true, screen: true, attributes: { name: "share" } };
        if (config.screen === false) {
            config.screen = true;
        }
        if (config.video === false) {
            config.video = true;
        }
        if (config.attributes === undefined) {
            config.attributes = { name: "share" };
        } else if (config.attributes.name === undefined || config.attributes.name === "share") {
            that.whoAmI(function (arg) {
                config.attributes.name = arg.name + "_share";
            });
        }
        var onAccessError = function (event) {
            if (event.msg.name === "OverconstrainedError")
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Resolution selected is not supported by your webcam');
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_start_screenshare_failed, { event: event });
            callback(event.msg);
        };
        var onAccessSuccess = function () {
            callback(true);
        };
        var stream = that.initPublishStream('', config, onAccessSuccess, onAccessError);
        return stream;
    }


    /**
     * Create the canvas element and add it to the DOM
     * @param selector : string  Selector ID, can be empty
     * @returns {string}: Canvas DOM Handle created
     */
    const createCanvas = (selector) => {
        if (selector) {
            return selector;
        }

        let canvas = document.createElement('canvas');
        let domHandle = that.canvasVideoPlayer + '_veneer';
        canvas.id = domHandle;
        canvas.width = that.canvasOptions.width;
        canvas.height = that.canvasOptions.height;
        canvas.className = that.canvasVideoPlayer + '_input_veneer';
        canvas.setAttribute('style', `display:none;`);
        document.body.appendChild(canvas);
        that.inputContext = canvas.getContext('2d');
        updateCanvas();
        return domHandle;
    };

    /**
     *  Add the video frames to canvas context using dawImage fn, and updating frames recursively using 'requestAnimationFrame'
     */
    const updateCanvas = () => {
        that.inputContext.drawImage(that.canvas_video_player, 0, 0, that.canvasOptions.width, that.canvasOptions.height);
        requestAnimationFrame(updateCanvas);
    };

    /**
     * Start Canvas method used to start canvas streaming
      * @param params
     * @param callback
     * @returns localStream
     */
    that.startCanvas = (params, callback) => {
        let localStream, canvasDomID;
        let selector = params ? params.canvasSelector : '';
        try {
            let status = validateCanvas();
            if (status.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) {
                canvasDomID = createCanvas(selector);
                let frameRate = params ? params.fps : that.canvasOptions.fps;
                let props = { domHandle: canvasDomID, fps: frameRate > 23 ? 23 : frameRate };
                localStream = initCanvas(props, function (res, type) {
                    if (type === 'success') {
                        that.publish(res, { "canvas": true, maxVideoBW: 4096, minVideoBW: 1024 }, function (response) {
                            if (response.result === 0) {
                                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('startCanvas response.result:', response);
                                localStreams.forEach((stream, id) => {
                                    if (stream && stream.ifVideo()) {
                                        stream.setQualityLayers(2);
                                    }
                                });
                                if (callback) callback(response);
                            }
                        });
                    }
                    else {
                        if (callback) callback(res)
                    }
                });
            } else {
                if (callback) callback(status);
            }
        } catch (error) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('incorrect canvas params ' + error);
            __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_start_canvas_failed, { error: error });
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
        }
        return localStream;
    };

    /**
     *  Method to set video object for canvas and start the canvas streaming
     * @param videoPlayerId
     * @param options
     * @param callback
     */
    that.playVideo = (videoPlayerId, options, callback) => {
        that.canvasVideoPlayer = videoPlayerId;
        let playerObject = document.querySelector('#' + videoPlayerId);  // Get the player object using the selector

        //if player does not exist in DOM return error
        if (playerObject === undefined || playerObject === null) {
            callback(__WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1162);
        }
        // Set the canvas options and start the canvas
        else {
            that.canvas_video_player = playerObject;
            if (options) {
                that.canvasOptions.width = options.width ? options.width : that.canvasOptions.width;
                that.canvasOptions.height = options.height ? options.height : that.canvasOptions.height;
                that.canvasOptions.fps = options.fps ? options.fps : 23;
            }
            that.startCanvas({ fps: options.fps }, callback);
        }
    }


    /**
     * method to stop screen share
     * @param callback
     */
    that.stopCanvas = (callback) => {
        let status = validateCanvas();
        if (status.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) {
            that.localStreams.forEach((stream) => {
                if (stream && stream.ifCanvas()) {
                    stream.stream.getTracks().forEach((track) => {
                        track.stop();
                    });
                    stream.close();
                    callback({ result: 0, msg: "Canvas stopped successfully." })
                }
                else if (stream && stream.ifVideo()) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('stopCanvas setting video to simulcast: Stream ' + stream);
                    stream.setQualityLayers(3);
                }
            });
        } else {
            callback(status);
        }
    }
    const sendRemoteMediaDeviceControlRequest = (req, mic, cam, broadcast, remClientId, callback) => {
        let error = validatePermission(mic, cam, true);
        if ((error.result === __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) &&
            (broadcast || (remClientId && (typeof remClientId === 'string')))) {
            that.socket.sendMessage(req, { clientId: remClientId }, (resp) => {
                callback(resp);
            });
        } else {
            callback((error.result !== __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000.result) ? error : __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1155);
        }
    }
    const validatePermission = (check_audio, check_video, check_moderator) => {
        let subscription = (!that.subscription || ((!check_video || that.subscription.audio_video) &&
            (!check_audio || (that.subscription.audio_only || that.subscription.audio_video))));
        if (that && subscription && (!check_moderator || (that.me.role === 'moderator'))) {
            return __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000;
        }
        let error = !that ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1171 : !subscription ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1170 : __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1168;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('validateCanvas error code ' + error.result);
        return error;
    }
    const validateCanvas = () => {
        if (that && (!that.subscription || that.subscription.audio_video) &&
            ((that.roomSettings.mode !== 'lecture') || (that.me.role === 'moderator') || (that.floorGranted === true))) {
            return __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_000;
        }
        let error = !that ? __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1171 : (!that.subscription || that.subscription.audio_video) ?
            __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1173 : __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1170;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('validateCanvas error code ' + error.result);
        return error;
    }

    const initCanvas = (props, callback) => {
        var stream = null;
        var config = { video: true, canvas: true, attributes: { name: "canvas" } };
        if (config.canvas === false) {
            config.canvas = true;
        }
        if (config.video === false) {
            config.video = true;
        }
        if (config.audio === true) {
            config.audio = false;
        }

        if (!config.div) {
            config.div = props.domHandle;
        }


        if (!config.fps) {
            config.fps = props.fps;
        }

        if (config.attributes === undefined) {
            config.attributes = { name: "canvas" };
        }
        else if (config.attributes.name === undefined || config.attributes.name === "canvas") {
            that.whoAmI(function (arg) {
                config.attributes.name = arg.name + "_canvas";
            });
        }

        var onAccessError = function (event) {
            if (event.msg.name === "OverconstrainedError")
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Resolution selected is not supported by your webcam');
            callback(event.msg, 'error');
        };
        var onAccessSuccess = function (st) {
            stream = st;
            callback(stream, 'success');
        };
        // config.fps = 23;
        config.videoSize = [1920, 1080, 1920, 1080];
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("initcanvas config " + JSON.stringify(config));
        that.initPublishStream('', config, onAccessSuccess, onAccessError);
        return stream;

    }

    const onCanvasStarted = (arg) => {
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'canvas-started', message: { clientId: arg.clientId, name: arg.name, streamId: arg.streamId } });
        that.canvasStatus = true;
        that.dispatchEvent(evt);
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('onCanvasStarted event :', JSON.stringify(evt));
        if (arg.streamId) {
            const stream = remoteStreams.get(arg.streamId);
            if (stream && !stream.failed) {
                // forcing canvas subscriber stream to take HD layer with appropriate temporal layers
                stream._setStaticQualityLayer(2, -1, function (result) {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('stream._setStaticQualityLayer (2/-1) for canvas result : ' + result);
                });
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('canvas started:stream is undefined or failed');
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('canvas arg.streamId is undefined');
        }
    }


    const onCanvasStopped = (arg) => {
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'canvas-stopped', message: { clientId: arg.clientId, name: arg.name, streamId: arg.streamId } });
        that.canvasStatus = false;
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].debug('onCanvasStarted event :', JSON.stringify(evt));
        that.dispatchEvent(evt);
    }


    const onCanvasStateEvents = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('canvasStateEvents');
        if (arg.videomuted === true) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'canvas-state-events', message: "Canvas stopped", reason: "bw" });
            that.dispatchEvent(evt);
        } else {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'canvas-state-events', message: "Canvas resumed", reason: "bw" });
            that.dispatchEvent(evt);
        }
    }

    const onShareStateEvents = (arg) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('shareStateEvents');
        if (arg.videomuted === true) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'share-state-events', message: "Share stopped", reason: "bw" });
            that.dispatchEvent(evt);
        } else {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'share-state-events', message: "Share resumed", reason: "bw" });
            that.dispatchEvent(evt);
        }
    }
    const onGenericEvents = (arg) => {
        console.log('onGenericEvents' + JSON.stringify(arg));
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: arg.id, message: arg.data });
        that.dispatchEvent(evt);
    }
    const onUserRoleChangedEvent = (arg) => {
        console.log('onUserRoleChangedEvent' + JSON.stringify(arg));
        if (arg.moderator === true) {
            if (that.me.role === 'participant') {
                that.me.role = 'moderator';
                if (that.roomSettings.mode === 'lecture') {
                    that.cCrequest = [];
                    that.approvedHands = [];
                    if (arg.raisedHands.length > 0) {
                        arg.raisedHands.forEach((item) => {
                            that.cCrequest.push(item);
                        });
                    }
                    if (arg.approvedHands.length > 0) {
                        arg.approvedHands.forEach((item) => {
                            that.cCapprovedHands.push(item);
                        });
                    }
                } else {
                    //group mode
                }
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("onUserRoleChangedEvent() Already Moderator - no change");
            }
        } else {
            if (that.me.role === 'moderator') {
                that.me.role = 'participant';
                if (that.roomSettings.mode === 'lecture') {
                    that.cCrequest = [];
                    that.approvedHands = [];
                    var lstrm = that.localStreams.getAll();
                    localStreams.forEach((stream, id) => {
                        that.unpublish(stream, function (arg) {
                            if (arg == true) {
                                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("stream has been un-published");
                            } else {
                                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("error during stream un-publishing");
                                __WEBPACK_IMPORTED_MODULE_12__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_11__customEvents__["a" /* default */].event_stream_unpublish_failed, { stream: stream });
                            }
                        });
                    });
                }
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info("onUserRoleChangedEvent() Already partcipant - no change");
            }
        }
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'user-role-changed', message: arg });
        that.dispatchEvent(evt);
    }

    that.subscribeStreamStatsForClient = (stream, statsEnabled, callback = () => { }) => {
        if (!socket) {
            return 'Error getting stats - no socket';
        }
        if (!stream) {
            return 'Error getting stats - no stream';
        }
        socket.sendMessage('subscribeStreamStatsForClient', { streamId: stream.getID(), statsEnabled: statsEnabled }, (result) => {
            if (result) {
                var selecterStringsButton = document.querySelectorAll(`.stats-container`);
                var selecterStringsOverlay = document.querySelectorAll(`.stats-overlay`);

                if (result.status === 'Success' && statsEnabled === true) //To Do : need result/error code will send the result code
                {
                    that.subscribeSessionStats = true;
                    selecterStringsButton.forEach(function (selecterString) {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'block';
                        }
                    });
                    selecterStringsOverlay.forEach(function (selecterString) {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'block';
                        }
                    });
                }
                else {
                    that.subscribeSessionStats = false;
                    selecterStringsButton.forEach(function (selecterString) {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'none';
                        }
                    });
                    selecterStringsOverlay.forEach(function (selecterString) {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'none';
                        }
                    });
                }
                callback(result);
            }
        });
        return undefined;
    };
    that.manageStatsSubscription = (stream) => {
        if (that.subscribeSessionStats === true) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('resubscribe session stats');
            that.subscribeStreamStatsForClient(stream, that.subscribeSessionStats);
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('session stats not subscribed');
        }
    }

    that.reconPubSubFailed = (message) => {
        // after reconnect publish or subscribe failed, we should clear all peer connection and streams and emit event
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('reconnect publish or subscribe failed', message);
        that.reconnectionAllowed = false;
        clearAll();
        // send reconnection timeout event to application
        let reconnectionTimedOut = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'network-reconnect-timeout', error: __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1167.result, message: message });
        that.dispatchEvent(reconnectionTimedOut);
    };

    that.manageNumTalker = () => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Reset the preferred number of active talkers');
        if (prefNumTakler !== -1) {
            that.setTalkerCount(prefNumTakler, (result) => { __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('reset active talker', result) });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Use default prefrence of number of active talkers');
        }
    };

    that.makeOutboundCall = (dialNumber) => {
        if (dialNumber != null) {
            that.socket.sendMessage("makeOutboundCall", { number: dialNumber }, (result) => {
                if (result) {
                    callback(result);
                }
            });
        }
    };

    const onDialStateEvents = (arg) => {
        console.log('recieved dialStateEvents');
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'dial-state-events', message: { number: msg.number, state: msg.status, description: msg.description } });
        that.dispatchEvent(evt);
    };

    var fileUploader = async function (archive, options = { 'isMobile': false, 'broadcast': true, 'clientList': [] }, callback) {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' init file upload ');
        let upJobId = uploadsInProgress.size;
        let fUploadResult = {
            messageType: 'upload-started', result: 0, description: 'upload started', response: {
                uploadStatus: 'started', upJobId: upJobId, uploadInfo: {
                    upJobId: upJobId,
                    name: archive.name,
                    size: archive.size,
                    type: archive.type,
                }
            }
        };

        try {
            const fs = new __WEBPACK_IMPORTED_MODULE_14__fileShare_app_fileSender__["a" /* default */]();
            let  fSender ={sender:fs,status:'started'};
            uploadsInProgress.set(upJobId, fSender);
            // fire event to app informing upload success  // to do : modify the message and keep only relevent metadata
            let evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
            that.dispatchEvent(evt);
            // upload the file
            const file = await fs.upload(archive);
            let sFile = file.toJSON();

            //update the status as complete and update the map
            fSender.status = 'completed';
            uploadsInProgress.set(upJobId, fSender);
            fUploadResult.messageType = 'upload-completed'
            fUploadResult.response.uploadStatus = fSender.status;
            fUploadResult.response.upJobId = upJobId;
            fUploadResult.description =' upload completed'
            fUploadResult.response.uploadInfo = {
                upJobId: upJobId,
                name: sFile.name,
                size: sFile.size,
                speed: sFile.speed,
                createdAt: sFile.createdAt,
                dlimit: sFile.dlimit,
                time: sFile.time,
                expiresAt: sFile.expiresAt,
                timeLimit: sFile.timeLimit
            };
            if (options.isMobile === true) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file sharing mobile client ');
                fUploadResult.response.uploadInfo = sFile;
                fUploadResult.response.uploadInfo.upJobId = upJobId;
                evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
                that.dispatchEvent(evt);
                callback(fUploadResult);
                return;
            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' is mobile  false ', options.isMobile);
                // web client send the data to signalling server
                // do we want to provide a default way to
                //allow user to append File sharing fantom UI  then this provision can be used with UI modification
                if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                    inFileShareUI(sFile, document.getElementById(fileShareUI.recvElToAppend), 'fs-file-uploaded');

                }

                that.sendFtData(sFile, 'fs-file-available', options.broadcast, options.clientList, function (res) {
                    fUploadResult.response.sentStatus = res;
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('sent message to all participants: file is available for download ', res, 'fupload result', fUploadResult);
                    // fire event to app informing upload success
                    // to do : modify the message and keep only relevent metadata
                    evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
                    that.dispatchEvent(evt);
                    callback(fUploadResult);

                });
                //refactor seems some error need to check why callback not returned from send ft
                evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
                that.dispatchEvent(evt);
                callback(fUploadResult);


            }

        } catch (error) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('upload to file server failed', error);
            uploadsInProgress.delete(upJobId);
            fUploadResult.messageType = 'upload-failed';
            fUploadResult.response.uploadStatus = 'failed';
            fUploadResult.description =' upload failed';
            fUploadResult.result = 1;
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
            that.dispatchEvent(evt);
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('xception in file upload ', error);
            // callback sith failure code
            let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1182;
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' send file failed', result);
            callback(result);
            return;
        }

    };
    //  var callback =( res)=> {console.log('send file response ', res)};
    // (msg, broadcast, clientList, callback)
    that.sendFiles = (files = [], options = { 'isMobile': false, 'broadcast': true, 'clientList': [] }, callback) => {
        // sanatize the input , check if it is a proper file or not
        // upload files
        // check the sanity of files array
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Send file called ' + ' options ' + JSON.stringify(options) + 'file object' + JSON.stringify(files));
        if (that.state === DISCONNECTED && options.isMobile === false) {
            let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1180;
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file upload: room is disconnected  file operations are not allowed');
            callback(result);
            return;
        }
        if (!(callback && typeof callback === "function")) {
            var callback = (res) => { __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('SDK defined callback send file response ', res) };
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('send file called with callback ');
        }
        if (files.length > 0) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('preparing to upload files');
            that.filesToUpload = files;
            try {
                if (that.filesToUpload[that.filesToUpload.length - 1].size <= 0){
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(" file size is 0 bytes ", that.filesToUpload[that.filesToUpload.length - 1].size);
                    let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1186 + that.filesToUpload[that.filesToUpload.length - 1].size;
                    callback(result);
                    return;
                }
                if (!options.isMobile) {
                    // check the size limit
                    if (that.filesToUpload[that.filesToUpload.length - 1].size > maxFileSize) {
                        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(" file upload  limit exceeded. max allowed limit is ", maxFileSize);
                        let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1187 + maxFileSize;
                        callback(result);
                        return;
                    }
                    // send the signalling mesage about upload started
                    let fsMessage = {};
                    fsMessage.data = files;

                    // do we want to provide a default way to
                    //allow user to append File sharing fantom UI  then this provision can be used with UI modification
                    if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                        inFileShareUI(fsMessage, document.getElementById(fileShareUI.recvElToAppend), 'fs-upload-init');

                    }

                    that.sendFtData(fsMessage, 'fs-upload-started', options.broadcast, options.clientList, function (res) {
                        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file-upload-started sent to all participants', res);
                    });

                }
                const archive = new __WEBPACK_IMPORTED_MODULE_15__fileShare_app_archive__["a" /* default */](files);
                fileUploader(archive, options, callback);

            } catch (error) {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('xception occured in send file ', error);
                // callback sith failure code
                let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1182;
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' send file failed', result);
                callback(result);
            }


        }
        else {

            let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1185;
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' input file list to upload is empty', result, ' length of file array', files.length);
            callback(result);


        }


    }


    that.recvFiles = async (index, options = { 'isMobile': false }, callback) => {
        if (that.state === DISCONNECTED && options.isMobile === false) {
            let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1180;
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file download: room is disconnected  file operations are not allowed');
            if (callback != undefined) callback(result);
            return;
        }
        else if (index > shFileList.length) {
            let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1181;
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file download: file is not available');
            if (callback != undefined) callback(result);
            return;
        }
        let fDownloadResult = {
            messageType: 'download-started', result: 0, description: 'download-started', response: {
                downloadStatus: 'started', jobId: index, downloadInfo: that.availableFiles[index],
            }
        };
        try{
            let fileInfo = shFileList[index];
            // download started for file , send the fs-download-result event with data from available list of files
            // set up file receiver
            let url = fileInfo.url.split('#')[0];
            let response = await fetch(url);
            let gheder = response.headers.get('WWW-Authenticate');
            let tempNonce = gheder.replace('send-v1 ', '');
            const fr = new __WEBPACK_IMPORTED_MODULE_16__fileShare_app_fileReceiver__["a" /* default */]({
                secretKey: fileInfo.secretKey,
                id: fileInfo.id,
                nonce: tempNonce,
                requiresPassword: false
            });

            // set the download in progress map
            let fReceiver = { receiver: fr, status: 'started' };
            downloadsInProgress.set(index, fReceiver);
            // fire event to app informing upload success  // to do : modify the message and keep only relevent metadata
            let evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
            that.dispatchEvent(evt);
            // get meta and download file
            await fr.getMetadata();
            let resp=   await fr.download(options);
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file downloaded successfully ', resp);

            fReceiver.status = 'completed';
            downloadsInProgress.set(index, fReceiver);
            fDownloadResult.messageType = 'download-completed'
            fDownloadResult.response.downloadStatus = fReceiver.status;
            fDownloadResult.response.jobId = index;
            fDownloadResult.description = ' upload completed'
            evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
            that.dispatchEvent(evt);

            if (callback != undefined)callback(resp);


        } catch(error){
            // delete the entry from download progress map
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(" file download failed", error);
            downloadsInProgress.delete(index);
            fDownloadResult.messageType = 'download-failed';
            fDownloadResult.response.downloadStatus = 'failed';
            fDownloadResult.description = ' download failed';
            fDownloadResult.result = 1;// do we send 1 for failure for other SDK fails ? need to check
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
            that.dispatchEvent(evt);

            let result = __WEBPACK_IMPORTED_MODULE_9__customErrors__["a" /* default */].error_1183;
            if (callback != undefined) callback(result);
        }

    }

    that.mobileSetAvailableFile = (dat, callback) => {
        __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('mobile sdk wants to set the available file list ', dat);
        // To Do validate and sanantize to see if SDK is pushing correct values ?
        if (dat.message.type === 'fs-file-available') {
            // can further sanataze but do we need ?
            shFileList.push(dat.message);
            // mobile does not have available file list and we do not want to expose full structure
            // to do :- find a better solution to abstract this for mobile sdk user and normal open API
            let favailable = {
                name: dat.message.name,
                size: dat.message.size,
                speed: dat.message.speed,
                createdAt: dat.message.createdAt,
                dlimit: dat.message.dlimit,
                time: dat.message.time,
                expiresAt: dat.message.expiresAt,
                timeLimit: dat.message.timeLimit,
                index: shFileList.length - 1,
            };
            that.availableFiles.push(favailable);

            callback(true);
        } else {
            callback(true);
        }

    }


    that.setFsEndPoint = (options = { isMobile: false, fsDetails: {} }) => {
        if (options.isMobile === true) {
        //    Logger.info('set filsharing service details from mobile client', JSON.stringify(options.fsDetails));
            Object(__WEBPACK_IMPORTED_MODULE_13__fileShare_app_api__["f" /* setFileShareServiceEndPoint */])(options.fsDetails, options.callInfo); // pass the call info as well
        }

    }

    // added for testing , if needed we can extend it to provide injected UI
    that.inJectFsUI = (options = { enable: true, uploadElToAppend: '', recvElToAppend: '' }) => {
        if (options && options.enable === true && options.uploadElToAppend !== '' && document.getElementById(options.uploadElToAppend) !== null && options.recvElToAppend !== '' && document.getElementById(options.recvElToAppend) !== null) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' show file sharing UI ');
            that.showFsUi = true;
            fileShareUI.uploadElToAppend = options.uploadElToAppend;
            fileShareUI.recvElToAppend = options.recvElToAppend;
            that.testFT();
        }
        else {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file UI injection failed');
        }



    }

    that.testFT = () => {
        if ((that.showFsUi === false) || (that.showFsUi === true && document.getElementById(fileShareUI.uploadElToAppend) === null)) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' file upload  UI can not be appended');
            return;
        }
        var x = document.createElement("INPUT");
        x.setAttribute("type", "file");
        x.setAttribute("id", 'filesID');
        //  var elToAppend = document.getElementById('chat_btn');
        var elToAppend = document.getElementById(fileShareUI.uploadElToAppend);
        elToAppend.appendChild(x);

        function handleFileSelect(evt) {
            var files = evt.target.files; // FileList object
            //    that.filesToUpload = files;
            // temp test for android
            //    that.sendFiles(that.filesToUpload);
            that.sendFiles(files);
            // Loop through the FileList and render image files as thumbnails.
            for (var i = 0, f; f = files[i]; i++) {

                console.log(f);

            }
        }

        document.getElementById('filesID').addEventListener('change', handleFileSelect, false);
        document.getElementById('filesID').addEventListener("click", function (evt) {
            evt.target.value = null ;
        }, false);
    }
    //room level functionality to cancel all running uploads
    that.cancelUploads = (cancelAll = false, upJobId = undefined, callback) => {
        let res ={description:'failed', result: 1};
        if (upJobId === undefined && cancelAll === false){
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error(' upJobId must be defined for cancelling a particular upload ');
            res.description = 'upJobId is undefined.';
            res.result =1;
            if (callback !== undefined) return callback(res);
            return;
        }
        else if (cancelAll === true){
            for (var [key, value] of uploadsInProgress) {
                if (value.status === 'started') {
                    value.sender.cancel();
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' running jobs are', value);
                }
                else {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' status is ', value.status);
                }
            }
            res.description = 'Cancelled all uploads';
            res.result = 0;
            if (callback !== undefined)callback(res);
            return;
        } else if (upJobId != undefined ){
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('cancelling specified upload with id', upJobId);
            let cancelUpload =uploadsInProgress.get(upJobId);
            if (cancelUpload != undefined ){
                if(cancelUpload.status === 'started'){
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('canceled upload', upJobId );
                    cancelUpload.sender.cancel();
                    res.description = 'Cancelled upload ' + upJobId ;
                    res.result = 0;
                    if (callback != undefined)callback(res);
                }
                else if (cancelUpload.status === 'completed') {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('upload can not be cancelled because it is already completed');
                    res.description = 'upload is already completed.';
                    res.result = 1;
                    if (callback != undefined) callback(res);

                }

            }else{
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Uplode id is invalid');
                res.description = 'Uplode id is invalid. ';
                res.result = 1;
                if (callback != undefined) callback(res);

            }
        }


    };

    //room level functionality to cancel all running uploads
    that.cancelDownloads = (cancelAll = false, dJobId = undefined, callback) => {
        let res = { description: 'failed', result: 1 };
        if (dJobId === undefined && cancelAll === false) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].error('ID must be defined for cancelling a particular upload ');
            res.description = 'ID is undefined.';
            res.result = 1;
            if (callback !== undefined) return callback(res);
            return;
        }
        else if (cancelAll === true) {
            for (var [key, value] of downloadsInProgress) {
                if (value.status === 'started') {
                    value.receiver.cancel();
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' running jobs are', value);
                }
                else {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info(' status is ', value.status);
                }
            }
            res.description = 'Cancelled all downloads';
            res.result = 0;
            if (callback !== undefined) callback(res);
             return;
        } else if (dJobId != undefined) {
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('cancelling specified download with id', dJobId);
            dJobId=dJobId.toString();
            let cancelDownloadload = downloadsInProgress.get(dJobId);
            if (cancelDownloadload != undefined) {
                if (cancelDownloadload.status === 'started') {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('cancelling download', dJobId);
                    cancelDownloadload.receiver.cancel();
                    res.description = 'Cancelled download ' + dJobId;
                    res.result = 0;
                    if (callback != undefined) callback(res);
                }
                else if (cancelDownloadload.status === 'completed') {
                    __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('Download can not be cancelled because it is already completed');
                    res.description = 'download is already completed.';
                    res.result = 1;
                    if (callback != undefined) callback(res);

                }

            } else {
                __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('download id is invalid');
                res.description = 'Download id is invalid. ';
                res.result = 1;
                if (callback != undefined) callback(res);

            }
        }


    };

    // test function for mobile SDK file sharing  // remove it latter
    that.testFtMobile = (isMobile = false) => {
        var x = document.createElement("INPUT");
        x.setAttribute("type", "file");
        x.setAttribute("id", 'files-mobile');
        var elToAppend = ''
        if (isMobile === false) {
            elToAppend = document.getElementById('chat_btn');

        } else {
            elToAppend = document.body;

        }

        elToAppend.appendChild(x);

        function handleFileSelect(evt) {
            var files = evt.target.files; // FileList object
            __WEBPACK_IMPORTED_MODULE_7__utils_Logger__["a" /* default */].info('mobile list of files to upload', files[0]);

            that.filesToUpload = files;
            // that.sendFiles(that.filesToUpload);

            // Loop through the FileList and render image files as thumbnails.
            for (var i = 0, f; f = files[i]; i++) {

                console.log('iterating file list', f);


            }
        }

        document.getElementById('files-mobile').addEventListener('change', handleFileSelect, false);
    }

    if (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() !== 'IE') {
        that.on('room-disconnected', clearAll);
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream, socketEventToArgs.bind(null, socketOnAddStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting, socketEventToArgs.bind(null, socketOnVcxRtcMessage));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.signaling_message_peer, socketEventToArgs.bind(null, socketOnPeerMessage));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.publish_me, socketEventToArgs.bind(null, socketOnPublishMe));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.unpublish_me, socketEventToArgs.bind(null, socketOnUnpublishMe));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthAlert, socketEventToArgs.bind(null, socketOnBandwidthAlert));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onSelfBandwidthAlert, socketEventToArgs.bind(null, socketOnSelfBandwidthAlert));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onDataStream, socketEventToArgs.bind(null, socketOnDataStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onUpdateAttributeStream, socketEventToArgs.bind(null, socketOnUpdateAttributeStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream, socketEventToArgs.bind(null, socketOnRemoveStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, socketEventToArgs.bind(null, socketOnDisconnect));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.connection_failed, socketEventToArgs.bind(null, socketOnICEConnectionFailed));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.error, socketEventToArgs.bind(null, socketOnError));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveTrack, socketEventToArgs.bind(null, socketOnRemoveTrack));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_connected, socketEventToArgs.bind(null, userConnect));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected, socketEventToArgs.bind(null, userDisConnect));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed, socketEventToArgs.bind(null, userSubcribe));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_unsubscribed, socketEventToArgs.bind(null, userUnSubcribe));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_requested, socketEventToArgs.bind(null, floorRequest));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_granted, socketEventToArgs.bind(null, floorGrant));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_not_granted, socketEventToArgs.bind(null, floorNotGrnat));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.floor_released, socketEventToArgs.bind(null, floorRelease));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.dial_state_events, socketEventToArgs.bind(null, onDialStateEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_awaited, socketEventToArgs.bind(null, onUserAwaited));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.data_stream_room, socketEventToArgs.bind(null, socketOnDataStreamToRoom));

        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_awaited, socketEventToArgs.bind(null, onRoomAwaited));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_connected, socketEventToArgs.bind(null, onRoomConnected));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_record_on, socketEventToArgs.bind(null, onRoomRecordStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.room_record_off, socketEventToArgs.bind(null, onRoomRecordStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.new_active_talker, socketEventToArgs.bind(null, onNewActiveTalker));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_audio, socketEventToArgs.bind(null, onHardMuteAudio));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_audio, socketEventToArgs.bind(null, onHardUnmuteAudio));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_video, socketEventToArgs.bind(null, onHardMuteVideo));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_video, socketEventToArgs.bind(null, onHardUnmuteVideo));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.share_started, socketEventToArgs.bind(null, onShareStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.share_stopped, socketEventToArgs.bind(null, onShareStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.share_state_events, socketEventToArgs.bind(null, onShareStateEvents));

        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.canvas_started, socketEventToArgs.bind(null, onCanvasStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.canvas_stopped, socketEventToArgs.bind(null, onCanvasStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.canvas_state_events, socketEventToArgs.bind(null, onCanvasStateEvents));

        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.generic_events, socketEventToArgs.bind(null, onGenericEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.user_role_changed, socketEventToArgs.bind(null, onUserRoleChangedEvent));

        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].RoomEvent.switch_codec, socketEventToArgs.bind(null, onSwitchCodec));

        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_audio_muted, socketEventToArgs.bind(null, onUserAudioMuted));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_audio_unmuted, socketEventToArgs.bind(null, onUserAudioUnmuted));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_video_muted, socketEventToArgs.bind(null, onUserVideoMuted));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].UserEvent.user_video_unmuted, socketEventToArgs.bind(null, onUserVideoUnmuted));

        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute, socketEventToArgs.bind(null, onHardmuteOne));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute_room, socketEventToArgs.bind(null, onHardmuteRoom));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.hard_unmute_room, socketEventToArgs.bind(null, onHardUnmuteRoom));
        socket.on(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onStatSubscription, socketEventToArgs.bind(null, socketOnStatSubscription));

    } else {
        if (document.getElementById('WebrtcEverywherePluginId') === null)
            that.installPlugin();
        var plugin = document.getElementById('WebrtcEverywherePluginId');

        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream, function (event) {
            for (arg in event.data.args)
                socketOnAddStream(event.data.args[arg]);
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream, function (event) {
            for (arg in event.data.args)
                socketOnRemoveStream(event.data.args[arg]);
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting, function (event) {
            for (arg in event.data.args)
                socketOnVcxRtcMessage(event.data.args[arg]);
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.publish_me, function (event) {
            for (arg in event.data.args)
                socketOnPublishMe(event.data.args[arg]);
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_connected, function (event) {
            for (arg in event.data.args)
                userConnect(event.data.args[arg]);
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected, function (event) {
            for (arg in event.data.args)
                userDisConnect(event.data.args[arg]);
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed, function (event) {
            for (arg in event.data.args)
                userSubcribe(event.data.args[arg]);
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].SocketEvent.user_unsubscribed, function (event) {
            for (arg in event.data.args)
                userUnSubcribe(event.data.args[arg]);
        });

    }
    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (Room);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__views_AudioPlayer__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__views_VideoPlayer__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Pair__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_ErrorHandler__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__customErrors__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Localization__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__customEvents__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__EventLogger__ = __webpack_require__(7);
/* Import Global Libraries */











/*
 * Class: Stream
 * Description: This class represents a stream, either a Published Local Stream or Subscribed Remote Stream.
 *              This Class will handle WebRTC stream, identify it and draw it in Player.
 * Author: Subrat
 * Las Edit Date: 27/11/2017
 * Relase Version: 1.0
 */


const Stream = (altConnection, specInput) => {
    const spec = specInput;
    const that = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["b" /* EventDispatcher */])(spec);
    that.config =  specInput;
    that.stream = spec.stream;    // Media Stream
    that.url = spec.url;          // URL - if a stream is initiated from a URL
    that.recording = spec.recording;  // If a stream is initiated from a Recorded File.
    that.recordingId = undefined;
    that.room = undefined;        // Gets room info when its published in a Room.
    that.showing = false;         // If the Stream is being played in any DOM Object.
    that.local = false;           // If the Stream is a local stream.
    that.video = spec.video;      // If the stream has Video Track. Or, if a local stream has access to Video Device
    that.audio = spec.audio;      // If the stream has Audio Track. Or, if a local stream has access to Mic Device
    that.screen = spec.screen;    // If the stream has Screen Track. Or, if a local stream has access to Screen
    that.videoSize = spec.videoSize;      // VideoSize to be defined in 4 element array [minWidth, minHeight, maxWidth, maxHeight]
    that.videoFrameRate = spec.videoFrameRate;    // Video Frame Rate - Initiated or Opted, defined in 2 element array [min, max]
    that.extensionId = spec.extensionId;  // Chrome Extension ID for Screen Share App
    that.desktopStreamId = spec.desktopStreamId;  // Stream ID for Screen Share
    that.recordingId = spec.recordingId; // Archived File ID of recorded stream. Used for playback
    that.clientId = spec.clientId;
    that.videoMutedDueToBw = false;      // If video track has been muted
    that.hardAudioMuted = false;
    that.hardVideoMuted = false;
    that.selfMuteVideo = false;
    that.selfMuteAudio = false;
    that.ATVideoMuted = false;
    that.processingVideoMute = false;
    that.attributes = spec.attributes;  // Additional Information about Stream, defined as {var: value, var:value}
    that.Connection = altConnection === undefined ? __WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */] : altConnection;
    that.playerDivs = [];
    that.canvas = spec.canvas;
    that.transactions = new Map();
    that.audioStream = spec.audioStream;
    that.videoStream = spec.videoStream;
    that.recordedBlobs = [];
    let audioMuted = false;      // If audio track has been muted
    let videoMuted = false;      // If video track has been muted
    that.abwdEnabled = true;
    that.abwdNotification = 'sdk';
    that.abwdLanguage = 'en';
    let currentMediaType = 'none';
    let currentRemoteClientId = 'none';
    let currentImageDisplay = false;
    let currentVideoMuteReason = 'none';


    // Verify if video size specified in the specs is legible
    if (that.videoSize !== undefined && (!(that.videoSize instanceof Array) || that.videoSize.length !== 4)) {
        throw Error('Error! Invalid Video Size');
    }

    if (spec.local === undefined || spec.local === true) {
        that.local = true;
    }


    // ************************************
    // Public function: getID()
    // It returns Unique Stream ID of Published and Subscribed Streams.
    // ************************************

    that.getID = () => {
        let id;
        // An initiated local stream will not have ID unless its published.
        if (that.local && !spec.streamID) {
            id = 'local';  // Inititing ID with a String Constant "Local"
        } else {
            id = spec.streamID;
        }
        return id;
    };


    // ************************************
    // Public function: getAttributes()
    // It returns attributes of the stream
    // ************************************

    that.getAttributes = () => {
        return spec.attributes;
    };



    // ************************************
    // Public function: setAttributes()
    // It changes local & published stream attribute in room
    // ************************************

    that.setAttributes = (attrs) => {
        if (that.local) {
            that.emit(Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'internal-set-attributes', stream: that, attrs }));
            return;
        }
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error('Error! Stream Object is not published. Failed to update attributes.');
    };


    // ************************************
    // Public function: updateLocalAttributes()
    // It changes local attributes of local or subscribed streams. Changes not reflected in Room
    // ************************************

    that.updateLocalAttributes = (attrs) => {
        spec.attributes = attrs;
    };



    // ************************************
    // Public function: ifAudio()
    // It returns if the Stream has Audio Track
    // ************************************

    that.ifAudio = () => {
        if ( spec.audio !== false && spec.audio !== undefined ) {
            return true;
        }
        else {
            return false;
        }
    };



    // ************************************
    // Public function: ifVideo()
    // It returns if the Stream has Video Track
    // ************************************

    that.ifVideo = () => {
        if ( spec.video !== false && spec.video !== undefined ) {
            return true;
        }
        else {
            return false;
        }
    };


    // ************************************
    // Public function: ifData()
    // It returns if the Stream has Data Track
    // ************************************

    that.ifData = () => {
        if (  spec.data !== false && spec.data !== undefined  ) {
            return true;
        }
        else {
            return false;
        }
    };


    // ************************************
    // Public function: ifScreen()
    // It returns if the Stream has Screen Share Track
    // ************************************

    that.ifScreen = () => {
        return spec.screen;
    };


    // ************************************
    // Public function: ifMedia()
    // It returns if the Stream has either  Audio track,  Video track or Screen Track
    // ************************************

    that.ifMedia = () => {
        if ( spec.audio !== false && spec.audio !== undefined ) {
            return true;
        }
        else if ( spec.video !== false && spec.video !== undefined ) {
            return true;
        }
        else if ( spec.screen !== false ) {
            return true;
        }
        else {
            return false;
        }
    };


    // ************************************
    // Public function: ifExternal()
    // It returns if the Stream Video Track is created from URL or a Recorded File
    // ************************************

    that.ifExternal = () => {
        if ( that.url !== undefined || that.recording !== undefined ) {
            return true;
        }
        else {
            return false;
        }
    }



    that.ifCanvas = () => {
        return spec.canvas;
    }

    // ************************************
    // Public function: sendData()
    // Sends plain text or mime encoded data.
    // This function will further evolve by changing parameter and Stream-Event to handle Public/Pvt Messages
    // ************************************

    that.sendData = (msg) => {
        if (that.local && that.ifData()) {
            that.emit(Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'internal-send-data', stream: that, msg }));
            return;
        }
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error('Error! Stream Object is not published. Failed to send data.');
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_send_data_failed, {error:'Error! Stream Object is not published. Failed to send data.'});
    };


    // ************************************
    // Public function: init()
    // Intializes stream, tries to  get access of Local Video and Audio Devices
    // This function must be called before one can publish stream into a room.
    // However, we don't want to shwocase this method to developers. Rather they would
    // Simply call an InitPublisher() function which will initiaze stream and do init(0 and
    // return the object
    // ************************************

    that.init = () => {
        try {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("requested getUsermedia options: " + JSON.stringify(spec));
            if ((spec.audio || spec.video || spec.screen || spec.canvas) || spec.url === undefined) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('Note! Requested access to local media');
                let videoOpt = false, audioOpt = false ,canvasOpt = false;
                let videoSizeForCanvas =  [640, 480, 1280, 720];
                if (spec.video && (spec.video !== false)){
                  videoOpt = {};
                  if (that.videoSize !== undefined) {
                      videoOpt = { width : {min: that.videoSize[0], max: that.videoSize[2], ideal: that.videoSize[2]},
                                   height: {min:that.videoSize[1], max: that.videoSize[3], ideal:that.videoSize[3]}};
                  }
                  if (that.videoFrameRate !== undefined)
                    videoOpt.frameRate = { min: that.videoFrameRate[0],max: that.videoFrameRate[1]};
					        if ((typeof spec.video === "object") &&  (spec.video.deviceId !== undefined))
                    videoOpt.deviceId = (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() !== 'safari') ?
                                        { exact: spec.video.deviceId } : spec.video.deviceId;
                }if (spec.screen && (spec.screen !== false)){
                    videoOpt = true;
                }if (spec.canvas && spec.canvas !== false){
                  canvasOpt = {};
                  if(that.videoSize === undefined)
                      canvasOpt = { width : {min: that.videoSizeForCanvas[0], max: that.videoSizeForCanvas[2]},
                                   height: {min:that.videoSizeForCanvas[1], max: that.videoSizeForCanvas[3]},
                                   canvasId: spec.div , fps: spec.fps};
                  else {
                      canvasOpt = { width : {min: that.videoSize[0], max: that.videoSize[2]},
                                   height: {min:that.videoSize[1], max: that.videoSize[3]},
                                   canvasId:spec.div, fps:spec.fps};
                  }
                }
                if(spec.audio && (spec.audio !== false)) {
                  audioOpt = {echoCancellation: {exact: true}, googEchoCancellation: {exact: true},
                              autoGainControl: {exact: true}, noiseSuppression: {exact: true},
                              googHighpassFilter: {exact: true}};
                  if ( (typeof spec.audio === "object") && spec.audio.deviceId){
                    audioOpt.deviceId = { exact: spec.audio.deviceId };
                  }
                }
                const opt = { video:videoOpt, audio: audioOpt, screen: spec.screen, canvas: canvasOpt, fake: spec.fake,
                              extensionId: that.extensionId, desktopStreamId: that.desktopStreamId};
                if(spec.canvas && (spec.canvas !== false)) {
                    that.Connection.GetCanvasStream(opt, (stream) => {
                        that.videoStream = stream;
                        that.stream = stream;
                        console.log('Got stream from canvas', opt);
                        that.videoStream.getTracks().forEach((trackInput) => {
                            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('getTracks canvas: ', trackInput);
                            const track = trackInput;
                            track.onended = () => {
                                that.videoStream.getTracks().forEach((secondTrackInput) => {
                                    const secondTrack = secondTrackInput;
                                    secondTrack.onended = null;
                                });

                                const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({
                                    type: 'stream-ended',
                                    stream: that,
                                    msg: track.kind
                                });
                                that.dispatchEvent(streamEvent);
                            };
                        });
                        const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'media-access-allowed', stream:that });
                        that.dispatchEvent(streamEvent);
                    }, (err) => {
                        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error('GetCanvasStream: ', err);
                        const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'media-access-denied', msg: err });
                        that.dispatchEvent(streamEvent);
                        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_denied, {error:err});
                    });
                }
                else{
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('Note!! calling getUserMedia' + JSON.stringify(opt));
                    getUserMedia(opt,(stream,error) => {
                      if (!error){
                        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('Note! User has granted access to local media.');
                        that.stream = stream;
                        that.stream.getTracks().forEach((trackInput, index) => {
                          if(trackInput.kind === 'video') {
                            that.videoStream = stream;
                            if (typeof(spec.video) !== 'object') spec.video = {};
                            spec.video.trackIndex = index;
                            if (trackInput.getSettings().deviceId) spec.video.deviceId = trackInput.getSettings().deviceId;
                            }else if (trackInput.kind === 'audio') {
                              that.audioStream = stream;
                              if (typeof(spec.audio) !== 'object') spec.audio = {};
                              spec.audio.trackIndex = index;
                              if (trackInput.getSettings().deviceId) spec.audio.deviceId = trackInput.getSettings().deviceId;
                            }
                          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('getTracks', trackInput , ' kind: ' , trackInput.kind);
                          const track = trackInput;
                          track.onended = () => {
                            that.stream.getTracks().forEach((secondTrackInput) => {
                                const secondTrack = secondTrackInput;
                                secondTrack.onended = null;
                            });

                            const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'stream-ended',
                                stream: that,
                                msg: track.kind });

                            that.dispatchEvent(streamEvent);
                          };
                        });
                      const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'media-access-allowed', stream:that });
                      that.dispatchEvent(streamEvent);
                    }else{

                      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error(`Error! Failed to get access to local media. Error code was ${ JSON.stringify(error) }.`);
                      const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'media-access-denied', msg: error });
                      that.dispatchEvent(streamEvent);
                      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_denied, {error:error});
                    }

                  });
                }
            } else {
                const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'media-access-allowed' });
                that.dispatchEvent(streamEvent);
            }
        } catch (e) {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error(`Error! Failed to get access to local media. Error was ${e}.`);
            const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({ type: 'media-access-denied', msg: e });
            that.dispatchEvent(streamEvent);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_denied, {error:e});
        }
    };

    that.initRemoteStream = (stream) => {
      if (!that.local){
        that.stream = stream;
        if ( that.ifAudio() || that.audioOnly){
          that.audioStream  = new MediaStream();
          that.stream.getAudioTracks().forEach(function(track){
            that.audioStream.addTrack(track);
          });
        }
        that.mediaStream  = new MediaStream();
        that.stream.getTracks().forEach(function(track){
          that.mediaStream.addTrack(track);
        });
      }
    }

    // ************************************
    // Public function: close()
    // Unpublishes a published stream from Room. Hides it from HTML DOM object and stops each track of the stream.
    // ************************************

    that.close = () => {
        if (that.local) {

            // Unpublishes stream from Room
            if (that.room !== undefined) {
                that.room.unpublish(that);
            }

            // Removes HTML DOM element
            that.hide();
            if (that.videoStream !== undefined) {
                that.videoStream.getTracks().forEach((trackInput) => {
                    const track = trackInput;
                track.onended = null;
                track.stop(); // Stops each track in the Stream
              });
              that.videoStream = undefined;
            }
            if (that.audioStream !== undefined) {
                that.audioStream.getTracks().forEach((trackInput) => {
                    const track = trackInput;
                track.onended = null;
                track.stop(); // Stops each track in the Stream
              });
              that.audioStream = undefined;
            }
            that.stream = undefined;
        }
    };



    // ************************************
    // Public function: play()
    // Plays the stream in HTML DOM Element. One can pass all player's display options too.
    // ************************************
    that.disableTrack = (streamID) => {
        that.room.removeTrack(streamID);

    };
    that.attachMediaStream = (element, stream) => {
        if (!element) {
            return null;
        }
        if (element.isWebRtcPlugin) {
            element.src = stream;
            return element;
        }
        else if (element.nodeName.toLowerCase() === 'video') {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("Checked element is video");
            if (!element.pluginObj && stream) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("Plugins and stream validated");
                var _pluginObj = document.createElement('object');
                var _isIE = (Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(window, "ActiveXObject")) || ("ActiveXObject" in window);
                if (_isIE) {
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("Browser IE validated");
                    // windowless
                    var windowlessParam = document.createElement("param");
                    windowlessParam.setAttribute('name', 'windowless');
                    windowlessParam.setAttribute('value', true);
                    _pluginObj.appendChild(windowlessParam);
                    _pluginObj.setAttribute('classid', 'CLSID:7FD49E23-C8D7-4C4F-93A1-F7EACFA1EC53');
                } else {
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("Other browser got");
                    _pluginObj.setAttribute('type', 'application/webrtc-everywhere');
                }
                element.pluginObj = _pluginObj;

                _pluginObj.setAttribute('className', element.className);
                _pluginObj.setAttribute('innerHTML', element.innerHTML);
                var width = element.getAttribute("width");
                var height = element.getAttribute("height");
                var bounds = element.getBoundingClientRect();
                if (!width) width = bounds.right - bounds.left;
                if (!height) height = bounds.bottom - bounds.top;

                if ("getComputedStyle" in window) {
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("computing style");
                    var computedStyle = window.getComputedStyle(element, null);
                    if (!width && computedStyle.width != 'auto' && computedStyle.width != '0px') {
                        width = computedStyle.width;
                    }
                    if (!height && computedStyle.height != 'auto' && computedStyle.height != '0px') {
                        height = computedStyle.height;
                    }
                }
                if (width) _pluginObj.setAttribute('width', width);
                else _pluginObj.setAttribute('autowidth', true);
                if (height) _pluginObj.setAttribute('height', height);
                else _pluginObj.setAttribute('autoheight', true);

                document.body.appendChild(_pluginObj);
                if (element.parentNode) {
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("parent node found");
                    element.parentNode.replaceChild(_pluginObj, element); // replace (and remove) element
                    // add element again to be sure any query() will succeed
                    document.body.appendChild(element);
                    element.style.visibility = "hidden";
                }
            }


            if (element.pluginObj) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("plugin object found");
                element.pluginObj.bindEventListener('play', function(objvid) {
                    if (element.pluginObj) {
                        if (element.pluginObj.getAttribute("autowidth") && objvid.videoWidth) {
                            element.pluginObj.setAttribute('width', objvid.videoWidth/* + "px"*/);
                        }
                        if (element.pluginObj.getAttribute("autoheight") && objvid.videoHeight) {
                            element.pluginObj.setAttribute('height', objvid.videoHeight/* + "px"*/);
                        }
                    }
                });
                element.pluginObj.src = stream;
            }

            return element.pluginObj;
        }
        else if (element.nodeName.toLowerCase() === 'audio') {
            return element;
        }
    };
    const getUserMedia = (opt,callback) => {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('getusermedia called  opt' + JSON.stringify(opt));
      that.Connection.GetUserMedia(opt, (stream) => {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('getUserMedia success');
        callback(stream);
      }, (error) => {
        error = Object(__WEBPACK_IMPORTED_MODULE_5__utils_ErrorHandler__["a" /* default */])(error);
        var retry = true;

        if((opt.video.height && opt.video.height.min) && (opt.video.width && opt.video.width.min)) {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('getUserMedia failed error:' + error.result + 'min Res: ' +
                opt.video.height.min + 'X' + opt.video.width.min);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_gum_failed, {error: error});
        }

        if ((error.result == 1149) || (error.result == 1147) || (error.result == 1148)){
           switch(opt.video.height.min){
            case 720:
              opt.video.height.min = 540;
              opt.video.width.min = 960;
            break;
            case 540:
              opt.video.height.min = 480;
              opt.video.width.min = 640;
            break;
            case 480:
              opt.video.height.min = 360;
              opt.video.width.min = 480;
            break;
            default:
              retry = false;
            break;
           }
        }else{
          retry = false;
        }
        if (retry === true){
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('getUserMedia failed retry min Res :' + opt.video.height.min + 'X' + opt.video.width.min);
          getUserMedia(opt,callback);
        }else{
          callback(undefined,error);
        }
      });
    }
    that.setQualityLayers = (numSpatialLayers) =>{
      if(that.pc && that.stream && that.local && that.pc.peerConnection && that.pc.peerConnection.getSenders){
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info(' that.setQulaityLayers numSpatialLayers:' + numSpatialLayers);

        that.pc.peerConnection.getSenders().forEach(function(sender){
          if(sender.track && sender.track.kind === 'video'){
            const parameters = sender.getParameters();
            if ((parameters != undefined ) && (parameters.encodings != undefined)){
              for (var cnt=0; cnt < parameters.encodings.length; cnt++){
                if (numSpatialLayers > cnt){
                  __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info(' Layer :' + cnt + ' enabled' );
                  parameters.encodings[cnt].active = true;
                }else{
                  __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info(' Layer :' + cnt + ' disabled' );
                  parameters.encodings[cnt].active = false;
                }
              }
              sender.setParameters(parameters);
            }else{
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info(' that.setQulaityLayers: no sender params/encodings-  Not in simulcast mod');
            }
          }
        });
      }else {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('setQulaityLayers Failed invalid stream :' + that.stream + ' local: ' + that.local);
      }
    }
    that.setMaxVideoBitarte = (videoBwKbps) => {
      let browser = __WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck();
      if ((browser  === 'chrome-stable') || ((browser  === 'mozilla') &&
            (!__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_7__vcxEventProperties__["a" /* default */].constant.FIREFOX_VERSION_SENDER_ENCODINGS_PARAM_SUPPORT)))){
        that.pc.peerConnection.getSenders().forEach(function(sender){
          if(sender.track && sender.track.kind === 'video'){
            const parameters = sender.getParameters();
            if (parameters != undefined ){
              if (!parameters.encodings) parameters.encodings = [{}];
              for (var cnt=0; cnt < parameters.encodings.length; cnt++){
                  __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error(' that.setMaxVideoBitarte: bw: ',videoBwKbps );
                  parameters.encodings[cnt].maxBitrate = videoBwKbps*1000;
              }
              sender.setParameters(parameters);
            }else{
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error(' that.setMaxVideoBitarte: no sender params/encodings-  ');
            }
          }
        });
      }else {
        //support traditional way of sdp renegotiation.. in kbps
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error ("Setting Max Bw  using sdp reneg videoBwKbps= ",videoBwKbps);
        const config = { maxVideoBW: videoBwKbps, Sdp:true};
        that.pc.updateSpec(config, () => { __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("that.setMaxVideoBitarte: sdp reneg success");});
      }
    }
    that.switchMicrophone = (stream,mic_id,callback) =>{
      setMediaDevicesTrack (stream, mic_id, undefined, (status) => {
        callback( (status.result === 0) ? stream : status);
      });
    }
    that.switchCamera = (stream,cam_id,callback) =>{
      setMediaDevicesTrack (stream, undefined, cam_id, (status) => {
        callback( (status.result === 0) ? stream : status);
      });
    }
    that.switchMediaDevices = (stream, mic_id, cam_id, callback) => {
      setMediaDevicesTrack(stream, mic_id, cam_id,(status) =>{
        callback( (status.result === 0) ? stream : status);
      });
    }

    const setMediaDevicesTrack = (stream, mic_id, cam_id, callback) => {
      if(stream && stream.local===true && stream.pc && stream.pc.peerConnection &&
         !stream.ifScreen() && !stream.ifCanvas()){
        let options ={};
        if (mic_id !==  undefined){
          if (!that.transactions.get("setMicrophoneTrack")){
            that.transactions.set("setMicrophoneTrack", {state: "inprogress"});
          }else {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error("Invalid state: previous request in progress. ");
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_audio_device_access_failed, {mic_id: mic_id});
            return;
          }
          if (mic_id !== "none") options.audio = {deviceId: { exact: mic_id}};
          else options.audio = true;
        }else options.audio = false;
        if (cam_id !== undefined){
          if (!that.transactions.get("setCameraTrack"))that.transactions.set("setCameraTrack", {state: "inprogress"});
          else {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error("Invalid state: previous request in progress. ");
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_video_device_access_failed, {cam_id: cam_id});
            return;
          }
          if (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'safari'){
            options.video = { width : that.videoSize[2], height : that.videoSize[3]};
          }else {
            options.video = { width : {min: that.videoSize[0], max: that.videoSize[2]},
                              height: {min:that.videoSize[1], max: that.videoSize[3]}};
          }
          if (cam_id !== "none") options.video.deviceId = { exact: cam_id};
          if (that.videoFrameRate !== undefined)
            options.video.frameRate = { min: that.videoFrameRate[0],max: that.videoFrameRate[1]};
        }else options.video = false;

        getUserMedia(options,(streamGot, error) => {
          if (error == undefined){
            replaceNewMediaStreamTrack (stream, (mic_id !== undefined),(cam_id !== undefined), streamGot);
            stream.stream = streamGot;
            if (cam_id){
              stream.videoStream = streamGot;
              if (cam_id !== "none")
                spec.video.deviceId = cam_id;
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].log("Got video access from devices:- ",  cam_id);
              that.transactions.delete("setCameraTrack");
            }
            if (mic_id){
              stream.audioStream = streamGot;
              if (mic_id !== "none")
                spec.audio.deviceId = mic_id;
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].log("Got audio access from devices:- ",  mic_id);
              that.transactions.delete("setMicrophoneTrack");
            }
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
          }else{
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("Error getUserMedia(), error: " + error + " cam: " + cam_id, " mic: ",  mic_id);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_gum_failed, {cam_id: cam_id, mic_id: mic_id});
            if (mic_id) that.transactions.delete("setMicrophoneTrack");
            if (cam_id) that.transactions.delete("setCameraTrack");
            callback(error);
          }
        });
      }else{
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info("Cannot switch devices over invalid stream");
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
      }
    }
    const replaceNewMediaStreamTrack = (streamObj, audio,video ,newStream) => {
      let sender_audio_track_found = false , sender_video_track_found = false;
      streamObj.pc.peerConnection.getSenders().forEach(function(sender, index){
        if (sender.track){
          if(video && (sender.track.kind === 'video')){
            spec.video.trackIndex = index;
            sender_video_track_found = true;
            if (newStream) {
              newStream.getVideoTracks().forEach(function(vtrack){vtrack.enabled = true;sender.replaceTrack(vtrack);});
            } else {
              sender.replaceTrack(null);
            }
            streamObj.videoStream.getVideoTracks().forEach(function(vtrack){vtrack.onended = null;vtrack.stop();});
          }else if (audio && (sender.track.kind === 'audio')){
            spec.audio.trackIndex = index;
            sender_audio_track_found = true;
            if (newStream){
               newStream.getAudioTracks().forEach(function(atrack){atrack.enabled = true;sender.replaceTrack(atrack);});
            }else {
              sender.replaceTrack(null);
            }
            streamObj.audioStream.getAudioTracks().forEach(function(atrack){atrack.onended = null;atrack.stop();});
          }
        }
      });
      if ((audio && !sender_audio_track_found) || (video && !sender_video_track_found)){
        streamObj.pc.peerConnection.getSenders().forEach(function(sender, index){
          if (!sender.track && newStream){
            if (audio && !sender_audio_track_found &&
                ((spec.audio.trackIndex !== undefined) && (index === spec.audio.trackIndex))){
              sender_audio_track_found = true;
              newStream.getAudioTracks().forEach(function(atrack){atrack.enabled = true;sender.replaceTrack(atrack);});
            }
            if (video && !sender_video_track_found &&
                ((spec.video.trackIndex !== undefined) && (index === spec.video.trackIndex))){
              sender_video_track_found = true;
              newStream.getVideoTracks().forEach(function(vtrack){vtrack.enabled = true;sender.replaceTrack(vtrack);});
            }
          }
        });
        if ((audio && !sender_audio_track_found) || (video && !sender_video_track_found)){
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error("Error: Not finding sender track::  audio: " + audio + " found: " + sender_audio_track_found +
                        " index: " + spec.audio.trackIndex  + " video: " + video + " found: " + sender_video_track_found +
                        " index: " + spec.video.trackIndex);
          streamObj.pc.peerConnection.getSenders().forEach(function(sender, index){
          let kind = sender.track ?sender.track.kind : "none";
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error ("index : " + index + " sender.track: " + sender.track  + " kind : " + kind);
          });
        }
      }
      //streamObj.stream.getTracks().forEach(function(track){track.onended = null;track.stop();});
    }
    const shouldDisplayFrozenImage = (imageOnVideoMute, remoteClientId, userMute) => {
      return (imageOnVideoMute && ((currentRemoteClientId == remoteClientId) || (currentRemoteClientId == 'none')) &&
          ((currentMediaType == 'video') || (currentMediaType == 'audiovideo')|| (currentImageDisplay && !userMute)));
    }
    that.reloadPlayer = function(talkerInfo, imageOnVideoMute){
      let newMediaType = talkerInfo.mediatype;
      let remoteClientId = talkerInfo.clientId;
      if ((currentMediaType == newMediaType) && !currentImageDisplay &&
          (!imageOnVideoMute || currentVideoMuteReason == 'none' || currentVideoMuteReason == talkerInfo.reason)){
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].debug ("reloadPlayer() id : " + that.getID() + " no change in media type: " + newMediaType);
        currentRemoteClientId = remoteClientId;
        return;
      }
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].debug("reloadPlayer() streamId: " + that.getID() + " mediatype:( " + newMediaType + " , " + currentMediaType +
                   " ), clientId:( " + remoteClientId + " , " + currentRemoteClientId + " ), reason:( " +
                   talkerInfo.reason + " , " +    currentVideoMuteReason + " ) " + " imageOnVideoMute: " +  imageOnVideoMute);
      let id = that.getID();
      if (document.querySelector(`#stream${id}`) !== undefined && document.querySelector(`#stream${id}`) !== null) {
        let elementID = `stream${id}`;
        var domIds = document.querySelectorAll('#' + elementID);
        let stremAttached = false;
        domIds.forEach(streamElement => {
          try {
            switch(newMediaType){
            case 'audio':
              //show prevous image incase of video mute TODO - if user mutes, show blank ?.
              currentVideoMuteReason = talkerInfo.reason;
              if (shouldDisplayFrozenImage(imageOnVideoMute, remoteClientId,(talkerInfo.reason == 'user'))){
                //if transition from video-> audio, audio track need to be added
                if (that.mediaStream.getAudioTracks().length == 0){
                  that.stream.getAudioTracks().forEach(function(track){
                  that.mediaStream.addTrack(track);
                  });
                }
              currentImageDisplay = true;
              stremAttached = true;
              break;
            }
            case 'audioOnly':
              if (that.audioStream){
                streamElement.srcObject = that.audioStream;
                currentImageDisplay = false;
                stremAttached = true;
              }else{
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error ("reloadPlayer() failed id : " + that.getID() + " audiostream null " +
                              "medtype - curr: " + currentMediaType + " new: " + newMediaType);
              }
            break;
            case 'video' :
              if (that.mediaStream){
                if (currentMediaType == 'audiovideo'){
                  if (that.mediaStream.getVideoTracks().length == 0){
                    that.stream.getVideoTracks().forEach(function(track){
                      that.mediaStream.addTrack(track);
                    });
                  }
                  if (that.mediaStream.getAudioTracks().length != 0){
                    that.mediaStream.getAudioTracks().forEach(function(track){
                      that.mediaStream.removeTrack(track);
                    });
                  }
                }else{
                  streamElement.srcObject = that.mediaStream;
                }
                currentImageDisplay = false;
                currentVideoMuteReason = 'none';
                stremAttached = true;
              }else{
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error ("reloadPlayer() failed id : " + that.getID() + " videostream null " +
                              "medtype - curr: " + currentMediaType + " new: " + newMediaType);
              }
            break;
            case 'audiovideo':
              if (that.mediaStream){
                if (that.mediaStream.getAudioTracks().length == 0){
                  that.stream.getAudioTracks().forEach(function(track){
                  that.mediaStream.addTrack(track);
                  });
                }
                if (that.mediaStream.getVideoTracks().length == 0){
                  that.stream.getVideoTracks().forEach(function(track){
                    that.mediaStream.addTrack(track);
                  });
                }
                if ((currentMediaType != 'video') || (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'safari')){
                  streamElement.srcObject = that.mediaStream;
                }
                currentImageDisplay = false;
                currentVideoMuteReason = 'none';
                stremAttached = true;
              }else{
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error ("reloadPlayer() failed id : " + that.getID() + " stream null " +
                              "medtype - curr: " + currentMediaType + " new: " + newMediaType);
              }
            break;
            default:
              currentVideoMuteReason = talkerInfo.reason;
              if (shouldDisplayFrozenImage(imageOnVideoMute, remoteClientId,(talkerInfo.reason == 'user'))){
                currentImageDisplay = true;
                stremAttached = true;
                break;
              }
              streamElement.srcObject = null;
              currentImageDisplay = false;
              stremAttached = true;
            break;
            }
          } catch (error) {
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error ("reloadPlayer() id : " + that.getID() + " NULL set " +
                            "medtype - curr: " + currentMediaType + " new: " + newMediaType);
          }
        });
        if (stremAttached){
          currentMediaType = newMediaType;
          currentRemoteClientId = remoteClientId;
        }
      }else{
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error ("reloadPlayer() id : " + that.getID() + " ID selector null  " +
                      "medtype - curr: " + currentMediaType + " new: " + newMediaType);
      }
    };

    that.setBandwidthAlert = function(arg) {
      var lang;
      let streamId = that.getID();
      if(!that.player)
         return;
      if(that.abwdEnabled === true) {
        if(arg.bw === 'low') {
          if(that.abwdNotification === 'sdk') {
            that.player.setBwAlert(true, arg.type, arg.name);
          } else {
            //Fire a stream event to app.
            let Msg = '';
            if(arg.type === 'subscriber') {
              Msg = "subscriber low";
            } else {
              Msg = arg.name + " publisher low";
            }
            console.log("Pusing the abwd event to server");
            const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({
              type: 'bw-alert',
              stream: that,
              msg: Msg
            });
            that.dispatchEvent(streamEvent);
          }
        } else {
          if(that.abwdNotification === 'sdk') {
            that.player.setBwAlert(false);
          } else {
            const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["e" /* StreamEvent */])({
              type: 'bw-restored',
              stream: that
            });
            console.log("Pusing the abwd restore event to server");
            that.dispatchEvent(streamEvent);
          }
       }
     }
    };


    that.setVideoMutedMessage = (arg) => {
      if(that.player == null) return;
      if(arg.videomuted === true && arg.reason === 'bw') {
        that.videoMutedDueToBw = true
        that.player.setVideoMutedMsg(arg);
      } else {
       if(that.videoMutedDueToBw === true) {
        that.player.setVideoMutedMsg(arg);
       }
      }
    };

    that.setBlankFrameOnSubscriberVideoStream = (enable) => {
      for(var i=0;i<that.playerDivs.length;i++) {
        var elem  = document.getElementById(that.playerDivs[i].elementId);
        if(elem){
          var video_tag =  elem.querySelectorAll("video");
          if(video_tag.length > 0){
            var id = video_tag[0].id;
            var domIds = document.querySelectorAll('#' + id);
            domIds.forEach(streamElement => {
              try {
                if (enable === true){
                  streamElement.srcObject= null;
                  //streamElement.poster = null;
                }else{
                  //streamElement.poster = that.stream;
                  //streamElement.srcObject= that.stream;
                  streamElement.srcObject= that.local ? that.videoStream : that.stream;
                }
              }catch (error) {
                 console.log(`Error video stream: ${error}`);
              }
            });
          }
        }
      }
    };
    that.muteSubscriberStreamVideo = (enable) => {
      if(that.stream && !that.local){
        that.stream.getVideoTracks().forEach(function(track){
          track.enabled = !enable;
        });
      }
    };
    //reconnection case
    that.updateVideo = (id) => {

        if (document.querySelector(`#stream${id}`) !== undefined && document.querySelector(`#stream${id}`) !== null) {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('Player element exists and playing the video', `stream${id}`)
            {
                that.htmlPlay(`stream${id}`);
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('Player element does not exist')
        }
    };


    that.play = (elementID, optionsInput) => {
        const options = optionsInput || {};
        that.elementID = elementID;
        let player;
        if(optionsInput.player.abwd) {
          if(optionsInput.player.abwd.enabled !== undefined)
            that.abwdEnabled = optionsInput.player.abwd.enabled;
          if(that.abwdEnabled === true) {
            if(optionsInput.player.abwd.notification) {
              that.abwdNotification = optionsInput.player.abwd.notification;
              if(that.abwdNotification === 'sdk') {
                if(optionsInput.player.abwd.language !== undefined) {
                  if(optionsInput.player.abwd.language === 'en' || optionsInput.player.abwd.language === 'zh'){
                    that.abwdLanguage = optionsInput.player.abwd.language;
                  } else
                    that.abwdLanguage = 'en';
                }
              }
            }
          }
        }
        //only one player is required. currently only Video player is used
        // TODO :remove both players and have single player - media player
        //if ((that.ifVideo() || that.ifScreen()) && !that.audioOnly) {
        if ((that.ifVideo() || that.ifScreen()) || that.audioOnly || that.ifAudio()) {
            // Draw on HTML
            if (elementID !== undefined && (document.getElementById(elementID)!== null)) {

                /*this section of code is responsible to create and play the
                stream in dynamic video tag appended under <div></div>*/
                //-------------------------------------------
                if(__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === "IE"){
                    var vid = document.getElementById(elementID);
                    var video = document.getElementById(elementID);
                    if(vid.nodeName !== 'VIDEO'){
                            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('not video tag');
                            video = document.createElement('video');
                            video.setAttribute("height",vid.getAttribute('height'));
                        video.setAttribute("width",vid.getAttribute('width'));
                            vid.appendChild(video);
                    }
                    that.attachMediaStream(video,that.stream);
                }else{
                    player = Object(__WEBPACK_IMPORTED_MODULE_2__views_VideoPlayer__["a" /* default */])({ id: that.getID(),
                        stream: that,
                        elementID,
                        options
                    });
                    if(that.local)
                    {
                        player.video.muted = true;
                    }

                    that.player = player;
                    that.showing = true;
                }
                that.playerDivs = [];
                that.playerDivs.push({elementId:elementID,options:optionsInput});
                currentMediaType = 'audiovideo';
            }else{
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error("Element not found");
            }
        } else if (that.ifAudio() || that.audioOnly) {
            player = Object(__WEBPACK_IMPORTED_MODULE_1__views_AudioPlayer__["a" /* default */])({ id: that.getID(),
                stream: that,
                elementID,
                options
            });
            if(that.local)
            {
                player.audio.muted = true;
            }

            that.player = player;
            that.showing = true;
            that.playerDivs = [];
            that.playerDivs.push({elementId:elementID,options:optionsInput});
            currentMediaType = 'audio';
        }
        if(that.reload){
            delete that.reload;
        }
        if(that.room !==undefined){
            // if stats are enabled the show the stats UI on player
            if(that.room.subscribeSessionStats === true){
                that.ShowSessionStats(true);
            }
            else{
                that.ShowSessionStats(false);
            }
        }else{
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('room is not allocated to stream , stats UI will not be shown')
        }
    };
    that.resetMediaConfiguration = function (mediaConfiguration) {
        that.pc.resetSDP(mediaConfiguration);
    }
    that.htmlPlay = (elementID, optionsInput) => {
        const options = optionsInput || {};
        that.elementID = elementID;
        let player;
        if (that.ifVideo() || that.ifScreen()) {
            // Draw on HTML
            if (elementID !== undefined) {
                /*this section of code is responsible to create and play the
                stream in dynamic video tag appended under <div></div>*/
                //-------------------------------------------
                /*pass the video tag Id here to play the stream in video tag*/
                //-----------------------------------------------------
                // reconnection case handle duplicate video
            /*    var domId=document.getElementById(elementID);
                //------------------------------------------------
                    try {
                        domId.srcObject = that.stream;
                    } catch (error) {
                        domId.src = URL.createObjectURL(that.stream);
                    }
                    domId.play().then(() => {

                }).catch((error) => {
                });*/

                var domIds = document.querySelectorAll('#' + elementID);
                domIds.forEach(streamElement => {
                    try {
                        streamElement.srcObject = that.local ? that.videoStream : that.stream;
                    } catch (error) {
                        streamElement.src = URL.createObjectURL(that.local ? that.videoStream : that.stream);
                    }
                    streamElement.play().then(() => {

                    }).catch((error) => {
                        console.log(`Erro playing video stream: ${error}`);
                    });
                });

            }
        }
    };

    // ************************************
    // Public function: stop()
    // It destroys the player object if its already being played
    // ************************************

    that.stop = () => {
        if (that.showing) {
           if (that.player !== undefined) {
                that.player.destroy();
                that.showing = false;
            }
        }
    };

    that.show = that.play;
    that.hide = that.stop;
    /* ####this is the temporary mapping between the events call of#### */
    /*that.hasAudio = that.ifAudio;
    that.hasVideo = that.ifVideo;
    that.hasData = that.ifData;
    that.isExternal = that.ifExternal;
    that.hasMedia = that.ifMedia;
    that.hasScreen = that.ifScreen;*/


    /************************************
    //Author:Sohom
    //Description:To take a snapshot of video frame and to return a canvas object.
    // Public function: getVideoFrameCanvas()
    //
     ************************************/

    const getVideoFrameCanvas = (domHandle) => {
        if (that.player !== undefined && that.stream !== undefined) {
            const video = that.player.video;
            const style = document.defaultView.getComputedStyle(video);
            const width = parseInt(style.getPropertyValue('width'), 10);
            const height = parseInt(style.getPropertyValue('height'), 10);
            const left = parseInt(style.getPropertyValue('left'), 10);
            const top = parseInt(style.getPropertyValue('top'), 10);

            let div;
            if (typeof that.elementID === 'object' &&
                typeof that.elementID.appendChild === 'function') {
                div = that.elementID;
            } else {
                div = document.getElementById(that.elementID);
            }

            const divStyle = document.defaultView.getComputedStyle(div);
            const divWidth = parseInt(divStyle.getPropertyValue('width'), 10);
            const divHeight = parseInt(divStyle.getPropertyValue('height'), 10);
            const canvas = document.createElement('canvas');

            canvas.id = domHandle;
            canvas.width = divWidth;
            canvas.height = divHeight;
            canvas.className = 'canvas_input';
            canvas.setAttribute('style', 'position: absolute;top: 15%;left: 45%;z-index: 897;');
            document.body.appendChild(canvas);
            that.inputContext = canvas.getContext('2d');
            updateCanvas(height, width);
            return canvas;
        }
        return null;
    };

    const updateCanvas = (height, width) => {
        that.inputContext.drawImage(that.player.video, 0, 0, width, height);
        // requestAnimationFrame( updateCanvas );
    }

    /************************************
     * Author:Sohom
     * Description:
    // Public function: getVideoFrameURL()
    // To take a snapshot of video frame, the snapshot is saved and a URL is returned
     ************************************/

    that.getVideoFrameURL = (format) => {
        const canvas = getVideoFrameCanvas();
        if (canvas !== null) {
            if (format) {
                return canvas.toDataURL(...format);
            }
            return canvas.toDataURL();
        }
        return null;
    };


    /************************************
     * Author:Sohom
     * Description:
    // Public function: getVideoFrameImage()
    // To take a snapshot of video frame and to return an Image in raw format.
    ************************************/

    that.getVideoFrameImage = (domHandle) => {
        const canvas = getVideoFrameCanvas(domHandle);
        if (canvas !== null) {
            return canvas.getContext('2d').getImageData(10, 10, canvas.width, canvas.height);
        }
        return null;
    };



    // ************************************
    // Public function: checkOptions()
    // Check inconsistensy in Options/Attributes
    // ************************************

    that.checkOptions = (configInput, isUpdate) => {
        const config = configInput;

        // TODO: Check for any incompatible options
        if (isUpdate === true) {  // We are updating the stream
            if (config.audio || config.screen) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].warning('Error! Cannot update type of subscription');
                config.audio = undefined;
                config.screen = undefined;
            }
        } else if (that.local === false) { // check what we can subscribe to
            if (config.video === true && that.ifVideo() === false) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].warning('Error! Stream doesn\'t have Video Track. Can\'t subscribe to Video');
                config.video = false;
            }
            if (config.audio === true && that.ifAudio() === false) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].warning('Error! Stream doesn\'t have Audio Track. Can\'t subscribe to Audio');
                config.audio = false;
            }
        }
        if (that.local === false) {
            if (!that.ifVideo() && (config.slideShowMode === true)) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].warning('Error! Stream doesn\'t have Video Track. Cannot enable slideShowMode. Check parameters');
                config.slideShowMode = false;
            }
        }
    };


    // ************************************
    // Public function: checkOptions()
    // Check inconsistensy in Options/Attributes
    // ************************************
    const muteStreamAudio = (enable,callback = () => {}) => {
      try{
        if (enable === audioMuted){
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
          return;
        }
        if (enable){
          replaceNewMediaStreamTrack (that, true, false,null);
          audioMuted = enable;
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        }else{
          setMediaDevicesTrack(that, (spec.audio.deviceId ? spec.audio.deviceId : "none"), undefined,(status) => {
            if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) audioMuted = enable;
            callback(status);
          });
        }
      } catch (e) {
        console.log("Excpetion happend : " +  e);
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1150);
      }
      return;
    }
    const muteStreamVideo = (enable, callback = () => {}) => {
      try{
        if (enable === videoMuted){
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
          return;
        }
        if (enable){
          replaceNewMediaStreamTrack (that, false, true ,null);
          videoMuted = enable;
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        }else{
          setMediaDevicesTrack(that, undefined, (spec.video.deviceId ? spec.video.deviceId : "none"), (status) => {
            that.updateVideo(that.getID());
            if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) videoMuted = enable;
            callback(status);
          });

        }
      } catch (e) {
        console.log("Excpetion happend : " +  e);
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1150);
      }
    return;
    };
    // ************************************
    // Public function: muteAudio()
    // To mute Audio at local end-point. Callback can be defined at application level
    // ************************************

    that.muteAudio = (callback = () => {}, raiseEvent) => {
      muteStreamAudio(true, (resp) => {
        if (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) {
          that.selfMuteAudio = true
          if ((raiseEvent === undefined) || (raiseEvent !== false)) that.sendEvent("user-audio-muted");
        }
        callback(resp);
      });
    };
    that.setMediaDeviceMuteState = (isMuteOn, audio,video,raiseEvent,callback) => {
      try{
        if (audio){
          if (isMuteOn === audioMuted){
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
            return;
          }
/*
          that.pc.peerConnection.getSenders().forEach(function(sender){
            if(sender.track && sender.track.kind === 'audio'){
              const parameters = sender.getParameters();
              if ((parameters != undefined ) && (parameters.encodings != undefined)){
                for (var cnt=0; cnt < parameters.encodings.length; cnt++){
                  Logger.error("setting encoding cnt " + !isMuteOn);
                  parameters.encodings[cnt].active = !isMuteOn;
                }
                sender.setParameters(parameters);
              }
            }
          });*/
          that.audioStream.getAudioTracks().forEach(function(track){track.enabled = isMuteOn ? false : true;});
          audioMuted = isMuteOn;
          if (raiseEvent) that.sendEvent(audioMuted ? "user-audio-muted" : "user-audio-unmuted");
        }
        if (video){
          if (isMuteOn  === videoMuted){
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
            return;
          }
          that.stream.getVideoTracks().forEach(function(track){ track.enabled = isMuteOn ? false : true;});
          videoMuted = isMuteOn;
          if (raiseEvent) that.sendEvent(videoMuted ? "user-video-muted" : "user-video-unmuted");
        }
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      } catch (e) {
        console.log("Excpetion happend : " +  e);
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1150);
      }
    };

    that.muteAudioNotSelf = (callback = () => {}, raiseEvent) => {
            // that.selfMuteAudio = true;
            muteStreamAudio(true,callback);
            if ((raiseEvent === undefined) || (raiseEvent !== false)) that.sendEvent("user-audio-muted");
    };

    const handleDataAvailable = (event) => {
      if (event.data && event.data.size > 0) {
        that.recordedBlobs.push(event.data);
      }
    };
    that.startLocalRecord = (callback =() =>{}) => {
      if (!that.mediaRecorder){
        try {
        //let options = {mimeType: 'video/webm;codecs=vp8'};
          let options = {mimeType: 'video/webm'};
          that.mediaRecorder = new MediaRecorder(that.stream, options);
          that.mediaRecorder.ondataavailable = handleDataAvailable;
          that.recordedBlobs = [];
          that.mediaRecorder.start(10);
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        } catch (e) {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error('Exception while creating MediaRecorder:', e);
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        }
      }else{
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].error('Recording started already:');
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1174);
      }
    };
    that.stopLocalRecord = (callback =() =>{}) =>{
      if (that.mediaRecorder && that.recordedBlobs.length > 0 ){
        let  today = new Date();
        let  date = today.getFullYear()+'-'+(today.getMonth()+1)+'-'+today.getDate();
        let  time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
        let  fileName  = "stream_" + that.getID() + "_" + date+"::"+time + ".webm";
        const blob = new Blob(that.recordedBlobs, {type: 'video/webm'});
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = fileName;
        a.click();
        window.URL.revokeObjectURL(url);
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      }else{
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1175);
      }
      that.mediaRecorder = undefined;
      that.recordedBlobs = [];
    };

    that.sendEvent = (type) =>{
        if(that.room){
            that.room.socket.sendEvent(type,(result) => {
            });
        }
    }
    that.sendMessage = (type,options,callback = () => {}) =>{
        if(that.room){
            that.room.socket.emitEvent(type,options,(result) => {
                callback(result);
            });
        }
    }

    // ************************************
    // Public function: unmuteAudio()
    // To unmute Audio at local end-point. Callback can be defined at application level
    // ************************************

    that.unmuteAudio = (callback = () => {}, raiseEvent) => {
        if(that.hardAudioMuted === false) {
            muteStreamAudio(false, (resp) =>{
                if (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) {
                  that.selfMuteAudio = false;
                  if ((raiseEvent === undefined) || (raiseEvent !== false)) that.sendEvent("user-audio-unmuted");
                }
                callback(resp);
              });
        }else{
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1176);
        }
    };

    that.hardMuteAudio = (callback = () => {}) => {
        if(that.room && !that.local){
            that.sendMessage("hardmute-user-audio",{clientId:that.clientId});
        }
    }
    that.hardUnmuteAudio = (callback = () => {}) => {
        if(that.room && !that.local){
            that.sendMessage("hardunmute-user-audio",{clientId:that.clientId});
        }
    }
    that.hardMuteVideo = (callback = () => {}) => {
        if(that.room && !that.local){
            that.sendMessage("hardmute-user-video",{clientId:that.clientId});
        }
    }
    that.hardUnmuteVideo = (callback = () => {}) => {
        if(that.room && !that.local){
            that.sendMessage("hardunmute-user-video",{clientId:that.clientId});
        }
    }
    // ************************************
    // Public function: muteVideo()
    // To mute Video at local end-point. Callback can be defined at application level
    // ************************************
    that.muteNonATPubVideo = (callback = () => {}) => {
      if (that.videoStream){
        that.room.videoMuted = true;
        that.ATVideoMuted = true;
        that.videoStream.getVideoTracks().forEach(function (track) {
           track.enabled = false;
        });
      }
    };

    that.unmuteNonATPubVideo = (callback = () => {}) => {
      if (that.videoStream){
        if(that.hardAudioMuted === false && that.selfMuteVideo === false && that.ATVideoMuted === true) {
            that.room.videoMuted = false;
            that.ATVideoMuted = false;
            that.videoStream.getVideoTracks().forEach(function (track) {
                track.enabled = true;
            });
        }
      }
    };

    that.muteVideo = (callback = () => {},raiseEvent) => {
      muteStreamVideo(true, (resp) => {
        if(resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) {
          that.room.videoMuted = true;
          that.selfMuteVideo = true;
          if ((raiseEvent === undefined) || (raiseEvent !== false)) that.sendEvent("user-video-muted");
        }
        callback(resp);
      });
    };

    // ************************************
    // Public function: unmuteVideo()
    // To unmute Video at local end-point. Callback can be defined at application level
    // ************************************

    that.unmuteVideo = (callback = () => {}, raiseEvent) => {
      if(that.hardVideoMuted === false) {
         muteStreamVideo(false, (resp) => {
            if(resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) {
              that.room.videoMuted = false;
              that.selfMuteVideo = false;
              if ((raiseEvent === undefined) || (raiseEvent !== false)) that.sendEvent("user-video-unmuted");
            }
            callback(resp);
          });
        }else{
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1176);
        }
    };


    // ************************************
    // Public function: _setStaticQualityLayer()
    // eslint-disable-next-line no-underscore-dangle
    // ************************************

    that._setStaticQualityLayer = (spatialLayer, temporalLayer, callback = () => {}) => {
        if (that.room && that.room.p2p) {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].warning('Error! p2p streams don\'t support setStaticQualityLayer');
            callback('error');
            return;
        }

        const config = { qualityLayer: { spatialLayer, temporalLayer } };
        that.checkOptions(config, true);
        that.pc.updateSpec(config, callback);
    };



    // ************************************
    // Public function: _setDynamicQualityLayer()
    // eslint-disable-next-line no-underscore-dangle
    // ************************************

    that._setDynamicQualityLayer = (callback) => {
        if (that.room && that.room.p2p) {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].warning('Error! p2p streams don\'t support setDynamicQualityLayer');
            callback('error');
            return;
        }
        const config = { qualityLayer: { spatialLayer: -1, temporalLayer: -1 } };
        that.checkOptions(config, true);
        that.pc.updateSpec(config, callback);
    };



    // ************************************
    // Function: controlHandler()
    // eslint-disable-next-line no-underscore-dangle
    // ************************************

    const controlHandler = (handlersInput, publisherSideInput, enable) => {
        let publisherSide = publisherSideInput;
        let handlers = handlersInput;
        if (publisherSide !== true) {
            publisherSide = false;
        }

        handlers = (typeof handlers === 'string') ? [handlers] : handlers;
        handlers = (handlers instanceof Array) ? handlers : [];

        if (handlers.length > 0) {
            that.room.sendControlMessage(that, 'control', { name: 'controlhandlers',
                enable,
                publisherSide,
                handlers });
        }
    };



    // ************************************
    // Function: disableHandlers()
    // desc:
    // ************************************

    that.disableHandlers = (handlers, publisherSide) => {
        controlHandler(handlers, publisherSide, false);
    };



    // ************************************
    // Function: enableHandlers()
    // desc:
    // ************************************

    that.enableHandlers = (handlers, publisherSide) => {
        controlHandler(handlers, publisherSide, true);
    };



  that.updateSimulcastLayersBitrate = (bitrates) => {
    if (that.pc && that.local) {
      that.pc.updateSimulcastLayersBitrate(bitrates);
    }
  };

    // ************************************
    // Public Function: updateConfiguration()
    // desc: To update configuraiton of stream on peer connection
    // ************************************

    that.updateConfiguration = (config, callback = () => {}) => {
        if (config === undefined) { return; }
        if (that.pc) {
            that.checkOptions(config, true);
            if (that.local) {
                if (that.room.p2p) {
                    for (let index = 0; index < that.pc.length; index += 1) {
                        that.pc[index].updateSpec(config, callback);
                    }
                } else {
                    that.pc.updateSpec(config, callback);
                }
            } else {
                that.pc.updateSpec(config, callback);
            }
        } else {
            callback('Error! This stream has no peerConnection attached, Skipping');
        }
    };

    that.ShowSessionStats = (statsEnabled) => {
        if (statsEnabled === true) {
            if (that.player !== undefined) {
                that.player.ShowSessionStats(true);
            } else {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('stream does not have a player to show stats');
            }
        } else {
            if (that.player !== undefined) {
                that.player.ShowSessionStats(false);
            } else {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["a" /* default */].info('stream does not have a player to hide stats');
            }
        }
    }
    return that;
}
/* harmony default export */ __webpack_exports__["a"] = (Stream);


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = transformStream;
/* harmony export (immutable) */ __webpack_exports__["a"] = blobStream;
/* harmony export (immutable) */ __webpack_exports__["b"] = concatStream;
/* global TransformStream */

function transformStream(readable, transformer, oncancel) {
  try {
    return readable.pipeThrough(new TransformStream(transformer));
  } catch (e) {
    const reader = readable.getReader();
    return new ReadableStream({
      start(controller) {
        if (transformer.start) {
          return transformer.start(controller);
        }
      },
      async pull(controller) {
        let enqueued = false;
        const wrappedController = {
          enqueue(d) {
            enqueued = true;
            controller.enqueue(d);
          }
        };
        while (!enqueued) {
          const data = await reader.read();
          if (data.done) {
            if (transformer.flush) {
              await transformer.flush(controller);
            }
            return controller.close();
          }
          await transformer.transform(data.value, wrappedController);
        }
      },
      cancel(reason) {
        readable.cancel(reason);
        if (oncancel) {
          oncancel(reason);
        }
      }
    });
  }
}

class BlobStreamController {
  constructor(blob, size) {
    this.blob = blob;
    this.index = 0;
    this.chunkSize = size || 1024 * 64;
  }

  pull(controller) {
    return new Promise((resolve, reject) => {
      const bytesLeft = this.blob.size - this.index;
      if (bytesLeft <= 0) {
        controller.close();
        return resolve();
      }
      const size = Math.min(this.chunkSize, bytesLeft);
      const slice = this.blob.slice(this.index, this.index + size);
      const reader = new FileReader();
      reader.onload = () => {
        controller.enqueue(new Uint8Array(reader.result));
        resolve();
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(slice);
      this.index += size;
    });
  }
}

function blobStream(blob, size) {
  return new ReadableStream(new BlobStreamController(blob, size));
}

class ConcatStreamController {
  constructor(streams) {
    this.streams = streams;
    this.index = 0;
    this.reader = null;
    this.nextReader();
  }

  nextReader() {
    const next = this.streams[this.index++];
    this.reader = next && next.getReader();
  }

  async pull(controller) {
    if (!this.reader) {
      return controller.close();
    }
    const data = await this.reader.read();
    if (data.done) {
      this.nextReader();
      return this.pull(controller);
    }
    controller.enqueue(data.value);
  }
}

function concatStream(streams) {
  return new ReadableStream(new ConcatStreamController(streams));
}


/***/ }),
/* 18 */
/***/ (function(module, exports) {

assert.notEqual = notEqual
assert.notOk = notOk
assert.equal = equal
assert.ok = assert

module.exports = assert

function equal (a, b, m) {
  assert(a == b, m) // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert(a != b, m) // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert(!t, m)
}

function assert (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ece_js__ = __webpack_require__(156);


const encoder = new TextEncoder();
const decoder = new TextDecoder();

class Keychain {
  constructor(secretKeyB64, nonce) {
    this._nonce = nonce || 'yRCdyQ1EMSA3mo4rqSkuNQ==';
    if (secretKeyB64) {
      this.rawSecret = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(secretKeyB64);
    } else {
      this.rawSecret = crypto.getRandomValues(new Uint8Array(16));
    }
    this.secretKeyPromise = crypto.subtle.importKey(
      'raw',
      this.rawSecret,
      'HKDF',
      false,
      ['deriveKey']
    );
    this.metaKeyPromise = this.secretKeyPromise.then(function(secretKey) {
      return crypto.subtle.deriveKey(
        {
          name: 'HKDF',
          salt: new Uint8Array(),
          info: encoder.encode('metadata'),
          hash: 'SHA-256'
        },
        secretKey,
        {
          name: 'AES-GCM',
          length: 128
        },
        false,
        ['encrypt', 'decrypt']
      );
    });
    this.authKeyPromise = this.secretKeyPromise.then(function(secretKey) {
      return crypto.subtle.deriveKey(
        {
          name: 'HKDF',
          salt: new Uint8Array(),
          info: encoder.encode('authentication'),
          hash: 'SHA-256'
        },
        secretKey,
        {
          name: 'HMAC',
          hash: { name: 'SHA-256' }
        },
        true,
        ['sign']
      );
    });
  }

  get nonce() {
    return this._nonce;
  }

  set nonce(n) {
    if (n && n !== this._nonce) {
      this._nonce = n;
    }
  }

  setPassword(password, shareUrl) {
    this.authKeyPromise = crypto.subtle
      .importKey('raw', encoder.encode(password), { name: 'PBKDF2' }, false, [
        'deriveKey'
      ])
      .then(passwordKey =>
        crypto.subtle.deriveKey(
          {
            name: 'PBKDF2',
            salt: encoder.encode(shareUrl),
            iterations: 100,
            hash: 'SHA-256'
          },
          passwordKey,
          {
            name: 'HMAC',
            hash: 'SHA-256'
          },
          true,
          ['sign']
        )
      );
  }

  setAuthKey(authKeyB64) {
    this.authKeyPromise = crypto.subtle.importKey(
      'raw',
      Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(authKeyB64),
      {
        name: 'HMAC',
        hash: 'SHA-256'
      },
      true,
      ['sign']
    );
  }

  async authKeyB64() {
    const authKey = await this.authKeyPromise;
    const rawAuth = await crypto.subtle.exportKey('raw', authKey);
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils__["arrayToB64"])(new Uint8Array(rawAuth));
  }

  async authHeader() {
    const authKey = await this.authKeyPromise;
    const sig = await crypto.subtle.sign(
      {
        name: 'HMAC'
      },
      authKey,
      Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(this.nonce)
    );
    return `send-v1 ${Object(__WEBPACK_IMPORTED_MODULE_0__utils__["arrayToB64"])(new Uint8Array(sig))}`;
  }

  async encryptMetadata(metadata) {
    const metaKey = await this.metaKeyPromise;
    const ciphertext = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: new Uint8Array(12),
        tagLength: 128
      },
      metaKey,
      encoder.encode(
        JSON.stringify({
          name: metadata.name,
          size: metadata.size,
          type: metadata.type || 'application/octet-stream',
          manifest: metadata.manifest || {},
          roomMeta:metadata.roomMeta || {}
        })
      )
    );
    return ciphertext;
  }

  encryptStream(plainStream) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__ece_js__["c" /* encryptStream */])(plainStream, this.rawSecret);
  }

  decryptStream(cryptotext) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__ece_js__["b" /* decryptStream */])(cryptotext, this.rawSecret);
  }

  async decryptMetadata(ciphertext) {
    const metaKey = await this.metaKeyPromise;
    const plaintext = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: new Uint8Array(12),
        tagLength: 128
      },
      metaKey,
      ciphertext
    );
    return JSON.parse(decoder.decode(plaintext));
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Keychain;



/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var af = moment.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Mre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            ss : '%d sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    return af;

})));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var ar = moment.defineLocale('ar', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : pluralize('s'),
            ss : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return ar;

})));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arDz = moment.defineLocale('ar-dz', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return arDz;

})));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arKw = moment.defineLocale('ar-kw', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arKw;

})));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '1',
        '2': '2',
        '3': '3',
        '4': '4',
        '5': '5',
        '6': '6',
        '7': '7',
        '8': '8',
        '9': '9',
        '0': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var arLy = moment.defineLocale('ar-ly', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : pluralize('s'),
            ss : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arLy;

})));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arMa = moment.defineLocale('ar-ma', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return arMa;

})));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var arSa = moment.defineLocale('ar-sa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return arSa;

})));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var arTn = moment.defineLocale('ar-tn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            ss : '%d ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return arTn;

})));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-nc',
        4: '-nc',
        100: '-nc',
        6: '-nc',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-nc',
        90: '-nc'
    };

    var az = moment.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gln hft] dddd [saat] LT',
            lastDay : '[dnn] LT',
            lastWeek : '[ken hft] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s vvl',
            s : 'birne saniy',
            ss : '%d saniy',
            m : 'bir dqiq',
            mm : '%d dqiq',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM : function (input) {
            return /^(gndz|axam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gec';
            } else if (hour < 12) {
                return 'shr';
            } else if (hour < 17) {
                return 'gndz';
            } else {
                return 'axam';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return az;

})));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? '__' : '__',
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            format: '______'.split('_'),
            standalone: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function () {
                return '[] dddd [] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithPlural,
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
                case 'D':
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return be;

})));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var bg = moment.defineLocale('bg', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[ ] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return bg;

})));


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var bm = moment.defineLocale('bm', {
        months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
        monthsShort : 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
        weekdays : 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
        weekdaysShort : 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
        weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'MMMM [tile] D [san] YYYY',
            LLL : 'MMMM [tile] D [san] YYYY [lr] HH:mm',
            LLLL : 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
        },
        calendar : {
            sameDay : '[Bi lr] LT',
            nextDay : '[Sini lr] LT',
            nextWeek : 'dddd [don lr] LT',
            lastDay : '[Kunu lr] LT',
            lastWeek : 'dddd [tmnen lr] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s kn',
            past : 'a b %s b',
            s : 'sanga dama dama',
            ss : 'sekondi %d',
            m : 'miniti kelen',
            mm : 'miniti %d',
            h : 'lr kelen',
            hh : 'lr %d',
            d : 'tile kelen',
            dd : 'tile %d',
            M : 'kalo kelen',
            MM : 'kalo %d',
            y : 'san kelen',
            yy : 'san %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return bm;

})));


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bn = moment.defineLocale('bn', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return bn;

})));


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bo = moment.defineLocale('bo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[], LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    (meridiem === '' && hour < 5) ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return bo;

})));


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 9:
                return number + ' bloaz';
            default:
                return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondenno',
            ss : '%d eilenn',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'a' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return br;

})));


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prolu] dddd [u] LT';
                    case 6:
                        return '[prole] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            ss     : translate,
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return bs;

})));


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ca = moment.defineLocale('ca', {
        months : {
            standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
            format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
            isFormat: /D[oD]?(\s)+MMMM/
        },
        monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [de] YYYY',
            ll : 'D MMM YYYY',
            LLL : 'D MMMM [de] YYYY [a les] H:mm',
            lll : 'D MMM YYYY, H:mm',
            LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',
            llll : 'ddd D MMM YYYY, H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'd\'aqu %s',
            past : 'fa %s',
            s : 'uns segons',
            ss : '%d segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : '';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ca;

})));


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
        monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');

    var monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i];
    // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
    // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
    var monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;

    function plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekund');
                } else {
                    return result + 'sekundami';
                }
                break;
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'den' : 'dnem';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dny' : 'dn');
                } else {
                    return result + 'dny';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'msce' : 'msc');
                } else {
                    return result + 'msci';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
                break;
        }
    }

    var cs = moment.defineLocale('cs', {
        months : months,
        monthsShort : monthsShort,
        monthsRegex : monthsRegex,
        monthsShortRegex : monthsRegex,
        // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
        // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
        monthsStrictRegex : /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
        monthsShortStrictRegex : /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm',
            l : 'D. M. YYYY'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[ztra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve stedu v] LT';
                    case 4:
                        return '[ve tvrtek v] LT';
                    case 5:
                        return '[v ptek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[vera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulou nedli v] LT';
                    case 1:
                    case 2:
                        return '[minul] dddd [v] LT';
                    case 3:
                        return '[minulou stedu v] LT';
                    case 4:
                    case 5:
                        return '[minul] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'ped %s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cs;

})));


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var cv = moment.defineLocale('cv', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [] MMMM [] D[-]',
            LLL : 'YYYY [] MMMM [] D[-], HH:mm',
            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
        },
        calendar : {
            sameDay: '[] LT []',
            nextDay: '[] LT []',
            lastDay: '[] LT []',
            nextWeek: '[] dddd LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                return output + affix;
            },
            past : '%s ',
            s : '- ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-/,
        ordinal : '%d-',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return cv;

})));


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact : true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn l',
            s: 'ychydig eiliadau',
            ss: '%d eiliad',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return cy;

})));


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var da = moment.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay : '[i dag kl.] LT',
            nextDay : '[i morgen kl.] LT',
            nextWeek : 'p dddd [kl.] LT',
            lastDay : '[i gr kl.] LT',
            lastWeek : '[i] dddd[s kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'f sekunder',
            ss : '%d sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en mned',
            MM : '%d mneder',
            y : 'et r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return da;

})));


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return de;

})));


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deAt = moment.defineLocale('de-at', {
        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deAt;

})));


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deCh = moment.defineLocale('de-ch', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            ss : '%d Sekunden',
            m : processRelativeTime,
            mm : '%d Minuten',
            h : processRelativeTime,
            hh : '%d Stunden',
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return deCh;

})));


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ], weekdays = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var dv = moment.defineLocale('dv', {
        months : months,
        monthsShort : months,
        weekdays : weekdays,
        weekdaysShort : weekdays,
        weekdaysMin : '______'.split('_'),
        longDateFormat : {

            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/M/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            ss : 'd% ',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 7,  // Sunday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return dv;

})));


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }


    var el = moment.defineLocale('el', {
        monthsNominativeEl : '___________'.split('_'),
        monthsGenitiveEl : '___________'.split('_'),
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '' : '';
            } else {
                return isLower ? '' : '';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === '');
        },
        meridiemParse : /[]\.??\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[ {}] LT',
            nextDay : '[ {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[ {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[ ] dddd [{}] LT';
                    default:
                        return '[ ] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    return el;

})));


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enSG = moment.defineLocale('en-SG', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enSG;

})));


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enAu = moment.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enAu;

})));


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enCa = moment.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY h:mm A',
            LLLL : 'dddd, MMMM D, YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return enCa;

})));


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enGb = moment.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enGb;

})));


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enIe = moment.defineLocale('en-ie', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enIe;

})));


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enIl = moment.defineLocale('en-il', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    return enIl;

})));


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var enNz = moment.defineLocale('en-nz', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            ss : '%d seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return enNz;

})));


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var eo = moment.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
        weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
        weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),
        weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-a de] MMMM, YYYY',
            LLL : 'D[-a de] MMMM, YYYY HH:mm',
            LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodia je] LT',
            nextDay : '[Morga je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hiera je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'post %s',
            past : 'anta %s',
            s : 'sekundoj',
            ss : '%d sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return eo;

})));


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var es = moment.defineLocale('es', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex : monthsRegex,
        monthsShortRegex : monthsRegex,
        monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return es;

})));


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esDo = moment.defineLocale('es-do', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY h:mm A',
            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return esDo;

})));


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

    var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
    var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esUs = moment.defineLocale('es-us', {
        months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'MM/DD/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY h:mm A',
            LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return esUs;

})));


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
            'ss': [number + 'sekundi', number + 'sekundit'],
            'm' : ['he minuti', 'ks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['he tunni', 'tund aega', 'ks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['he peva', 'ks pev'],
            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['he aasta', 'aasta', 'ks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'H:mm:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[Tna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Jrgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s prast',
            past   : '%s tagasi',
            s      : processRelativeTime,
            ss     : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : '%d peva',
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return et;

})));


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var eu = moment.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        monthsParseExact : true,
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] HH:mm',
            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            ss : '%d segundo',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return eu;

})));


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var fa = moment.defineLocale('fa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /  |  /,
        isPM: function (input) {
            return /  /.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '  ';
            } else {
                return '  ';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : 'dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : ' d%',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[-]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 12th is the first week of the year.
        }
    });

    return fa;

})));


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'ss':
                return isFuture ? 'sekunnin' : 'sekuntia';
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'pivn' : 'piv';
            case 'dd':
                result = isFuture ? 'pivn' : 'piv';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = moment.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tnn] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pst',
            past : '%s sitten',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fi;

})));


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var fo = moment.defineLocale('fo', {
        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gjr kl.] LT',
            lastWeek : '[sstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s sani',
            s : 'f sekund',
            ss : '%d sekundir',
            m : 'ein minuttur',
            mm : '%d minuttir',
            h : 'ein tmi',
            hh : '%d tmar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mnaur',
            MM : '%d mnair',
            y : 'eitt r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fo;

})));


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var fr = moment.defineLocale('fr', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourdhui ] LT',
            nextDay : '[Demain ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[Hier ] LT',
            lastWeek : 'dddd [dernier ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal : function (number, period) {
            switch (period) {
                // TODO: Return 'e' when day of month > 1. Move this case inside
                // block for masculine words below.
                // See https://github.com/moment/moment/issues/3375
                case 'D':
                    return number + (number === 1 ? 'er' : '');

                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fr;

})));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var frCa = moment.defineLocale('fr-ca', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourdhui ] LT',
            nextDay : '[Demain ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[Hier ] LT',
            lastWeek : 'dddd [dernier ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        }
    });

    return frCa;

})));


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var frCh = moment.defineLocale('fr-ch', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        monthsParseExact : true,
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Aujourdhui ] LT',
            nextDay : '[Demain ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[Hier ] LT',
            lastWeek : 'dddd [dernier ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            ss : '%d secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return frCh;

})));


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = moment.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[frne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            ss : '%d sekonden',
            m : 'ien mint',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return fy;

})));


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



    var months = [
        'Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Mitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deaireadh Fmhair', 'Samhain', 'Nollaig'
    ];

    var monthsShort = ['Ean', 'Feab', 'Mrt', 'Aibr', 'Beal', 'Mit', 'Iil', 'Lna', 'Men', 'Deai', 'Samh', 'Noll'];

    var weekdays = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Satharn'];

    var weekdaysShort = ['Dom', 'Lua', 'Mi', 'Ca', 'Da', 'hAo', 'Sat'];

    var weekdaysMin = ['Do', 'Lu', 'M', 'Ce', 'D', 'hA', 'Sa'];

    var ga = moment.defineLocale('ga', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Inniu ag] LT',
            nextDay: '[Amrach ag] LT',
            nextWeek: 'dddd [ag] LT',
            lastDay: '[Inn aig] LT',
            lastWeek: 'dddd [seo caite] [ag] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'i %s',
            past: '%s  shin',
            s: 'cpla soicind',
            ss: '%d soicind',
            m: 'nimad',
            mm: '%d nimad',
            h: 'uair an chloig',
            hh: '%d uair an chloig',
            d: 'l',
            dd: '%d l',
            M: 'm',
            MM: '%d m',
            y: 'bliain',
            yy: '%d bliain'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ga;

})));


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
    ];

    var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

    var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

    var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

    var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months : months,
        monthsShort : monthsShort,
        monthsParseExact : true,
        weekdays : weekdays,
        weekdaysShort : weekdaysShort,
        weekdaysMin : weekdaysMin,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[An-diugh aig] LT',
            nextDay : '[A-mireach aig] LT',
            nextWeek : 'dddd [aig] LT',
            lastDay : '[An-d aig] LT',
            lastWeek : 'dddd [seo chaidh] [aig] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ann an %s',
            past : 'bho chionn %s',
            s : 'beagan diogan',
            ss : '%d diogan',
            m : 'mionaid',
            mm : '%d mionaidean',
            h : 'uair',
            hh : '%d uairean',
            d : 'latha',
            dd : '%d latha',
            M : 'mos',
            MM : '%d mosan',
            y : 'bliadhna',
            yy : '%d bliadhna'
        },
        dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
        ordinal : function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gd;

})));


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var gl = moment.defineLocale('gl', {
        months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
        monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
        weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
        weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str.indexOf('un') === 0) {
                    return 'n' + str;
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            ss : '%d segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return gl;

})));


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['thodde secondanim', 'thodde second'],
            'ss': [number + ' secondanim', number + ' second'],
            'm': ['eka mintan', 'ek minute'],
            'mm': [number + ' mintanim', number + ' mintam'],
            'h': ['eka voran', 'ek vor'],
            'hh': [number + ' voranim', number + ' voram'],
            'd': ['eka disan', 'ek dis'],
            'dd': [number + ' disanim', number + ' dis'],
            'M': ['eka mhoinean', 'ek mhoino'],
            'MM': [number + ' mhoineanim', number + ' mhoine'],
            'y': ['eka vorsan', 'ek voros'],
            'yy': [number + ' vorsanim', number + ' vorsam']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var gomLatn = moment.defineLocale('gom-latn', {
        months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
        monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
        weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'A h:mm [vazta]',
            LTS : 'A h:mm:ss [vazta]',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY A h:mm [vazta]',
            LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
            llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
        },
        calendar : {
            sameDay: '[Aiz] LT',
            nextDay: '[Faleam] LT',
            nextWeek: '[Ieta to] dddd[,] LT',
            lastDay: '[Kal] LT',
            lastWeek: '[Fatlo] dddd[,] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s adim',
            s : processRelativeTime,
            ss : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse : /\d{1,2}(er)/,
        ordinal : function (number, period) {
            switch (period) {
                // the ordinal 'er' only applies to day of the month
                case 'D':
                    return number + 'er';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /rati|sokalli|donparam|sanje/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'rati') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'sokalli') {
                return hour;
            } else if (meridiem === 'donparam') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'sanje') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'rati';
            } else if (hour < 12) {
                return 'sokalli';
            } else if (hour < 16) {
                return 'donparam';
            } else if (hour < 20) {
                return 'sanje';
            } else {
                return 'rati';
            }
        }
    });

    return gomLatn;

})));


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
            '1': '',
            '2': '',
            '3': '',
            '4': '',
            '5': '',
            '6': '',
            '7': '',
            '8': '',
            '9': '',
            '0': ''
        },
        numberMap = {
            '': '1',
            '': '2',
            '': '3',
            '': '4',
            '': '5',
            '': '6',
            '': '7',
            '': '8',
            '': '9',
            '': '0'
        };

    var gu = moment.defineLocale('gu', {
        months: '___________'.split('_'),
        monthsShort: '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ',
            LTS: 'A h:mm:ss ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar: {
            sameDay: '[] LT',
            nextDay: '[] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            ss: '%d ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
        meridiemParse: /|||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6 // The week that contains Jan 6th is the first week of the year.
        }
    });

    return gu;

})));


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var he = moment.defineLocale('he', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D []MMMM YYYY',
            LLL : 'D []MMMM YYYY HH:mm',
            LLLL : 'dddd, D []MMMM YYYY HH:mm',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ]LT',
            nextDay : '[ ]LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ]LT',
            lastWeek : '[] dddd [ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            d : '',
            dd : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            M : '',
            MM : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            y : '',
            yy : function (number) {
                if (number === 2) {
                    return '';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' ';
                }
                return number + ' ';
            }
        },
        meridiemParse: /"|"| | | ||/i,
        isPM : function (input) {
            return /^("| |)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 5) {
                return ' ';
            } else if (hour < 10) {
                return '';
            } else if (hour < 12) {
                return isLower ? '"' : ' ';
            } else if (hour < 18) {
                return isLower ? '"' : ' ';
            } else {
                return '';
            }
        }
    });

    return he;

})));


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var hi = moment.defineLocale('hi', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return hi;

})));


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months : {
            format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
            standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
        },
        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prolu] dddd [u] LT';
                    case 6:
                        return '[prole] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            ss     : translate,
            m      : translate,
            mm     : translate,
            h      : translate,
            hh     : translate,
            d      : 'dan',
            dd     : translate,
            M      : 'mjesec',
            MM     : translate,
            y      : 'godinu',
            yy     : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return hr;

})));


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
            case 's':
                return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
            case 'ss':
                return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' v' : ' ve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = moment.defineLocale('hu', {
        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s mlva',
            past : '%s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return hu;

})));


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var hyAm = moment.defineLocale('hy-am', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[] LT',
            nextDay: '[] LT',
            lastDay: '[] LT',
            nextWeek: function () {
                return 'dddd [ ] LT';
            },
            lastWeek: function () {
                return '[] dddd [ ] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'DDD':
                case 'w':
                case 'W':
                case 'DDDo':
                    if (number === 1) {
                        return number + '-';
                    }
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return hyAm;

})));


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var id = moment.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            ss : '%d detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return id;

})));


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
            case 'ss':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
                }
                return result + 'seknda';
            case 'm':
                return withoutSuffix ? 'mnta' : 'mntu';
            case 'mm':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
                } else if (withoutSuffix) {
                    return result + 'mnta';
                }
                return result + 'mntu';
            case 'hh':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
                }
                return result + 'klukkustund';
            case 'd':
                if (withoutSuffix) {
                    return 'dagur';
                }
                return isFuture ? 'dag' : 'degi';
            case 'dd':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'dagar';
                    }
                    return result + (isFuture ? 'daga' : 'dgum');
                } else if (withoutSuffix) {
                    return result + 'dagur';
                }
                return result + (isFuture ? 'dag' : 'degi');
            case 'M':
                if (withoutSuffix) {
                    return 'mnuur';
                }
                return isFuture ? 'mnu' : 'mnui';
            case 'MM':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'mnuir';
                    }
                    return result + (isFuture ? 'mnui' : 'mnuum');
                } else if (withoutSuffix) {
                    return result + 'mnuur';
                }
                return result + (isFuture ? 'mnu' : 'mnui');
            case 'y':
                return withoutSuffix || isFuture ? 'r' : 'ri';
            case 'yy':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'r' : 'rum');
                }
                return result + (withoutSuffix || isFuture ? 'r' : 'ri');
        }
    }

    var is = moment.defineLocale('is', {
        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gr kl.] LT',
            lastWeek : '[sasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s san',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : 'klukkustund',
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return is;

})));


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var it = moment.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            ss : '%d secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return it;

})));


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var itCh = moment.defineLocale('it-ch', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
        weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            ss : '%d secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return itCh;

})));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ja = moment.defineLocale('ja', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMD HH:mm',
            LLLL : 'YYYYMD dddd HH:mm',
            l : 'YYYY/MM/DD',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMD(ddd) HH:mm'
        },
        meridiemParse: /|/i,
        isPM : function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : function (now) {
                if (now.week() < this.week()) {
                    return '[]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            lastDay : '[] LT',
            lastWeek : function (now) {
                if (this.week() < now.week()) {
                    return '[]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d',
            m : '1',
            mm : '%d',
            h : '1',
            hh : '%d',
            d : '1',
            dd : '%d',
            M : '1',
            MM : '%d',
            y : '1',
            yy : '%d'
        }
    });

    return ja;

})));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var jv = moment.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            ss : '%d detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return jv;

})));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ka = moment.defineLocale('ka', {
        months : {
            standalone: '___________'.split('_'),
            format: '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /(|)/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[] LT[-]',
            nextDay : '[] LT[-]',
            lastDay : '[] LT[-]',
            nextWeek : '[] dddd LT[-]',
            lastWeek : '[] dddd LT-',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(|||)/).test(s) ?
                    s.replace(/$/, '') :
                    s + '';
            },
            past : function (s) {
                if ((/(||||)/).test(s)) {
                    return s.replace(/(|)$/, ' ');
                }
                if ((//).test(s)) {
                    return s.replace(/$/, ' ');
                }
            },
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return '-' + number;
            }
            return number + '-';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    return ka;

})));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var kk = moment.defineLocale('kk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return kk;

})));


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var km = moment.defineLocale('km', {
        months: '___________'.split(
            '_'
        ),
        monthsShort: '___________'.split(
            '_'
        ),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            ss: '%d ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return km;

})));


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var kn = moment.defineLocale('kn', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}()/,
        ordinal : function (number) {
            return number + '';
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return kn;

})));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ko = moment.defineLocale('ko', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D A h:mm',
            LLLL : 'YYYY MMMM D dddd A h:mm',
            l : 'YYYY.MM.DD.',
            ll : 'YYYY MMMM D',
            lll : 'YYYY MMMM D A h:mm',
            llll : 'YYYY MMMM D dddd A h:mm'
        },
        calendar : {
            sameDay : ' LT',
            nextDay : ' LT',
            nextWeek : 'dddd LT',
            lastDay : ' LT',
            lastWeek : ' dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d',
            m : '1',
            mm : '%d',
            h : ' ',
            hh : '%d',
            d : '',
            dd : '%d',
            M : ' ',
            MM : '%d',
            y : ' ',
            yy : '%d'
        },
        dayOfMonthOrdinalParse : /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                case 'M':
                    return number + '';
                case 'w':
                case 'W':
                    return number + '';
                default:
                    return number;
            }
        },
        meridiemParse : /|/,
        isPM : function (token) {
            return token === '';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '' : '';
        }
    });

    return ko;

})));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    },
    months = [
        ' ',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ' ',
        ' ',
        ' '
    ];


    var ku = moment.defineLocale('ku', {
        months : months,
        monthsShort : months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return //.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : 'dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : ' ',
            ss : ' %d',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 12th is the first week of the year.
        }
    });

    return ku;

})));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var ky = moment.defineLocale('ky', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : '[ ] dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
        ordinal : function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ky;

})));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        monthsParseExact : true,
        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            ss : '%d Sekonnen',
            m : processRelativeTime,
            mm : '%d Minutten',
            h : processRelativeTime,
            hh : '%d Stonnen',
            d : processRelativeTime,
            dd : '%d Deeg',
            M : processRelativeTime,
            MM : '%d Mint',
            y : processRelativeTime,
            yy : '%d Joer'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lb;

})));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var lo = moment.defineLocale('lo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd[] LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd[] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            ss : '%d ' ,
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /()\d{1,2}/,
        ordinal : function (number) {
            return '' + number;
        }
    });

    return lo;

})));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var units = {
        'ss' : 'sekund_sekundi_sekundes',
        'm' : 'minut_minuts_minut',
        'mm': 'minuts_minui_minutes',
        'h' : 'valanda_valandos_valand',
        'hh': 'valandos_valand_valandas',
        'd' : 'diena_dienos_dien',
        'dd': 'dienos_dien_dienas',
        'M' : 'mnuo_mnesio_mnes',
        'MM': 'mnesiai_mnesi_mnesius',
        'y' : 'metai_met_metus',
        'yy': 'metai_met_metus'
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekunds';
        } else {
            return isFuture ? 'keli sekundi' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months : {
            format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
            standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
        },
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : {
            format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
            standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
            isFormat: /dddd HH:mm/
        },
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar : {
            sameDay : '[iandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Prajus] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prie %s',
            s : translateSeconds,
            ss : translate,
            m : translateSingular,
            mm : translate,
            h : translateSingular,
            hh : translate,
            d : translateSingular,
            dd : translate,
            M : translateSingular,
            MM : translate,
            y : translateSingular,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lt;

})));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var units = {
        'ss': 'sekundes_sekundm_sekunde_sekundes'.split('_'),
        'm': 'mintes_mintm_minte_mintes'.split('_'),
        'mm': 'mintes_mintm_minte_mintes'.split('_'),
        'h': 'stundas_stundm_stunda_stundas'.split('_'),
        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
        'd': 'dienas_dienm_diena_dienas'.split('_'),
        'dd': 'dienas_dienm_diena_dienas'.split('_'),
        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minte", "3 mintes".
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 mintes" as in "pc 21 mintes".
            // E.g. "3 mintm" as in "pc 3 mintm".
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
    }

    var lv = moment.defineLocale('lv', {
        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar : {
            sameDay : '[odien pulksten] LT',
            nextDay : '[Rt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagju] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            ss : relativeTimeWithPlural,
            m : relativeTimeWithSingular,
            mm : relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : relativeTimeWithPlural
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return lv;

})));


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['sekund', 'sekunda', 'sekundi'],
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact : true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedjelje] [u] LT',
                    '[prolog] [ponedjeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srijede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mjesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return me;

})));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var mi = moment.defineLocale('mi', {
        months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
        weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
        weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [i] HH:mm',
            LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
        },
        calendar: {
            sameDay: '[i teie mahana, i] LT',
            nextDay: '[apopo i] LT',
            nextWeek: 'dddd [i] LT',
            lastDay: '[inanahi i] LT',
            lastWeek: 'dddd [whakamutunga i] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'i roto i %s',
            past: '%s i mua',
            s: 'te hkona ruarua',
            ss: '%d hkona',
            m: 'he meneti',
            mm: '%d meneti',
            h: 'te haora',
            hh: '%d haora',
            d: 'he ra',
            dd: '%d ra',
            M: 'he marama',
            MM: '%d marama',
            y: 'he tau',
            yy: '%d tau'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return mi;

})));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var mk = moment.defineLocale('mk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : 'e_o_____a'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : '[] dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return mk;

})));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ml = moment.defineLocale('ml', {
        months : '___________'.split('_'),
        monthsShort : '._._._.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -',
            LTS : 'A h:mm:ss -',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm -',
            LLLL : 'dddd, D MMMM YYYY, A h:mm -'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        meridiemParse: /|| ||/i,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if ((meridiem === '' && hour >= 4) ||
                    meridiem === ' ' ||
                    meridiem === '') {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return ' ';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        }
    });

    return ml;

})));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function translate(number, withoutSuffix, key, isFuture) {
        switch (key) {
            case 's':
                return withoutSuffix ? ' ' : ' ';
            case 'ss':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'm':
            case 'mm':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'h':
            case 'hh':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'd':
            case 'dd':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'M':
            case 'MM':
                return number + (withoutSuffix ? ' ' : ' ');
            case 'y':
            case 'yy':
                return number + (withoutSuffix ? ' ' : ' ');
            default:
                return number;
        }
    }

    var mn = moment.defineLocale('mn', {
        months : ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
        monthsShort : '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY  MMMM D',
            LLL : 'YYYY  MMMM D HH:mm',
            LLLL : 'dddd, YYYY  MMMM D HH:mm'
        },
        meridiemParse: /|/i,
        isPM : function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + ' ';
                default:
                    return number;
            }
        }
    });

    return mn;

})));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    function relativeTimeMr(number, withoutSuffix, string, isFuture)
    {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's': output = ' '; break;
                case 'ss': output = '%d '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        else {
            switch (string) {
                case 's': output = ' '; break;
                case 'ss': output = '%d '; break;
                case 'm': output = ' '; break;
                case 'mm': output = '%d '; break;
                case 'h': output = ' '; break;
                case 'hh': output = '%d '; break;
                case 'd': output = ' '; break;
                case 'dd': output = '%d '; break;
                case 'M': output = ' '; break;
                case 'MM': output = '%d '; break;
                case 'y': output = ' '; break;
                case 'yy': output = '%d '; break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months : '___________'.split('_'),
        monthsShort: '._._._._._._._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future: '%s',
            past: '%s',
            s: relativeTimeMr,
            ss: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return mr;

})));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ms = moment.defineLocale('ms', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            ss : '%d saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ms;

})));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var msMy = moment.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            ss : '%d saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return msMy;

})));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var mt = moment.defineLocale('mt', {
        months : 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
        monthsShort : 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
        weekdays : 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
        weekdaysShort : 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
        weekdaysMin : 'a_Tn_Tl_Er_a_i_Si'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Illum fil-]LT',
            nextDay : '[Gada fil-]LT',
            nextWeek : 'dddd [fil-]LT',
            lastDay : '[Il-biera fil-]LT',
            lastWeek : 'dddd [li gadda] [fil-]LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'f %s',
            past : '%s ilu',
            s : 'ftit sekondi',
            ss : '%d sekondi',
            m : 'minuta',
            mm : '%d minuti',
            h : 'siega',
            hh : '%d siegat',
            d : 'urnata',
            dd : '%d ranet',
            M : 'xahar',
            MM : '%d xhur',
            y : 'sena',
            yy : '%d sni'
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return mt;

})));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var my = moment.defineLocale('my', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[.] LT []',
            nextDay: '[] LT []',
            nextWeek: 'dddd LT []',
            lastDay: '[.] LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s ',
            past: ' %s ',
            s: '.',
            ss : '%d ',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return my;

})));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var nb = moment.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
        monthsParseExact : true,
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i gr kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'noen sekunder',
            ss : '%d sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en mned',
            MM : '%d mneder',
            y : 'ett r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nb;

})));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ne = moment.defineLocale('ne', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '._._._._._._.'.split('_'),
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 16) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd[,] LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return ne;

})));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nl = moment.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            ss : '%d seconden',
            m : 'n minuut',
            mm : '%d minuten',
            h : 'n uur',
            hh : '%d uur',
            d : 'n dag',
            dd : '%d dagen',
            M : 'n maand',
            MM : '%d maanden',
            y : 'n jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;

})));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
    var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nlBe = moment.defineLocale('nl-be', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            ss : '%d seconden',
            m : 'n minuut',
            mm : '%d minuten',
            h : 'n uur',
            hh : '%d uur',
            d : 'n dag',
            dd : '%d dagen',
            M : 'n maand',
            MM : '%d maanden',
            y : 'n jaar',
            yy : '%d jaar'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nlBe;

})));


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var nn = moment.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I gr klokka] LT',
            lastWeek: '[Fregande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s sidan',
            s : 'nokre sekund',
            ss : '%d sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein mnad',
            MM : '%d mnader',
            y : 'eit r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nn;

})));


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var paIn = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return paIn;

})));


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
    function plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                return result + (plural(number) ? 'sekundy' : 'sekund');
            case 'm':
                return withoutSuffix ? 'minuta' : 'minut';
            case 'mm':
                return result + (plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix  ? 'godzina'  : 'godzin';
            case 'hh':
                return result + (plural(number) ? 'godziny' : 'godzin');
            case 'MM':
                return result + (plural(number) ? 'miesice' : 'miesicy');
            case 'yy':
                return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
        weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
        weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dzi o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W niedziel o] LT';

                    case 2:
                        return '[We wtorek o] LT';

                    case 3:
                        return '[W rod o] LT';

                    case 6:
                        return '[W sobot o] LT';

                    default:
                        return '[W] dddd [o] LT';
                }
            },
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W zesz niedziel o] LT';
                    case 3:
                        return '[W zesz rod o] LT';
                    case 6:
                        return '[W zesz sobot o] LT';
                    default:
                        return '[W zeszy] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : '1 dzie',
            dd : '%d dni',
            M : 'miesic',
            MM : translate,
            y : 'rok',
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pl;

})));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var pt = moment.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h %s',
            s : 'segundos',
            ss : '%d segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return pt;

})));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ptBr = moment.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h %s',
            s : 'poucos segundos',
            ss : '%d segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d'
    });

    return ptBr;

})));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'ss': 'secunde',
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s n urm',
            s : 'cteva secunde',
            ss : relativeTimeWithPlural,
            m : 'un minut',
            mm : relativeTimeWithPlural,
            h : 'o or',
            hh : relativeTimeWithPlural,
            d : 'o zi',
            dd : relativeTimeWithPlural,
            M : 'o lun',
            MM : relativeTimeWithPlural,
            y : 'un an',
            yy : relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return ro;

})));


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? '__' : '__',
            'mm': withoutSuffix ? '__' : '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

    // http://new.gramota.ru/spravka/rules/139-prop :  103
    //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months : {
            format: '___________'.split('_'),
            standalone: '___________'.split('_')
        },
        monthsShort : {
            //  CLDR  "."  ".",        ?
            format: '._._._.____._._._._.'.split('_'),
            standalone: '._.__.____._._._._.'.split('_')
        },
        weekdays : {
            standalone: '______'.split('_'),
            format: '______'.split('_'),
            isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
        },
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        monthsParse : monthsParse,
        longMonthsParse : monthsParse,
        shortMonthsParse : monthsParse,

        //    ,   ,  ,  4 ,      
        monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

        //  
        monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

        //    
        monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

        // ,     
        monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., H:mm',
            LLLL : 'dddd, D MMMM YYYY ., H:mm'
        },
        calendar : {
            sameDay: '[, ] LT',
            nextDay: '[, ] LT',
            lastDay: '[, ] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[ ] dddd, [] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[ ] dddd, [] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[ ] dddd, [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd, [] LT';
                    } else {
                        return '[] dddd, [] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[ ] dddd, [] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[ ] dddd, [] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[ ] dddd, [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd, [] LT';
                    } else {
                        return '[] dddd, [] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : relativeTimeWithPlural,
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        meridiemParse: /|||/i,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                    return number + '-';
                case 'D':
                    return number + '-';
                case 'w':
                case 'W':
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ru;

})));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];
    var days = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var sd = moment.defineLocale('sd', {
        months : months,
        monthsShort : months,
        weekdays : days,
        weekdaysShort : days,
        weekdaysMin : days,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            }
            return '';
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd [  ] LT',
            lastDay : '[] LT',
            lastWeek : '[ ] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sd;

})));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var se = moment.defineLocale('se', {
        months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
        monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
        weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
        weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
        weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'MMMM D. [b.] YYYY',
            LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
        },
        calendar : {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s geaes',
            past : 'mait %s',
            s : 'moadde sekunddat',
            ss: '%d sekunddat',
            m : 'okta minuhta',
            mm : '%d minuhtat',
            h : 'okta diimmu',
            hh : '%d diimmut',
            d : 'okta beaivi',
            dd : '%d beaivvit',
            M : 'okta mnnu',
            MM : '%d mnut',
            y : 'okta jahki',
            yy : '%d jagit'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return se;

})));


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    /*jshint -W100*/
    var si = moment.defineLocale('si', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, a h:mm',
            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
        },
        calendar : {
            sameDay : '[] LT[]',
            nextDay : '[] LT[]',
            nextWeek : 'dddd LT[]',
            lastDay : '[] LT[]',
            lastWeek : '[] dddd LT[]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            ss : ' %d',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2} /,
        ordinal : function (number) {
            return number + ' ';
        },
        meridiemParse : / | |.|../,
        isPM : function (input) {
            return input === '..' || input === ' ';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '..' : ' ';
            } else {
                return isLower ? '..' : ' ';
            }
        }
    });

    return si;

})));


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
        monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return (n > 1) && (n < 5);
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':  // a few seconds / in a few seconds / a few seconds ago
                return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'seknd');
                } else {
                    return result + 'sekundami';
                }
                break;
            case 'm':  // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minty' : 'mint');
                } else {
                    return result + 'mintami';
                }
                break;
            case 'h':  // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodn');
                } else {
                    return result + 'hodinami';
                }
                break;
            case 'd':  // a day / in a day / a day ago
                return (withoutSuffix || isFuture) ? 'de' : 'dom';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dni' : 'dn');
                } else {
                    return result + 'dami';
                }
                break;
            case 'M':  // a month / in a month / a month ago
                return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
                } else {
                    return result + 'mesiacmi';
                }
                break;
            case 'y':  // a year / in a year / a year ago
                return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'rokov');
                } else {
                    return result + 'rokmi';
                }
                break;
        }
    }

    var sk = moment.defineLocale('sk', {
        months : months,
        monthsShort : monthsShort,
        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedeu o] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [o] LT';
                    case 3:
                        return '[v stredu o] LT';
                    case 4:
                        return '[vo tvrtok o] LT';
                    case 5:
                        return '[v piatok o] LT';
                    case 6:
                        return '[v sobotu o] LT';
                }
            },
            lastDay: '[vera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minul nedeu o] LT';
                    case 1:
                    case 2:
                        return '[minul] dddd [o] LT';
                    case 3:
                        return '[minul stredu o] LT';
                    case 4:
                    case 5:
                        return '[minul] dddd [o] LT';
                    case 6:
                        return '[minul sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : translate,
            ss : translate,
            m : translate,
            mm : translate,
            h : translate,
            hh : translate,
            d : translate,
            dd : translate,
            M : translate,
            MM : translate,
            y : translate,
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sk;

})));


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
            case 'ss':
                if (number === 1) {
                    result += withoutSuffix ? 'sekundo' : 'sekundi';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
                } else {
                    result += 'sekund';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'ena minuta' : 'eno minuto';
            case 'mm':
                if (number === 1) {
                    result += withoutSuffix ? 'minuta' : 'minuto';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                } else {
                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'ena ura' : 'eno uro';
            case 'hh':
                if (number === 1) {
                    result += withoutSuffix ? 'ura' : 'uro';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
                } else {
                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
                }
                return result;
            case 'd':
                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
            case 'dd':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                } else {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                }
                return result;
            case 'M':
                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
            case 'MM':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                } else {
                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                }
                return result;
            case 'y':
                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
            case 'yy':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
                } else {
                    result += withoutSuffix || isFuture ? 'let' : 'leti';
                }
                return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[v] [nedeljo] [ob] LT';
                    case 3:
                        return '[v] [sredo] [ob] LT';
                    case 6:
                        return '[v] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[veraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 0:
                        return '[prejnjo] [nedeljo] [ob] LT';
                    case 3:
                        return '[prejnjo] [sredo] [ob] LT';
                    case 6:
                        return '[prejnjo] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prejnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ez %s',
            past   : 'pred %s',
            s      : processRelativeTime,
            ss     : processRelativeTime,
            m      : processRelativeTime,
            mm     : processRelativeTime,
            h      : processRelativeTime,
            hh     : processRelativeTime,
            d      : processRelativeTime,
            dd     : processRelativeTime,
            M      : processRelativeTime,
            MM     : processRelativeTime,
            y      : processRelativeTime,
            yy     : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sl;

})));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var sq = moment.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Sot n] LT',
            nextDay : '[Nesr n] LT',
            nextWeek : 'dddd [n] LT',
            lastDay : '[Dje n] LT',
            lastWeek : 'dddd [e kaluar n] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'n %s',
            past : '%s m par',
            s : 'disa sekonda',
            ss : '%d sekonda',
            m : 'nj minut',
            mm : '%d minuta',
            h : 'nj or',
            hh : '%d or',
            d : 'nj dit',
            dd : '%d dit',
            M : 'nj muaj',
            MM : '%d muaj',
            y : 'nj vit',
            yy : '%d vite'
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sq;

})));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['sekunda', 'sekunde', 'sekundi'],
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
        weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedelju] [u] LT';
                    case 3:
                        return '[u] [sredu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedelje] [u] LT',
                    '[prolog] [ponedeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : 'dan',
            dd     : translator.translate,
            M      : 'mesec',
            MM     : translator.translate,
            y      : 'godinu',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sr;

})));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var translator = {
        words: { //Different grammatical cases
            ss: ['', '', ''],
            m: [' ', ' '],
            mm: ['', '', ''],
            h: [' ', ' '],
            hh: ['', '', ''],
            dd: ['', '', ''],
            MM: ['', '', ''],
            yy: ['', '', '']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var srCyrl = moment.defineLocale('sr-cyrl', {
        months: '___________'.split('_'),
        monthsShort: '._._._.____._._._._.'.split('_'),
        monthsParseExact: true,
        weekdays: '______'.split('_'),
        weekdaysShort: '._._._._._._.'.split('_'),
        weekdaysMin: '______'.split('_'),
        weekdaysParseExact : true,
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[] [] [] LT';
                    case 3:
                        return '[] [] [] LT';
                    case 6:
                        return '[] [] [] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[] dddd [] LT';
                }
            },
            lastDay  : '[ ] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past   : ' %s',
            s      : ' ',
            ss     : translator.translate,
            m      : translator.translate,
            mm     : translator.translate,
            h      : translator.translate,
            hh     : translator.translate,
            d      : '',
            dd     : translator.translate,
            M      : '',
            MM     : translator.translate,
            y      : '',
            yy     : translator.translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return srCyrl;

})));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ss = moment.defineLocale('ss', {
        months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
        monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
        weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Namuhla nga] LT',
            nextDay : '[Kusasa nga] LT',
            nextWeek : 'dddd [nga] LT',
            lastDay : '[Itolo nga] LT',
            lastWeek : 'dddd [leliphelile] [nga] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'nga %s',
            past : 'wenteka nga %s',
            s : 'emizuzwana lomcane',
            ss : '%d mzuzwana',
            m : 'umzuzu',
            mm : '%d emizuzu',
            h : 'lihora',
            hh : '%d emahora',
            d : 'lilanga',
            dd : '%d emalanga',
            M : 'inyanga',
            MM : '%d tinyanga',
            y : 'umnyaka',
            yy : '%d iminyaka'
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ss;

})));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var sv = moment.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [kl.] HH:mm',
            LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igr] LT',
            nextWeek: '[P] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'fr %s sedan',
            s : 'ngra sekunder',
            ss : '%d sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en mnad',
            MM : '%d mnader',
            y : 'ett r',
            yy : '%d r'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return sv;

})));


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var sw = moment.defineLocale('sw', {
        months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
        weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[leo saa] LT',
            nextDay : '[kesho saa] LT',
            nextWeek : '[wiki ijayo] dddd [saat] LT',
            lastDay : '[jana] LT',
            lastWeek : '[wiki iliyopita] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s baadaye',
            past : 'tokea %s',
            s : 'hivi punde',
            ss : 'sekunde %d',
            m : 'dakika moja',
            mm : 'dakika %d',
            h : 'saa limoja',
            hh : 'masaa %d',
            d : 'siku moja',
            dd : 'masiku %d',
            M : 'mwezi mmoja',
            MM : 'miezi %d',
            y : 'mwaka mmoja',
            yy : 'miaka %d'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return sw;

})));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ta = moment.defineLocale('ta', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, HH:mm',
            LLLL : 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[ ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : '  ',
            hh : '%d  ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number + '';
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /|||||/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' ';
            } else if (hour < 6) {
                return ' ';  // 
            } else if (hour < 10) {
                return ' '; // 
            } else if (hour < 14) {
                return ' '; // 
            } else if (hour < 18) {
                return ' '; // 
            } else if (hour < 22) {
                return ' '; // 
            } else {
                return ' ';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return ta;

})));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var te = moment.defineLocale('te', {
        months : '___________'.split('_'),
        monthsShort : '._.__.____._._._._.'.split('_'),
        monthsParseExact : true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        dayOfMonthOrdinalParse : /\d{1,2}/,
        ordinal : '%d',
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 6th is the first week of the year.
        }
    });

    return te;

})));


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tet = moment.defineLocale('tet', {
        months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
        weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
        weekdaysMin : 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Ohin iha] LT',
            nextDay: '[Aban iha] LT',
            nextWeek: 'dddd [iha] LT',
            lastDay: '[Horiseik iha] LT',
            lastWeek: 'dddd [semana kotuk] [iha] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'iha %s',
            past : '%s liuba',
            s : 'minutu balun',
            ss : 'minutu %d',
            m : 'minutu ida',
            mm : 'minutu %d',
            h : 'oras ida',
            hh : 'oras %d',
            d : 'loron ida',
            dd : 'loron %d',
            M : 'fulan ida',
            MM : 'fulan %d',
            y : 'tinan ida',
            yy : 'tinan %d'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tet;

})));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var suffixes = {
        0: '-',
        1: '-',
        2: '-',
        3: '-',
        4: '-',
        5: '-',
        6: '-',
        7: '-',
        8: '-',
        9: '-',
        10: '-',
        12: '-',
        13: '-',
        20: '-',
        30: '-',
        40: '-',
        50: '-',
        60: '-',
        70: '-',
        80: '-',
        90: '-',
        100: '-'
    };

    var tg = moment.defineLocale('tg', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            lastDay : '[ ] LT',
            nextWeek : 'dddd[] [  ] LT',
            lastWeek : 'dddd[] [  ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        meridiemParse: /|||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 11) {
                return '';
            } else if (hour < 16) {
                return '';
            } else if (hour < 19) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1th is the first week of the year.
        }
    });

    return tg;

})));


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var th = moment.defineLocale('th', {
        months : '___________'.split('_'),
        monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
        monthsParseExact: true,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'), // yes, three characters difference
        weekdaysMin : '._._._._._._.'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY  H:mm',
            LLLL : 'dddd D MMMM YYYY  H:mm'
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd[ ] LT',
            lastDay : '[ ] LT',
            lastWeek : '[]dddd[ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return th;

})));


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tlPh = moment.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY HH:mm',
            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar : {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            ss : '%d segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlPh;

})));


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'leS' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'waQ' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'nem' :
        time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time = (output.indexOf('jaj') !== -1) ?
        time.slice(0, -3) + 'Hu' :
        (output.indexOf('jar') !== -1) ?
        time.slice(0, -3) + 'wen' :
        (output.indexOf('DIS') !== -1) ?
        time.slice(0, -3) + 'ben' :
        time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'ss':
                return numberNoun + ' lup';
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
        ten = Math.floor((number % 100) / 10),
        one = number % 10,
        word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += ((word !== '') ? ' ' : '') + numbersNouns[one];
        }
        return (word === '') ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
        monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
        monthsParseExact : true,
        weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[DaHjaj] LT',
            nextDay: '[waleS] LT',
            nextWeek: 'LLL',
            lastDay: '[waHu] LT',
            lastWeek: 'LLL',
            sameElse: 'L'
        },
        relativeTime : {
            future : translateFuture,
            past : translatePast,
            s : 'puS lup',
            ss : translate,
            m : 'wa tup',
            mm : translate,
            h : 'wa rep',
            hh : translate,
            d : 'wa jaj',
            dd : translate,
            M : 'wa jar',
            MM : translate,
            y : 'wa DIS',
            yy : translate
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return tlh;

})));


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {


;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'nc',
        4: '\'nc',
        100: '\'nc',
        6: '\'nc',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'nc',
        90: '\'nc'
    };

    var tr = moment.defineLocale('tr', {
        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[yarn saat] LT',
            nextWeek : '[gelecek] dddd [saat] LT',
            lastDay : '[dn] LT',
            lastWeek : '[geen] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s nce',
            s : 'birka saniye',
            ss : '%d saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yl',
            yy : '%d yl'
        },
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'Do':
                case 'DD':
                    return number;
                default:
                    if (number === 0) {  // special case for zero
                        return number + '\'nc';
                    }
                    var a = number % 10,
                        b = number % 100 - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return tr;

})));


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment.defineLocale('tzl', {
        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM [dallas] YYYY',
            LLL : 'D. MMMM [dallas] YYYY HH.mm',
            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM : function (input) {
            return 'd\'o' === input.toLowerCase();
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar : {
            sameDay : '[oxhi ] LT',
            nextDay : '[dem ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ieiri ] LT',
            lastWeek : '[sr el] dddd [lasteu ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'osprei %s',
            past : 'ja%s',
            s : processRelativeTime,
            ss : processRelativeTime,
            m : processRelativeTime,
            mm : processRelativeTime,
            h : processRelativeTime,
            hh : processRelativeTime,
            d : processRelativeTime,
            dd : processRelativeTime,
            M : processRelativeTime,
            MM : processRelativeTime,
            y : processRelativeTime,
            yy : processRelativeTime
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'ss': [number + ' secunds', '' + number + ' secunds'],
            'm': ['\'n mut', '\'iens mut'],
            'mm': [number + ' muts', '' + number + ' muts'],
            'h': ['\'n ora', '\'iensa ora'],
            'hh': [number + ' oras', '' + number + ' oras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', '' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', '' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', '' + number + ' ars']
        };
        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
    }

    return tzl;

})));


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tzm = moment.defineLocale('tzm', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '   %s',
            past : ' %s',
            s : '',
            ss : '%d ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d o',
            M : 'o',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return tzm;

})));


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var tzmLatn = moment.defineLocale('tzm-latn', {
        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            ss : '%d imik',
            m : 'minu',
            mm : '%d minu',
            h : 'saa',
            hh : '%d tassain',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 12th is the first week of the year.
        }
    });

    return tzmLatn;

})));


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js language configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var ugCn = moment.defineLocale('ug-cn', {
        months: '___________'.split(
            '_'
        ),
        monthsShort: '___________'.split(
            '_'
        ),
        weekdays: '______'.split(
            '_'
        ),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY-M-D-',
            LLL: 'YYYY-M-D- HH:mm',
            LLLL: 'dddd YYYY-M-D- HH:mm'
        },
        meridiemParse: / || || |/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                meridiem === ' ' ||
                meridiem === '' ||
                meridiem === ' '
            ) {
                return hour;
            } else if (meridiem === ' ' || meridiem === '') {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return ' ';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return ' ';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return ' ';
            } else {
                return '';
            }
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: '[] dddd [] LT',
            lastDay: '[] LT',
            lastWeek: '[] dddd [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s ',
            past: '%s ',
            s: ' ',
            ss: '%d ',
            m: ' ',
            mm: '%d ',
            h: ' ',
            hh: '%d ',
            d: ' ',
            dd: '%d ',
            M: ' ',
            MM: '%d ',
            y: ' ',
            yy: '%d '
        },

        dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '-';
                case 'w':
                case 'W':
                    return number + '-';
                default:
                    return number;
            }
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week: {
            // GB/T 7408-1994ISO 8601:1988
            dow: 1, // Monday is the first day of the week.
            doy: 7 // The week that contains Jan 1st is the first week of the year.
        }
    });

    return ugCn;

})));


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'ss': withoutSuffix ? '__' : '__',
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_'),
            'genitive': '______'.split('_')
        };

        if (m === true) {
            return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
        }
        if (!m) {
            return weekdays['nominative'];
        }

        var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months : {
            'format': '___________'.split('_'),
            'standalone': '___________'.split('_')
        },
        monthsShort : '___________'.split('_'),
        weekdays : weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: processHoursFunction('[ '),
            nextDay: processHoursFunction('[ '),
            lastDay: processHoursFunction('[ '),
            nextWeek: processHoursFunction('[] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return processHoursFunction('[] dddd [').call(this);
                    case 1:
                    case 2:
                    case 4:
                        return processHoursFunction('[] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            ss : relativeTimeWithPlural,
            m : relativeTimeWithPlural,
            mm : relativeTimeWithPlural,
            h : '',
            hh : relativeTimeWithPlural,
            d : '',
            dd : relativeTimeWithPlural,
            M : '',
            MM : relativeTimeWithPlural,
            y : '',
            yy : relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return number + '-';
                case 'D':
                    return number + '-';
                default:
                    return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return uk;

})));


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var months = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];
    var days = [
        '',
        '',
        '',
        '',
        '',
        '',
        ''
    ];

    var ur = moment.defineLocale('ur', {
        months : months,
        monthsShort : months,
        weekdays : days,
        weekdaysShort : days,
        weekdaysMin : days,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            }
            return '';
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[  ] LT',
            lastWeek : '[] dddd [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return ur;

})));


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var uz = moment.defineLocale('uz', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT []',
            nextDay : '[] LT []',
            nextWeek : 'dddd [ ] LT []',
            lastDay : '[ ] LT []',
            lastWeek : '[] dddd [ ] LT []',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s ',
            past : '  %s ',
            s : '',
            ss : '%d ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return uz;

})));


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var uzLatn = moment.defineLocale('uz-latn', {
        months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
        monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
        weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[Bugun soat] LT [da]',
            nextDay : '[Ertaga] LT [da]',
            nextWeek : 'dddd [kuni soat] LT [da]',
            lastDay : '[Kecha soat] LT [da]',
            lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'Yaqin %s ichida',
            past : 'Bir necha %s oldin',
            s : 'soniya',
            ss : '%d soniya',
            m : 'bir daqiqa',
            mm : '%d daqiqa',
            h : 'bir soat',
            hh : '%d soat',
            d : 'bir kun',
            dd : '%d kun',
            M : 'bir oy',
            MM : '%d oy',
            y : 'bir yil',
            yy : '%d yil'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 7th is the first week of the year.
        }
    });

    return uzLatn;

})));


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var vi = moment.defineLocale('vi', {
        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        monthsParseExact : true,
        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact : true,
        meridiemParse: /sa|ch/i,
        isPM : function (input) {
            return /^ch$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [nm] YYYY',
            LLL : 'D MMMM [nm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hm nay lc] LT',
            nextDay: '[Ngy mai lc] LT',
            nextWeek: 'dddd [tun ti lc] LT',
            lastDay: '[Hm qua lc] LT',
            lastWeek: 'dddd [tun ri lc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ti',
            past : '%s trc',
            s : 'vi giy',
            ss : '%d giy' ,
            m : 'mt pht',
            mm : '%d pht',
            h : 'mt gi',
            hh : '%d gi',
            d : 'mt ngy',
            dd : '%d ngy',
            M : 'mt thng',
            MM : '%d thng',
            y : 'mt nm',
            yy : '%d nm'
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return vi;

})));


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var xPseudo = moment.defineLocale('x-pseudo', {
        months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
        monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
        monthsParseExact : true,
        weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
        weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
        weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[T~d~ t] LT',
            nextDay : '[T~m~rr~w t] LT',
            nextWeek : 'dddd [t] LT',
            lastDay : '[~st~rd~ t] LT',
            lastWeek : '[L~st] dddd [t] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '~ %s',
            past : '%s ~g',
            s : ' ~fw ~sc~ds',
            ss : '%d s~c~ds',
            m : ' ~m~t',
            mm : '%d m~~ts',
            h : '~ h~r',
            hh : '%d h~rs',
            d : ' ~d',
            dd : '%d d~s',
            M : ' ~m~th',
            MM : '%d m~t~hs',
            y : ' ~r',
            yy : '%d ~rs'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return xPseudo;

})));


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var yo = moment.defineLocale('yo', {
        months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
        monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
        weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
        weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
        weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Oni ni] LT',
            nextDay : '[la ni] LT',
            nextWeek : 'dddd [s ton\'b] [ni] LT',
            lastDay : '[Ana ni] LT',
            lastWeek : 'dddd [s tol] [ni] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ni %s',
            past : '%s kja',
            s : 'isju aaya die',
            ss :'aaya %d',
            m : 'isju kan',
            mm : 'isju %d',
            h : 'wakati kan',
            hh : 'wakati %d',
            d : 'j kan',
            dd : 'j %d',
            M : 'osu kan',
            MM : 'osu %d',
            y : 'dun kan',
            yy : 'dun %d'
        },
        dayOfMonthOrdinalParse : /j\s\d{1,2}/,
        ordinal : 'j %d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    return yo;

})));


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var zhCn = moment.defineLocale('zh-cn', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMDAhmm',
            LLLL : 'YYYYMDddddAhmm',
            l : 'YYYY/M/D',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' ||
                    meridiem === '') {
                return hour;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            } else {
                // ''
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[]LT',
            nextDay : '[]LT',
            nextWeek : '[]ddddLT',
            lastDay : '[]LT',
            lastWeek : '[]ddddLT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '';
                case 'M':
                    return number + '';
                case 'w':
                case 'W':
                    return number + '';
                default:
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        week : {
            // GB/T 7408-1994ISO 8601:1988
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return zhCn;

})));


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var zhHk = moment.defineLocale('zh-hk', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMD HH:mm',
            LLLL : 'YYYYMDdddd HH:mm',
            l : 'YYYY/M/D',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[]LT',
            nextDay : '[]LT',
            nextWeek : '[]ddddLT',
            lastDay : '[]LT',
            lastWeek : '[]ddddLT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '';
                case 'M' :
                    return number + '';
                case 'w' :
                case 'W' :
                    return number + '';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return zhHk;

})));


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


    var zhTw = moment.defineLocale('zh-tw', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMD HH:mm',
            LLLL : 'YYYYMDdddd HH:mm',
            l : 'YYYY/M/D',
            ll : 'YYYYMD',
            lll : 'YYYYMD HH:mm',
            llll : 'YYYYMDdddd HH:mm'
        },
        meridiemParse: /|||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd LT',
            sameElse : 'L'
        },
        dayOfMonthOrdinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
                case 'd' :
                case 'D' :
                case 'DDD' :
                    return number + '';
                case 'M' :
                    return number + '';
                case 'w' :
                case 'W' :
                    return number + '';
                default :
                    return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            ss : '%d ',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    return zhTw;

})));


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Pair__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__customEvents__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__EventLogger__ = __webpack_require__(7);
/* global RTCSessionDescription, RTCIceCandidate, RTCPeerConnection */








const BaseStack = (specInput) => {
    var that = {};
    const specBase = specInput;
    let localDesc;
    that.remoteDesc = undefined;
    __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Starting Base stack', specBase);

    that.pcConfig = {
        iceServers: [],
    };

    that.con = {};
    if (specBase.iceServers !== undefined) {
        that.pcConfig.iceServers = specBase.iceServers;
    }
    if (specBase.forceTurn === true) {
        that.pcConfig.iceTransportPolicy = 'relay';
    }
    if (specBase.audio === undefined) {
        specBase.audio = true;
    }
    if (specBase.video === undefined) {
        specBase.video = true;
    }
    specBase.remoteCandidates = [];
    specBase.localCandidates = [];
    specBase.remoteDescriptionSet = false;

    that.mediaConstraints = {
        offerToReceiveVideo: (specBase.video !== undefined && specBase.video !== false),
        offerToReceiveAudio: (specBase.audio !== undefined && specBase.audio !== false),
    };

    function getPlugin() {
        return document.getElementById('WebrtcEverywherePluginId');
    }

    var IERTCSessionDescription = function (RTCSessionDescriptionInit) {
        return getPlugin().createSessionDescription(RTCSessionDescriptionInit);
    }

    var IERTCPeerConnection = function (configuration, constraints) {
        return getPlugin().createPeerConnection(configuration, constraints);
    }

    // creating peer connection object
    if(__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'IE'){
        that.peerConnection = IERTCPeerConnection(that.pcConfig, that.con);
    }else{
        that.peerConnection = new RTCPeerConnection(that.pcConfig, that.con);
    }

    var gotDescriptionLocalForPublish = function (desc) {
        localDesc = desc;
        localDesc.sdp  = localDesc.sdp.replace("a=sendrecv", "a=sendonly");
        setLocalDescForOffer(false,desc);
    }

    var gotDescriptionLocalForSubscribe = function (desc) {
        localDesc = desc;
        setLocalDescForOffer(true,desc);
    }

    function maybeFixConfiguration(pcConfig) {
        if (!pcConfig) {
            return;
        }
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
            if (pcConfig.iceServers[i].hasOwnProperty('urls')){
                pcConfig.iceServers[i]['url'] = pcConfig.iceServers[i]['urls'];
                delete pcConfig.iceServers[i]['urls'];
            }
        }
    }

    // Aux functions
    const errorCallback = (where, errorcb, message) => {
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].error('message:', message, 'in baseStack at', where);
        if (errorcb !== undefined) {
            errorcb('error');
        }
    };

    const successCallback = (message) => {
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Success in BaseStack', message);
    };

    const onIceCandidate = (event) => {
        let candidateObject = {};
        var candidate = event.candidate;
        if (!candidate) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Gathered all candidates. Sending END candidate');
            candidateObject = {
                sdpMLineIndex: -1,
                sdpMid: 'end',
                candidate: 'end',
            };
        } else {
            /* if (!candidate.candidate.match(/a=/)) {
                 candidate.candidate = `a=${candidate.candidate}`;
             }*/

            candidateObject = {
                sdpMLineIndex: candidate.sdpMLineIndex,
                sdpMid: candidate.sdpMid,
                candidate: 'a='+candidate.candidate,
            };
        }

        if (specBase.remoteDescriptionSet) {
            specBase.callback({ type: 'candidate', candidate: candidateObject });
        } else {
            specBase.localCandidates.push(candidateObject);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Storing candidate: ', specBase.localCandidates.length, candidateObject);
        }
    };

    const setLocalDescForOffer = (isSubscribe, sessionDescription) => {
        localDesc = sessionDescription;
        if (!isSubscribe) {
            localDesc.sdp = that.enableSimulcast(localDesc.sdp);
        }
        if(!isSubscribe && (__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'safari') ){
            localDesc.sdp = localDesc.sdp.replace("a=sendrecv", "a=sendonly");
        }
        localDesc.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(localDesc.sdp, specBase);
        specBase.callback({
            type: localDesc.type,
            sdp: localDesc.sdp,
        });
        __WEBPACK_IMPORTED_MODULE_5__EventLogger__["a" /* default */].info('webrtc-stack-event', __WEBPACK_IMPORTED_MODULE_4__customEvents__["a" /* default */].event_set_local_description, {localDesc: localDesc});
    };
    function getCodecFromMedia(medias,mediaType,codecName) {
    for (var media of medias){
      if (media.media.toLowerCase() === mediaType.toLowerCase()){
          for (var codec of media.codecs){
          if (codec.name.toLowerCase() === codecName.toLowerCase()){
            return codec;
          }
        }
      }
    }
  }
    const getSDP = function (sdp,type) {
        var codecToRemove;
        var codecToKeep ;
        var msg = new Object();
        msg.sdp = sdp.sdp;
        msg.type = sdp.type;
        if(type === __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC){
          codecToRemove = getCodecFromMedia(sdp.media,'video','vp8');
          codecToKeep = getCodecFromMedia(sdp.media,'video','h264');
        }else if(type === __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.default){
          codecToRemove = getCodecFromMedia(sdp.media,'video','h264');
          codecToKeep = getCodecFromMedia(sdp.media,'video','vp8');
          if (codecToRemove != undefined){
            msg.sdp = msg.sdp.replace("a=fmtp:" + codecToRemove.payload + " level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\r\n",'');
          }
        }else{
          return msg;
        }
        if (codecToRemove != undefined){
              msg.sdp = msg.sdp.replace("a=rtpmap:" + codecToRemove.payload + " " + codecToRemove.name +"/90000\r\n",'');
              msg.sdp = msg.sdp.replace("m=video 1 UDP/TLS/RTP/SAVPF " + codecToKeep.payload + " " + codecToRemove.payload + "\r\n",'m=video 1 UDP/TLS/RTP/SAVPF ' + codecToKeep.payload + '\r\n');
              msg.sdp = msg.sdp.replace("m=video 1 UDP/TLS/RTP/SAVPF " + codecToRemove.payload + " " + codecToKeep.payload + "\r\n",'m=video 1 UDP/TLS/RTP/SAVPF ' + codecToKeep.payload + '\r\n');
              msg.sdp = msg.sdp.replace("a=rtcp-fb:" + codecToRemove.payload + " ccm fir\r\n",'');
              msg.sdp = msg.sdp.replace("a=rtcp-fb:"+ codecToRemove.payload + " nack\r\n",'');
              msg.sdp = msg.sdp.replace("a=rtcp-fb:"+ codecToRemove.payload +" nack pli\r\n",'');
              msg.sdp = msg.sdp.replace("a=rtcp-fb:"+ codecToRemove.payload +" goog-remb\r\n",'');
        }
        return msg;
    }
    that.resetSDP  = function (mediaConfiguration) {
        const msg = getSDP(that.remoteDesc,mediaConfiguration);
        that.peerConnection.createOffer({offerToReceiveVideo: true,offerToReceiveAudio: true,iceRestart:false}).then(function(offer){
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info("OFFER: - \n"+offer.sdp);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info("RECVD ANSWER B4: - \n"+that.remoteDesc.sdp);
            that.peerConnection.setLocalDescription(offer).then(() => {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info("ANSWER: - \n"+msg.sdp);
                that.peerConnection.setRemoteDescription(new RTCSessionDescription(msg));
            }).catch(errorCallback.bind(null, 'processAnswer', undefined));
        }).catch(function (reason) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info(reason);
        });
    }
    const processAnswer = (message,mediaConfiguration) => {
        var  msg = message;
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Set remote and local description');
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Remote Description', msg.sdp);
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Local Description', localDesc.sdp);
        msg.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(msg.sdp, specBase);
        that.remoteDesc = JSON.parse(JSON.stringify(msg));
        if(__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'IE'){
        that.peerConnection.setLocalDescription(localDesc);
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Remote msg details for sdp:- '+JSON.stringify(msg));
        that.peerConnection.setRemoteDescription(IERTCSessionDescription(msg));
        specBase.remoteDescriptionSet = true;
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Candidates to be added: ', specBase.remoteCandidates.length,
            specBase.remoteCandidates);
        while (specBase.remoteCandidates.length > 0) {
            // IMPORTANT: preserve ordering of candidates
            that.peerConnection.addIceCandidate(specBase.remoteCandidates.shift());
        }
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Local candidates to send:', specBase.localCandidates.length);
        while (specBase.localCandidates.length > 0 && !that.peerConnection) {
            // IMPORTANT: preserve ordering of candidates
            specBase.callback({ type: 'candidate', candidate: specBase.localCandidates.shift() });
        }
        }else{
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Remote Description', that.remoteDesc.sdp);
        that.peerConnection.setLocalDescription(localDesc).then(() => {
            // browser === safari,   version >= 12.1, mediaConfiguration === default/vp8
            // browser === safari,  browser version <= 12.0, mediaConfig === default/vp8
            // browser !== safari, mediaConfig === h264 or VP8

            if((__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'safari' && __WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].getBrowserVersion() >=  __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_SUPPORTING_VP8  && mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC)){
                msg = getSDP(msg,__WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.default);
            }
            else if((__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'safari' && __WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].getBrowserVersion() <= __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_NOT_SUPPORTING_VP8 &&  mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC)){
                msg = getSDP(msg,__WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC);
            }
            else{
                msg = getSDP(msg,__WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.default);
            }
		__WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Remote Description', that.remoteDesc.sdp);
                that.peerConnection.setRemoteDescription(new RTCSessionDescription(msg)).then(() => {
                    specBase.remoteDescriptionSet = true;
                    __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Candidates to be added: ', specBase.remoteCandidates.length,
                        specBase.remoteCandidates);
                        while (specBase.remoteCandidates.length > 0 && (!that.peerConnection || !that.peerConnection.remoteDescription.type)) {
                            // IMPORTANT: preserve ordering of candidates
                            that.peerConnection.addIceCandidate(specBase.remoteCandidates.shift());
                        }
                        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info('Local candidates to send:', specBase.localCandidates.length);
                        while (specBase.localCandidates.length > 0) {
                            // IMPORTANT: preserve ordering of candidates
                            specBase.callback({ type: 'candidate', candidate: specBase.localCandidates.shift() });
                        }
                    }).catch(errorCallback.bind(null, 'processAnswer', undefined));
            }).catch(errorCallback.bind(null, 'processAnswer', undefined));
        }
    };
    var IERTCIceCandidate = function (RTCIceCandidateInit) {
        return getPlugin().createIceCandidate(RTCIceCandidateInit);
    };
    const processNewCandidate = (message) => {
        const msg = message;
        try {
            let obj;
            if (typeof (msg.candidate) === 'object') {
                obj = msg.candidate;
            } else {
                obj = JSON.parse(msg.candidate);
            }
            if (obj.candidate === 'end') {
                // ignore the end candidate for chrome
                return;
            }
            obj.candidate = obj.candidate.replace('a=', '');
            obj.sdpMLineIndex = parseInt(obj.sdpMLineIndex, 10);
            const candidate = IERTCIceCandidate(obj);
            if (specBase.remoteDescriptionSet) {
                that.peerConnection.addIceCandidate(candidate);
            } else {
                specBase.remoteCandidates.push(candidate);
            }
        } catch (e) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].error('Error parsing candidate', msg.candidate);
        }
    };

    // Peerconnection events

    that.peerConnection.onicecandidate = onIceCandidate;
    that.peerConnection.onaddstream = (stream) => {
        if (that.onaddstream) {
            that.onaddstream(stream);
        }
    };
    that.peerConnection.onremovestream = (stream) => {
        if (that.onremovestream) {
            that.onremovestream(stream);
        }
    };

    that.peerConnection.oniceconnectionstatechange = (ev) => {
        if (that.oniceconnectionstatechange) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info("ICE connection state changed",ev.currentTarget.iceConnectionState);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].info("ICE gathering state changed",ev.currentTarget.iceGatheringState);
            that.oniceconnectionstatechange(ev.currentTarget.iceConnectionState);
        }
    };

    // public functions

    that.enableSimulcast = (sdpInput) => {
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].error('Simulcast not implemented');
        return sdpInput;
    };
    that.updateSimulcastLayersBitrate = (bitrates) => {
      if (that.simulcast) {
        that.simulcast.spatialLayerBitrates = bitrates;
        that.setSimulcastLayersBitrate();
      }
    };

    that.setSimulcastLayersBitrate = () => {
      __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].error('Simulcast not implemented');
    };
  that.setSimulcast = (enable) => {
    that.simulcast = enable;
  };

    that.close = () => {
        that.state = 'closed';
        that.peerConnection.close();
    };

    that.updateSpec = (configInput, callback = () => {}) => {
        const config = configInput;
        if (config.maxVideoBW || config.maxAudioBW) {
            if (config.maxVideoBW) {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Maxvideo Requested:', config.maxVideoBW,
                    'limit:', specBase.limitMaxVideoBW);
                if (config.maxVideoBW > specBase.limitMaxVideoBW) {
                    config.maxVideoBW = specBase.limitMaxVideoBW;
                }
                specBase.maxVideoBW = config.maxVideoBW;
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Result', specBase.maxVideoBW);
            }
            if (config.maxAudioBW) {
                if (config.maxAudioBW > specBase.limitMaxAudioBW) {
                    config.maxAudioBW = specBase.limitMaxAudioBW;
                }
                specBase.maxAudioBW = config.maxAudioBW;
            }

            localDesc.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(localDesc.sdp, specBase);
            if (config.Sdp || config.maxAudioBW) {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Updating with SDP renegotiation', specBase.maxVideoBW, specBase.maxAudioBW);
                that.peerConnection.setLocalDescription(localDesc)
                    .then(() => {
                        that.remoteDesc.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(that.remoteDesc.sdp, specBase);
                        return that.peerConnection.setRemoteDescription(new RTCSessionDescription(that.remoteDesc));
                    }).then(() => {
                    specBase.remoteDescriptionSet = true;
                    specBase.callback({ type: 'updatestream', sdp: localDesc.sdp });
                }).catch(errorCallback.bind(null, 'updateSpec', callback));
            } else {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Updating without SDP renegotiation, ' +
                    'newVideoBW:', specBase.maxVideoBW,
                    'newAudioBW:', specBase.maxAudioBW);
                specBase.callback({ type: 'updatestream', sdp: localDesc.sdp });
            }
        }
        if (config.minVideoBW || (config.slideShowMode !== undefined) ||
            (config.muteStream !== undefined) || (config.qualityLayer !== undefined) ||
            (config.video !== undefined)) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('MinVideo Changed to ', config.minVideoBW);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('SlideShowMode Changed to ', config.slideShowMode);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('muteStream changed to ', config.muteStream);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Video Constraints', config.video);
            specBase.callback({ type: 'updatestream', config });
        }
    };

    that.createOffer = (isSubscribe,iceRestart) => {
        if (isSubscribe !== true) {
            that.mediaConstraints = {
                offerToReceiveVideo: false,
                offerToReceiveAudio: false,
            };
        }
        if(iceRestart){
            that.mediaConstraints['iceRestart'] = iceRestart;
        }
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["a" /* default */].debug('Creating offer :-'+JSON.stringify(that.mediaConstraints));
        if(__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'IE'){
            if (isSubscribe !== true){
                that.peerConnection.createOffer(gotDescriptionLocalForPublish, errorCallback);
            }else{
                var offerConstraints = {
                    "optional": [
                        { "OfferToReceiveAudio": true },
                        { "OfferToReceiveVideo": true },
                    ]
                };
                that.peerConnection.createOffer(gotDescriptionLocalForSubscribe, errorCallback,offerConstraints);
            }
        }else{
            that.peerConnection.createOffer(that.mediaConstraints)
                .then(setLocalDescForOffer.bind(null, isSubscribe))
                .catch(errorCallback.bind(null, 'Create Offer', undefined));
        }

    };

    that.addStream = (stream) => {
        that.peerConnection.addStream(stream);
    };
    that.addTrack = (track) =>{
        that.peerConnection.addTrack(track);
    };

    that.processSignalingMessage = (msgInput,mediaConfiguration) => {
        if (msgInput.type === 'answer') {
            processAnswer(msgInput,mediaConfiguration);
        } else if (msgInput.type === 'candidate') {
            processNewCandidate(msgInput);
        }
    };

    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (BaseStack);


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const SdpHelpers = {};

SdpHelpers.addSim = (spatialLayers) => {
  let line = 'a=ssrc-group:SIM';
  spatialLayers.forEach((spatialLayerId) => {
    line += ` ${spatialLayerId}`;
  });
  return `${line}\r\n`;
};

SdpHelpers.addGroup = (spatialLayerId, spatialLayerIdRtx) =>
  `a=ssrc-group:FID ${spatialLayerId} ${spatialLayerIdRtx}\r\n`;

SdpHelpers.addSpatialLayer = (cname, msid, mslabel,
  label, spatialLayerId, spatialLayerIdRtx) =>
  `a=ssrc:${spatialLayerId} cname:${cname}\r\n` +
  `a=ssrc:${spatialLayerId} msid:${msid}\r\n` +
  `a=ssrc:${spatialLayerId} mslabel:${mslabel}\r\n` +
  `a=ssrc:${spatialLayerId} label:${label}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} cname:${cname}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} msid:${msid}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} mslabel:${mslabel}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} label:${label}\r\n`;

SdpHelpers.setMaxBW = (sdpInput, spec) => {
  let r;
  let a;
  let sdp = sdpInput;
  if (spec.video && spec.maxVideoBW) {
    sdp = sdp.replace(/b=AS:.*\r\n/g, '');
    a = sdp.match(/m=video.*\r\n/);
    if (a == null) {
      a = sdp.match(/m=video.*\n/);
    }
    if (a && (a.length > 0)) {
      r = `${a[0]}b=AS:${spec.maxVideoBW}\r\n`;
      sdp = sdp.replace(a[0], r);
    }
  }

  if (spec.audio && spec.maxAudioBW) {
    a = sdp.match(/m=audio.*\r\n/);
    if (a == null) {
      a = sdp.match(/m=audio.*\n/);
    }
    if (a && (a.length > 0)) {
      r = `${a[0]}b=AS:${spec.maxAudioBW}\r\n`;
      sdp = sdp.replace(a[0], r);
    }
  }
  return sdp;
};

SdpHelpers.enableOpusNacks = (sdpInput) => {
  let sdp = sdpInput;
  const sdpMatch = sdp.match(/a=rtpmap:(.*)opus.*\r\n/);
  if (sdpMatch !== null) {
    const theLine = `${sdpMatch[0]}a=rtcp-fb:${sdpMatch[1]}nack\r\n`;
    sdp = sdp.replace(sdpMatch[0], theLine);
  }

  return sdp;
};

/* harmony default export */ __webpack_exports__["a"] = (SdpHelpers);


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__customErrors__ = __webpack_require__(11);


const GUMErrorHandler = (err) => {
    let error = null;
    if (err.name === 'OverconstrainedError' && err.constraint === 'deviceId') {
        // device id not matched
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1142;
    } else if ((err.name == "OverconstrainedError" || err.name == "ConstraintNotSatisfiedError") && err.constraint === 'width') {
        //constraints can not be satisfied by devices
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1147;
    } else if ((err.name == "OverconstrainedError" || err.name == "ConstraintNotSatisfiedError") && err.constraint === 'height') {
        //constraints can not be satisfied by devices
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1148;
    }
    else if ((err.name == "OverconstrainedError" || err.name == "ConstraintNotSatisfiedError") && !err.constraint) {
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1149;
    }
    else if (err.name == "NotFoundError" || err.name == "DevicesNotFoundError") {
        // Device not found
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1143;
    } else if (err.name == "NotReadableError" || err.name == "TrackStartError") {
        //webcam or mic are already in use
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1145;
    } else if (err.name == "NotAllowedError" || err.name == "PermissionDeniedError") {
        // Permission denied
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1144;
    } else if (err.name == "TypeError" || err.name == "TypeError") {
        //empty constraints object
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1146;
    } else {
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1150;
    }
    return error;
};

/* harmony default export */ __webpack_exports__["a"] = (GUMErrorHandler);


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ViewProperties__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__component_Speaker__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__component_Zoomer__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_Branding__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__component_Recorder__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__component_Share__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__component_Play__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__component_microphone__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__assets_css_defaultCss__ = __webpack_require__(8);
/*
This file is for handle Bar.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/

/* global document, clearTimeout, setTimeout */












/*
 * Bar represents the bottom menu bar of every mediaPlayer.
 * It contains a Speaker and an icon.
 * Every Bar is a View.
 * Ex.: var bar = Bar({elementID: element, id: id});
 */
const Bar = (spec) => {
    const that = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    // Variables
    let waiting;
    let toolbar;
    toolbar = Object(__WEBPACK_IMPORTED_MODULE_0__ViewProperties__["a" /* default */])().toolbar.default;
    var isDefault = false;
    //options attribute checking
    if(spec.options !== undefined && spec.options.player !==undefined){
        that.playerProperties = spec.options.player;
    }
    if (spec.options.toolbar) {
        var barUser = spec.options.toolbar;
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.position))
            toolbar.position = barUser.position;
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.class))
            toolbar.class = barUser.class;
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.skin)) {
            toolbar.skin = barUser.skin;
            isDefault = toolbar.skin === 'default';
        }
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.displayMode))
            toolbar.displayMode = barUser.displayMode;
        else
            toolbar.displayMode = barUser.displayMode;
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.autoDisplayTimeout))
            toolbar.autoDisplayTimeout = barUser.autoDisplayTimeout;
        if (barUser.buttons) {
            toolbar.buttons = barUser.buttons;
        }
    }


    // DOM element in which the Bar will be appended
    that.elementID = spec.elementID;

    // Bar ID
    that.id = spec.id;

    // Container
    if (isDefault) {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({name: 'div', id: `bar_${that.id}`, class: 'vcx_bar', style: __WEBPACK_IMPORTED_MODULE_10__assets_css_defaultCss__["a" /* default */].vcx_bar});
    }
    else {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({name: 'div', id: `bar_${that.id}`, class: 'vcx_bar ' + toolbar.skin + '_vcx_bar'});
    }

    __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getById(that.elementID).appendChild(that.div);

    //bar
    if (isDefault) {
        that.bar = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({
            name: 'div',
            id: `subbar_${that.id}`,
            class: 'vcx_subbar ' + toolbar.class,
            style: __WEBPACK_IMPORTED_MODULE_10__assets_css_defaultCss__["a" /* default */]['vcx_subbar_' + toolbar.position]
        });
    }
    else
        that.bar = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({
            name: 'div',
            id: `subbar_${that.id}`,
            class: 'vcx_subbar ' + toolbar.skin + '_vcx_subbar_' + toolbar.position + ' ' + toolbar.class
        });
    that.div.appendChild(that.bar);
    dragElement(that.bar);

    function dragElement(elmnt) {
        var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        if (document.getElementById(elmnt.id)) {
            /* if present, the header is where you move the DIV from:*/
            document.getElementById(elmnt.id).onmousedown = dragMouseDown;
        } else {
            /* otherwise, move the DIV from anywhere inside the DIV:*/
            elmnt.onmousedown = dragMouseDown;
        }

        function dragMouseDown(e) {
            e = e || window.event;
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // set the element's new position:
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
        }

        function closeDragElement() {
            /* stop moving when mouse button is released:*/
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }

    //Play icon
    if (toolbar.buttons.play) {
        that.playIcon = Object(__WEBPACK_IMPORTED_MODULE_8__component_Play__["a" /* default */])({stream: spec.stream, skin: toolbar.skin});
        that.bar.appendChild(that.playIcon);
    }

    // Zoom icon
    if (toolbar.buttons.zoom) {
        that.zoomIcon = Object(__WEBPACK_IMPORTED_MODULE_4__component_Zoomer__["a" /* default */])({skin: toolbar.skin,player:that.playerProperties});
        that.bar.appendChild(that.zoomIcon);
    }

    // Record icon
    if (toolbar.buttons.record) {
        that.recIcon = Object(__WEBPACK_IMPORTED_MODULE_6__component_Recorder__["a" /* default */])({skin: toolbar.skin, stream: spec.stream});
        that.bar.appendChild(that.recIcon);
    }

    // Share icon
    if (toolbar.buttons.share) {
        that.shareIcon = Object(__WEBPACK_IMPORTED_MODULE_7__component_Share__["a" /* default */])({skin: toolbar.skin, stream: spec.stream});
        that.bar.appendChild(that.shareIcon);
    }

    // Mic icon
    if (toolbar.buttons.mic) {
        that.micIcon = Object(__WEBPACK_IMPORTED_MODULE_9__component_microphone__["a" /* default */])({skin: toolbar.skin, stream: spec.stream});
        that.bar.appendChild(that.micIcon);
    }

    // Brand icon
    var brandTemp = {};
    if (spec.options && spec.options.toolbar && spec.options.toolbar.branding) {
        brandTemp = spec.options.toolbar.branding;
    }
    brandTemp['skin'] = toolbar.skin;
    that.brand = Object(__WEBPACK_IMPORTED_MODULE_5__component_Branding__["a" /* default */])(brandTemp);
    that.bar.appendChild(that.brand);

    // Speaker component
    if (toolbar.buttons.volume && !spec.stream.screen && (spec.options === undefined ||
            spec.options.speaker === undefined ||
            spec.options.speaker === true)) {

        that.speaker = Object(__WEBPACK_IMPORTED_MODULE_3__component_Speaker__["a" /* default */])({
            elementID: `subbar_${that.id}`,
            id: that.id,
            stream: spec.stream,
            media: spec.media,
            position: toolbar.position,
            skin: toolbar.skin
        });
    }

    // Toolbar display mode set
    if (toolbar.displayMode) {
        if (toolbar.displayMode == 'auto') {
            that.div.onmouseover = function (event) {
                var elem = event.currentTarget;
                setTimeout(
                    function () {
                        __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', elem).style.display = "block";
                    },
                    (parseInt(toolbar.autoDisplayTimeout) * 1000)
                );
            };
            that.div.onmouseout = function (event) {
                var elem = event.currentTarget;
                setTimeout(
                    function () {
                        __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', elem).style.display = "none";
                    },
                    (parseInt(toolbar.autoDisplayTimeout) * 1000)
                );
            };
            __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', that.div).style.display = "none";
        } else
            __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', that.div).style.display = "block";
    } else {
        __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', that.div).style.display = "none";
    }
    return that;
}


/* harmony default export */ __webpack_exports__["a"] = (Bar);


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ViewProperties__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Bar__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Localization__ = __webpack_require__(152);
/*
This file is for handle VideoPlayer.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/

/* global document, L */







/*
 * VideoPlayer represents a video component that shows either a local or a remote video.
 * Ex.: var player = VideoPlayer({id: id, stream: stream, elementID: elementID});
 * A VideoPlayer is also a View component.
 */
const VideoPlayer = (spec) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__View__["a" /* default */])({});

  // Variables
  var player = Object(__WEBPACK_IMPORTED_MODULE_1__ViewProperties__["a" /* default */])().player.default;
  if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(spec.options) && __WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(spec.options.player)){
	  var playerOptions = spec.options.player;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.autoplay))
		player.autoplay = playerOptions.autoplay;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.name))
		player.name = playerOptions.name;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.nameDisplayMode))
		player.nameDisplayMode = playerOptions.nameDisplayMode;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.frameFitMode))
		player.frameFitMode = playerOptions.frameFitMode;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.skin))
		player.skin = playerOptions.skin;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.class))
		player.class = playerOptions.class;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.height))
		player.height = playerOptions.height;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.width))
		player.width = playerOptions.width;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.minHeight))
		player.minHeight = playerOptions.minHeight;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.minWidth))
		player.minWidth = playerOptions.minWidth;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.aspectRatio))
		player.aspectRatio = playerOptions.aspectRatio;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.volume))
		player.volume = playerOptions.volume;
      if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.backgroundImg))
          player.backgroundImg = playerOptions.backgroundImg;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.media))
		player.media = playerOptions.media;
	if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(playerOptions.loader)){
		var loaderProp = playerOptions.loader;
		if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(loaderProp.url))
		player.loader.url = loaderProp.url;
		player.loader.show = loaderProp.show;
		if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(loaderProp.class))
		player.loader.class = loaderProp.class;
		if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(loaderProp.style))
		player.loader.style = loaderProp.style;
	}
  }

  // VideoPlayer ID
  that.id = spec.id;
  // Stream that the VideoPlayer will play
  that.stream = spec.stream.stream;
  // DOM element in which the VideoPlayer will be appended
  that.elementID = spec.elementID;

  // Private functions
  that.abwd = {};
  that.abwd.notification = true;
  that.abwd.lang = 'en';


  if(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(spec.options) &&
     __WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(spec.options.player) &&
     __WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].checkParam(spec.options.player.abwd)){
     var abwdOption = spec.options.player.abwd;
     if(abwdOption.enabled === false)
       that.abwd.notification = false;
     else {
        if(abwdOption.enabled === true && abwdOption.notification === 'sdk') {
          that.abwd.notification = true;
          if(abwdOption.language === 'en' || abwdOption.language === 'zh'){
            that.abwd.lang = abwdOption.language;
          } else
            that.abwd.lang = 'en';
        }  else {
         if(abwdOption.enabled === true && abwdOption.notification === 'app') {
          that.abwd.notification = false;
          that.abwd.lang = '';
         }
       }
    }
  }

	var container = __WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].getById(spec.elementID);
		container.style.height = player.height;
		container.style.width = player.width;//that.id
		container.style.minHeight = player.minHeight;
		container.style.minWidth = player.minWidth;


  const applyRatio = (ratio, width, height, reverse) => {
    const condition = !reverse ? width * (1 / ratio) < height : width * (1 / ratio) > height;
    if (condition) {
      that.video.style.width = `${width}px`;
      that.video.style.height = `${(1 / ratio) * width}px`;

      that.video.style.top = `${-((((1 / ratio) * width) / 2) - (height / 2))}px`;
      that.video.style.left = '0px';
    } else {
      that.video.style.height = `${height}px`;
      that.video.style.width = `${ratio * height}px`;

      that.video.style.left = `${-(((ratio * height) / 2) - (width / 2))}px`;
      that.video.style.top = '0px';
    }
  };

  // Public functions

  // It will stop the VideoPlayer and remove it from the HTML
  that.destroy = () => {
    console.log('video player destroy requested');
    that.video.pause();
    delete that.resizer;
    that.parentNode.removeChild(that.div);
  };

  that.resize = () => {
    const width = that.container.offsetWidth;
    const height = that.container.offsetHeight;

    if (spec.stream.screen || spec.options.crop === false || spec.stream.canvas ) {
      applyRatio(16 / 9, width, height, false);
    } else if (width !== that.containerWidth || height !== that.containerHeight) {
      applyRatio(4 / 3, width, height, true);
    }
    that.containerWidth = width;
    that.containerHeight = height;
  };

  /* window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
      document.getElementById(key).value = unescape(value);
  }); */

  // Container
  that.div = Object(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */])({name:'div',id:`player_${that.id}`,class:'vcx_player '+player.skin+'_vcx_player'});

  // Loader icon
    if(player.loader.url){
        that.loader = Object(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */])({name:'img',src:player.loader.url,id:`back_${that.id}`,class:'vcx_player_loader '+player.loader.class+' '+player.skin+'_vcx_player_loader'});
        if(!player.loader.show)
            that.loader.style.display = 'none';
    }


  //BackGround Image
    if(player.backgroundImg){
        that.screenSaver = Object(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */])({name:'img',src:player.backgroundImg,id:`screen_saver_${that.id}`,class:'vcx_player_screen_saver '+player.skin+'_vcx_player_screen_saver'});
        that.screenSaver.style.display = 'none';
    }


  // Video tag

  //that.video = Element({name:'video',autoplay:'autoplay',id:`stream${that.id}`,class:'vcx_stream',style:ViewProperties.Player.video.style.default});
    that.video = Object(__WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */])({name:'video',autoplay:'autoplay',playsinline:'playsinline', id:`stream${that.id}`,class:'vcx_stream '+player.skin+'_vcx_stream'});

    if (spec.stream.local) { that.video.volume = 0; }

  if (that.elementID !== undefined) {
    // Check for a passed DOM node.
    if (typeof that.elementID === 'object' &&
          typeof that.elementID.appendChild === 'function') {
      that.container = that.elementID;
    } else {
      that.container = __WEBPACK_IMPORTED_MODULE_3__Element__["a" /* default */].getById(that.elementID);
    }
  } else {
    that.container = document.body;
  }
  that.container.appendChild(that.div);

  that.parentNode = that.div.parentNode;


  // player stats button

  let statsContainer = document.createElement('div');
  statsContainer.setAttribute('id', `stats-container-${that.id}`);
  statsContainer.setAttribute('class', 'stats-container');
  statsContainer.setAttribute('style', 'display:none;');

  let bwNotContainer = document.createElement('div');
  bwNotContainer.setAttribute('id', `bw-notif-${that.id}`);
  bwNotContainer.setAttribute('class', 'bw-notification');
  bwNotContainer.setAttribute('style', 'display:none;position:absolute;z-index:3;padding:5px 10px;top:50%;right:50%;transform:translateX(50%);background:rgba(0,0,0,0.29);border-radius:5px;color:rgb(255,255,255)');

  let playerButton = document.createElement('div');
  playerButton.setAttribute('id', `stats-button-${that.id}`);
  playerButton.setAttribute('class', 'stats-button');
  playerButton.setAttribute('title', 'Click to see stats');
  playerButton.innerHTML = window.statsIcon;

  statsContainer.appendChild(playerButton);

  let statsOverlay = document.createElement('div');
  statsOverlay.setAttribute('class', 'stats-overlay');
  statsOverlay.setAttribute('id', `stats-overlay-${that.id}`);
  statsOverlay.setAttribute('style', 'display:none;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');

  let statsOverlayInner = document.createElement('div');
  statsOverlayInner.setAttribute('class', 'stats-overlay-inner');
  statsOverlayInner.setAttribute('id', `stats-overlay-inner-${that.id}`);
  // statsOverlayInner.setAttribute('style', `display:flex;flex-direction:row;`);


  let leftPartition = document.createElement('div'),
    rightPartition = document.createElement('div');
  leftPartition.setAttribute('class', 'stats-left-partition');
  leftPartition.setAttribute('id', `stats-left-part-${that.id}`);

  rightPartition.setAttribute('class', 'stats-right-partition');
  rightPartition.setAttribute('id', `stats-right-part-${that.id}`);

  playerButton.addEventListener('click', () => {
    if (statsOverlay.style.display === 'none')
      statsOverlay.style.display = 'block';
    else
      statsOverlay.style.display = 'none';
  });

  that.div.parentNode.style.position = 'relative';
  // Appending Stats container to main player container
  that.div.parentNode.appendChild(statsContainer);
  // appending overlay to container
  that.div.parentNode.appendChild(statsOverlay);
  statsOverlay.appendChild(statsOverlayInner);

  //Appending bw notification button
  that.div.parentNode.appendChild(bwNotContainer);


  // partitions of overlay
  statsOverlayInner.appendChild(leftPartition);
  statsOverlayInner.appendChild(rightPartition);


    if(that.loader){
        that.div.appendChild(that.loader);
    }
    if(that.screenSaver){
        that.div.appendChild(that.screenSaver);
    }

  that.div.appendChild(that.video);

  that.containerWidth = 0;
  that.containerHeight = 0;

  if (spec.options && spec.options.resizer !== false) {
    that.resizer = L.ResizeSensor(that.container, that.resize);

    that.resize();
  }

  // Bottom Bar
 if (spec.options.bar !== false) {
    that.bar = Object(__WEBPACK_IMPORTED_MODULE_2__Bar__["a" /* default */])({
		elementID: `player_${that.id}`,
		id: that.id,
		stream: spec.stream,
		media: that.video,
		options: spec.options
		});

  } else {
    // Expose a consistent object to manipulate the media.
    that.media = that.video;
  }
  //attachMediaStream(that.video,that.stream);
  that.video.srcObject = that.stream;
    // show or hide stats
    that.ShowSessionStats = (statsEnabled) => {
      if (statsEnabled === true) {
       // show stats UI
       statsContainer.setAttribute('style', 'display:block;');
       statsOverlay.setAttribute('style', 'display:block;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
      } else {
       // hide stats UI
       statsContainer.setAttribute('style', 'display:none;');
       statsOverlay.setAttribute('style', 'display:none;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
      }
    };

    that.setBwAlert = (enabled, type, name) => {
      if(that.abwd.notification === false)
        return;

      if(enabled === true) {
        if(type === 'subscriber')
          bwNotContainer.innerText = __WEBPACK_IMPORTED_MODULE_4__Localization__["a" /* default */].abwd[that.abwd.lang].bw_alert_subscriber;
        else
          bwNotContainer.innerText = name +  __WEBPACK_IMPORTED_MODULE_4__Localization__["a" /* default */].abwd[that.abwd.lang].bw_alert_publisher;
        bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px 10px;top:50%;right:50%;transform:translateX(50%);background:rgba(0,0,0,0.29);border-radius:5px;color:rgb(255,255,255)');
        //bwNotContainer.display = 'block';

      } else
        bwNotContainer.setAttribute('style', 'display:none;position:absolute;z-index:3;padding:5px 10px;top:50%;right:50%;transform:translateX(50%);background:rgba(0,0,0,0.29);border-radius:5px;color:rgb(255,255,255)');
        //bwNotContainer.display = none;
    };

    that.setVideoMutedMsg = (arg) => {
      if(that.abwd.notification === false)
        return;


      if(arg.videomuted === true && arg.reason === 'bw') {
          bwNotContainer.innerText = arg.name + " " + __WEBPACK_IMPORTED_MODULE_4__Localization__["a" /* default */].abwd[that.abwd.lang].video_muted;
          bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px 10px;top:50%;right:50%;transform:translateX(50%);background:rgba(0,0,0,0.29);border-radius:5px;color:rgb(255,255,255)');
      } else {
          bwNotContainer.setAttribute('style', 'display:none;position:absolute;z-index:3;padding:5px 10px;top:50%;right:50%;transform:translateX(50%);background:rgba(0,0,0,0.29);border-radius:5px;color:rgb(255,255,255)');
      }
    };

  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (VideoPlayer);



//////////////////
// WEBPACK FOOTER
// ./src/views/VideoPlayer.js
// module id = 139
// module chunks = 0


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const localization = {
  'abwd': {
    'en': {
      'bw_alert_publisher'  : ' Low upload bandwidth',
     'bw_alert_subscriber' : ' Low Download bandwidth',
      'video_muted'         : ' Video muted due to low bandwidth'
    },
    'zh' : {
      'bw_alert_publisher': ' ',
      'bw_alert_subscriber':'',
      'video_muted': ' '
    }
  }
}

/* harmony default export */ __webpack_exports__["a"] = (localization);


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* global unescape */

const Base64 = (() => {
  let base64Str;
  let base64Count;

  const END_OF_INPUT = -1;
  const base64Chars = [
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', '+', '/',
  ];

  const reverseBase64Chars = [];

  for (let i = 0; i < base64Chars.length; i += 1) {
    reverseBase64Chars[base64Chars[i]] = i;
  }

  const setBase64Str = (str) => {
    base64Str = str;
    base64Count = 0;
  };

  const readBase64 = () => {
    if (!base64Str) {
      return END_OF_INPUT;
    }
    if (base64Count >= base64Str.length) {
      return END_OF_INPUT;
    }
    const c = base64Str.charCodeAt(base64Count) & 0xff;  // eslint-disable-line no-bitwise
    base64Count += 1;
    return c;
  };

  const encodeBase64 = (str) => {
    let result;
    let lineCount;
    let done;
    setBase64Str(str);
    result = '';
    const inBuffer = new Array(3);
    lineCount = 0;
    done = false;
    while (!done && (inBuffer[0] = readBase64()) !== END_OF_INPUT) {
      inBuffer[1] = readBase64();
      inBuffer[2] = readBase64();
      // eslint-disable-next-line no-bitwise
      result += (base64Chars[inBuffer[0] >> 2]);
      if (inBuffer[1] !== END_OF_INPUT) {
        // eslint-disable-next-line no-bitwise
        result += (base64Chars[((inBuffer[0] << 4) & 0x30) | (inBuffer[1] >> 4)]);
        if (inBuffer[2] !== END_OF_INPUT) {
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[((inBuffer[1] << 2) & 0x3c) | (inBuffer[2] >> 6)]);
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[inBuffer[2] & 0x3F]);
        } else {
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[((inBuffer[1] << 2) & 0x3c)]);
          result = `${result}=`;
          done = true;
        }
      } else {
        // eslint-disable-next-line no-bitwise
        result += (base64Chars[((inBuffer[0] << 4) & 0x30)]);
        result = `${result}=`;
        result = `${result}=`;
        done = true;
      }
      lineCount += 4;
      if (lineCount >= 76) {
        result = `${result}\n`;
        lineCount = 0;
      }
    }
    return result;
  };

  const readReverseBase64 = () => {
    if (!base64Str) {
      return END_OF_INPUT;
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
      if (base64Count >= base64Str.length) {
        return END_OF_INPUT;
      }
      const nextCharacter = base64Str.charAt(base64Count);
      base64Count += 1;
      if (reverseBase64Chars[nextCharacter]) {
        return reverseBase64Chars[nextCharacter];
      }
      if (nextCharacter === 'A') {
        return 0;
      }
    }
  };

  const ntos = (value) => {
    let n = value.toString(16);
    if (n.length === 1) {
      n = `0${n}`;
    }
    n = `%${n}`;
    return unescape(n);
  };

  const decodeBase64 = (str) => {
    let result;
    let done;
    setBase64Str(str);
    result = '';
    const inBuffer = new Array(4);
    done = false;
    while (!done &&
              (inBuffer[0] = readReverseBase64()) !== END_OF_INPUT &&
              (inBuffer[1] = readReverseBase64()) !== END_OF_INPUT) {
      inBuffer[2] = readReverseBase64();
      inBuffer[3] = readReverseBase64();
      // eslint-disable-next-line no-bitwise,no-mixed-operators
      result += ntos((((inBuffer[0] << 2) & 0xff) | inBuffer[1] >> 4));
      if (inBuffer[2] !== END_OF_INPUT) {
        // eslint-disable-next-line no-bitwise,no-mixed-operators
        result += ntos((((inBuffer[1] << 4) & 0xff) | inBuffer[2] >> 2));
        if (inBuffer[3] !== END_OF_INPUT) {
          // eslint-disable-next-line no-bitwise
          result += ntos((((inBuffer[2] << 6) & 0xff) | inBuffer[3]));
        } else {
          done = true;
        }
      } else {
        done = true;
      }
    }
    return result;
  };

  return {
    encodeBase64,
    decodeBase64,
  };
})();

/* harmony default export */ __webpack_exports__["a"] = (Base64);


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

const path = __webpack_require__(177);

module.exports = {
	product:{
	    	company:'Vcloudx Inc', //Compny name
		product:'enablex.io', //Product name
        	version:'1.5.3', // version
		release:'1.5.3'	//release
	},
  video_layer_bitrates: {
    0: 300000,
    1: 800000,
    2: 1500000
  },
  video_resolution_range : {
    "HD": {"min" : {"width" : 320 , "height" : 180}, "max" : { "width" : 1280, "height" : 720}},
    "SD": {"min" : {"width" : 320 , "height" : 180}, "max" : { "width" : 640, "height" : 480}},
    "LD": {"min" : {"width" : 80 , "height" : 45}, "max" : { "width" : 640, "height" : 360}}
  }
};


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (immutable) */ __webpack_exports__["c"] = encryptStream;
/* harmony export (immutable) */ __webpack_exports__["b"] = decryptStream;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__streams__ = __webpack_require__(17);



const NONCE_LENGTH = 12;
const TAG_LENGTH = 16;
const KEY_LENGTH = 16;
const MODE_ENCRYPT = 'encrypt';
const MODE_DECRYPT = 'decrypt';
const ECE_RECORD_SIZE = 1024 * 64;
/* harmony export (immutable) */ __webpack_exports__["a"] = ECE_RECORD_SIZE;


const encoder = new TextEncoder();

function generateSalt(len) {
  const randSalt = new Uint8Array(len);
  crypto.getRandomValues(randSalt);
  return randSalt.buffer;
}

class ECETransformer {
  constructor(mode, ikm, rs, salt) {
    this.mode = mode;
    this.prevChunk;
    this.seq = 0;
    this.firstchunk = true;
    this.rs = rs;
    this.ikm = ikm.buffer;
    this.salt = salt;
  }

  async generateKey() {
    const inputKey = await crypto.subtle.importKey(
      'raw',
      this.ikm,
      'HKDF',
      false,
      ['deriveKey']
    );

    return crypto.subtle.deriveKey(
      {
        name: 'HKDF',
        salt: this.salt,
        info: encoder.encode('Content-Encoding: aes128gcm\0'),
        hash: 'SHA-256'
      },
      inputKey,
      {
        name: 'AES-GCM',
        length: 128
      },
      true, // Edge polyfill requires key to be extractable to encrypt :/
      ['encrypt', 'decrypt']
    );
  }

  async generateNonceBase() {
    const inputKey = await crypto.subtle.importKey(
      'raw',
      this.ikm,
      'HKDF',
      false,
      ['deriveKey']
    );

    const base = await crypto.subtle.exportKey(
      'raw',
      await crypto.subtle.deriveKey(
        {
          name: 'HKDF',
          salt: this.salt,
          info: encoder.encode('Content-Encoding: nonce\0'),
          hash: 'SHA-256'
        },
        inputKey,
        {
          name: 'AES-GCM',
          length: 128
        },
        true,
        ['encrypt', 'decrypt']
      )
    );

    return Buffer.from(base.slice(0, NONCE_LENGTH));
  }

  generateNonce(seq) {
    if (seq > 0xffffffff) {
      throw new Error('record sequence number exceeds limit');
    }
    const nonce = Buffer.from(this.nonceBase);
    const m = nonce.readUIntBE(nonce.length - 4, 4);
    const xor = (m ^ seq) >>> 0; //forces unsigned int xor
    nonce.writeUIntBE(xor, nonce.length - 4, 4);

    return nonce;
  }

  pad(data, isLast) {
    const len = data.length;
    if (len + TAG_LENGTH >= this.rs) {
      throw new Error('data too large for record size');
    }

    if (isLast) {
      const padding = Buffer.alloc(1);
      padding.writeUInt8(2, 0);
      return Buffer.concat([data, padding]);
    } else {
      const padding = Buffer.alloc(this.rs - len - TAG_LENGTH);
      padding.fill(0);
      padding.writeUInt8(1, 0);
      return Buffer.concat([data, padding]);
    }
  }

  unpad(data, isLast) {
    for (let i = data.length - 1; i >= 0; i--) {
      if (data[i]) {
        if (isLast) {
          if (data[i] !== 2) {
            throw new Error('delimiter of final record is not 2');
          }
        } else {
          if (data[i] !== 1) {
            throw new Error('delimiter of not final record is not 1');
          }
        }
        return data.slice(0, i);
      }
    }
    throw new Error('no delimiter found');
  }

  createHeader() {
    const nums = Buffer.alloc(5);
    nums.writeUIntBE(this.rs, 0, 4);
    nums.writeUIntBE(0, 4, 1);
    return Buffer.concat([Buffer.from(this.salt), nums]);
  }

  readHeader(buffer) {
    if (buffer.length < 21) {
      throw new Error('chunk too small for reading header');
    }
    const header = {};
    header.salt = buffer.buffer.slice(0, KEY_LENGTH);
    header.rs = buffer.readUIntBE(KEY_LENGTH, 4);
    const idlen = buffer.readUInt8(KEY_LENGTH + 4);
    header.length = idlen + KEY_LENGTH + 5;
    return header;
  }

  async encryptRecord(buffer, seq, isLast) {
    const nonce = this.generateNonce(seq);
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv: nonce },
      this.key,
      this.pad(buffer, isLast)
    );
    return Buffer.from(encrypted);
  }

  async decryptRecord(buffer, seq, isLast) {
    const nonce = this.generateNonce(seq);
    const data = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: nonce,
        tagLength: 128
      },
      this.key,
      buffer
    );

    return this.unpad(Buffer.from(data), isLast);
  }

  async start(controller) {
    if (this.mode === MODE_ENCRYPT) {
      this.key = await this.generateKey();
      this.nonceBase = await this.generateNonceBase();
      controller.enqueue(this.createHeader());
    } else if (this.mode !== MODE_DECRYPT) {
      throw new Error('mode must be either encrypt or decrypt');
    }
  }

  async transformPrevChunk(isLast, controller) {
    if (this.mode === MODE_ENCRYPT) {
      controller.enqueue(
        await this.encryptRecord(this.prevChunk, this.seq, isLast)
      );
      this.seq++;
    } else {
      if (this.seq === 0) {
        //the first chunk during decryption contains only the header
        const header = this.readHeader(this.prevChunk);
        this.salt = header.salt;
        this.rs = header.rs;
        this.key = await this.generateKey();
        this.nonceBase = await this.generateNonceBase();
      } else {
        controller.enqueue(
          await this.decryptRecord(this.prevChunk, this.seq - 1, isLast)
        );
      }
      this.seq++;
    }
  }

  async transform(chunk, controller) {
    if (!this.firstchunk) {
      await this.transformPrevChunk(false, controller);
    }
    this.firstchunk = false;
    this.prevChunk = Buffer.from(chunk.buffer);
  }

  async flush(controller) {
    //console.log('ece stream ends')
    if (this.prevChunk) {
      await this.transformPrevChunk(true, controller);
    }
  }
}

class StreamSlicer {
  constructor(rs, mode) {
    this.mode = mode;
    this.rs = rs;
    this.chunkSize = mode === MODE_ENCRYPT ? rs - 17 : 21;
    this.partialChunk = new Uint8Array(this.chunkSize); //where partial chunks are saved
    this.offset = 0;
  }

  send(buf, controller) {
    controller.enqueue(buf);
    if (this.chunkSize === 21 && this.mode === MODE_DECRYPT) {
      this.chunkSize = this.rs;
    }
    this.partialChunk = new Uint8Array(this.chunkSize);
    this.offset = 0;
  }

  //reslice input into record sized chunks
  transform(chunk, controller) {
    //console.log('Received chunk with %d bytes.', chunk.byteLength)
    let i = 0;

    if (this.offset > 0) {
      const len = Math.min(chunk.byteLength, this.chunkSize - this.offset);
      this.partialChunk.set(chunk.slice(0, len), this.offset);
      this.offset += len;
      i += len;

      if (this.offset === this.chunkSize) {
        this.send(this.partialChunk, controller);
      }
    }

    while (i < chunk.byteLength) {
      const remainingBytes = chunk.byteLength - i;
      if (remainingBytes >= this.chunkSize) {
        const record = chunk.slice(i, i + this.chunkSize);
        i += this.chunkSize;
        this.send(record, controller);
      } else {
        const end = chunk.slice(i, i + remainingBytes);
        i += end.byteLength;
        this.partialChunk.set(end);
        this.offset = end.byteLength;
      }
    }
  }

  flush(controller) {
    if (this.offset > 0) {
      controller.enqueue(this.partialChunk.slice(0, this.offset));
    }
  }
}

/*
input: a ReadableStream containing data to be transformed
key:  Uint8Array containing key of size KEY_LENGTH
rs:   int containing record size, optional
salt: ArrayBuffer containing salt of KEY_LENGTH length, optional
*/
function encryptStream(
  input,
  key,
  rs = ECE_RECORD_SIZE,
  salt = generateSalt(KEY_LENGTH)
) {
  const mode = 'encrypt';
  const inputStream = Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(input, new StreamSlicer(rs, mode));
  return Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(inputStream, new ECETransformer(mode, key, rs, salt));
}

/*
input: a ReadableStream containing data to be transformed
key:  Uint8Array containing key of size KEY_LENGTH
rs:   int containing record size, optional
*/
function decryptStream(input, key, rs = ECE_RECORD_SIZE) {
  const mode = 'decrypt';
  const inputStream = Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(input, new StreamSlicer(rs, mode));
  return Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(inputStream, new ECETransformer(mode, key, rs));
}

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(14).Buffer))

/***/ }),
/* 157 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var splice = __webpack_require__(182)
var nanotiming = __webpack_require__(183)
var assert = __webpack_require__(18)

module.exports = Nanobus

function Nanobus (name) {
  if (!(this instanceof Nanobus)) return new Nanobus(name)

  this._name = name || 'nanobus'
  this._starListeners = []
  this._listeners = {}
}

Nanobus.prototype.emit = function (eventName) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.emit: eventName should be type string or symbol')

  var data = []
  for (var i = 1, len = arguments.length; i < len; i++) {
    data.push(arguments[i])
  }

  var emitTiming = nanotiming(this._name + "('" + eventName.toString() + "')")
  var listeners = this._listeners[eventName]
  if (listeners && listeners.length > 0) {
    this._emit(this._listeners[eventName], data)
  }

  if (this._starListeners.length > 0) {
    this._emit(this._starListeners, eventName, data, emitTiming.uuid)
  }
  emitTiming()

  return this
}

Nanobus.prototype.on = Nanobus.prototype.addListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.on: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.on: listener should be type function')

  if (eventName === '*') {
    this._starListeners.push(listener)
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = []
    this._listeners[eventName].push(listener)
  }
  return this
}

Nanobus.prototype.prependListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.prependListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.prependListener: listener should be type function')

  if (eventName === '*') {
    this._starListeners.unshift(listener)
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = []
    this._listeners[eventName].unshift(listener)
  }
  return this
}

Nanobus.prototype.once = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.once: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.once: listener should be type function')

  var self = this
  this.on(eventName, once)
  function once () {
    listener.apply(self, arguments)
    self.removeListener(eventName, once)
  }
  return this
}

Nanobus.prototype.prependOnceListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.prependOnceListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.prependOnceListener: listener should be type function')

  var self = this
  this.prependListener(eventName, once)
  function once () {
    listener.apply(self, arguments)
    self.removeListener(eventName, once)
  }
  return this
}

Nanobus.prototype.removeListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.removeListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.removeListener: listener should be type function')

  if (eventName === '*') {
    this._starListeners = this._starListeners.slice()
    return remove(this._starListeners, listener)
  } else {
    if (typeof this._listeners[eventName] !== 'undefined') {
      this._listeners[eventName] = this._listeners[eventName].slice()
    }

    return remove(this._listeners[eventName], listener)
  }

  function remove (arr, listener) {
    if (!arr) return
    var index = arr.indexOf(listener)
    if (index !== -1) {
      splice(arr, index, 1)
      return true
    }
  }
}

Nanobus.prototype.removeAllListeners = function (eventName) {
  if (eventName) {
    if (eventName === '*') {
      this._starListeners = []
    } else {
      this._listeners[eventName] = []
    }
  } else {
    this._starListeners = []
    this._listeners = {}
  }
  return this
}

Nanobus.prototype.listeners = function (eventName) {
  var listeners = eventName !== '*'
    ? this._listeners[eventName]
    : this._starListeners

  var ret = []
  if (listeners) {
    var ilength = listeners.length
    for (var i = 0; i < ilength; i++) ret.push(listeners[i])
  }
  return ret
}

Nanobus.prototype._emit = function (arr, eventName, data, uuid) {
  if (typeof arr === 'undefined') return
  if (arr.length === 0) return
  if (data === undefined) {
    data = eventName
    eventName = null
  }

  if (eventName) {
    if (uuid !== undefined) {
      data = [eventName].concat(data, uuid)
    } else {
      data = [eventName].concat(data)
    }
  }

  var length = arr.length
  for (var i = 0; i < length; i++) {
    var listener = arr[i]
    listener.apply(listener, data)
  }
}


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Room__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Stream__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__views_ViewProperties__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__views_VideoPlayer__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__ = __webpack_require__(192);








// eslint-disable-next-line
__webpack_require__(193);
// eslint-disable-next-line
__webpack_require__(195);

const EnxRtc = {
  Logger: __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */],
  EnxRoom: __WEBPACK_IMPORTED_MODULE_1__Room__["a" /* default */].bind(null, undefined, undefined),
    Event: __WEBPACK_IMPORTED_MODULE_2__Events__["a" /* Event */],
    RoomEvent: __WEBPACK_IMPORTED_MODULE_2__Events__["d" /* RoomEvent */],
    StreamEvent: __WEBPACK_IMPORTED_MODULE_2__Events__["e" /* StreamEvent */],
    EnxStream: __WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */].bind(null, undefined),
    VideoPlayer: __WEBPACK_IMPORTED_MODULE_5__views_VideoPlayer__["a" /* default */],
    ViewProperties: __WEBPACK_IMPORTED_MODULE_4__views_ViewProperties__["a" /* default */],
        disconnect: __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].disconnectRoom,
        getDevices:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].getDevice,
        switchMediaDevice:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].switchMediaDevice,
        notifyDeviceUpdate:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].notifyDeviceUpdate,
        joinRoom:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].joinRoom,
        listParticipants:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].listParticipants,
        PublishStream:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].publishStream,
        sendMessage:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].sendMessage,
        receiveMessage:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].ReceiveMessage,
        startAudio:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].StartAudio,
        startRecord:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].StartRecord,
        startScreenShare:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].startScreenShare,
        startVideo:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].StartVideo,
        stopAudio:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].StopAudio,
        stopRecord:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].StopRecord,
        stopVideo:__WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].StopVideo,
};

/* harmony default export */ __webpack_exports__["default"] = (EnxRtc);


/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 20,
	"./af.js": 20,
	"./ar": 21,
	"./ar-dz": 22,
	"./ar-dz.js": 22,
	"./ar-kw": 23,
	"./ar-kw.js": 23,
	"./ar-ly": 24,
	"./ar-ly.js": 24,
	"./ar-ma": 25,
	"./ar-ma.js": 25,
	"./ar-sa": 26,
	"./ar-sa.js": 26,
	"./ar-tn": 27,
	"./ar-tn.js": 27,
	"./ar.js": 21,
	"./az": 28,
	"./az.js": 28,
	"./be": 29,
	"./be.js": 29,
	"./bg": 30,
	"./bg.js": 30,
	"./bm": 31,
	"./bm.js": 31,
	"./bn": 32,
	"./bn.js": 32,
	"./bo": 33,
	"./bo.js": 33,
	"./br": 34,
	"./br.js": 34,
	"./bs": 35,
	"./bs.js": 35,
	"./ca": 36,
	"./ca.js": 36,
	"./cs": 37,
	"./cs.js": 37,
	"./cv": 38,
	"./cv.js": 38,
	"./cy": 39,
	"./cy.js": 39,
	"./da": 40,
	"./da.js": 40,
	"./de": 41,
	"./de-at": 42,
	"./de-at.js": 42,
	"./de-ch": 43,
	"./de-ch.js": 43,
	"./de.js": 41,
	"./dv": 44,
	"./dv.js": 44,
	"./el": 45,
	"./el.js": 45,
	"./en-SG": 46,
	"./en-SG.js": 46,
	"./en-au": 47,
	"./en-au.js": 47,
	"./en-ca": 48,
	"./en-ca.js": 48,
	"./en-gb": 49,
	"./en-gb.js": 49,
	"./en-ie": 50,
	"./en-ie.js": 50,
	"./en-il": 51,
	"./en-il.js": 51,
	"./en-nz": 52,
	"./en-nz.js": 52,
	"./eo": 53,
	"./eo.js": 53,
	"./es": 54,
	"./es-do": 55,
	"./es-do.js": 55,
	"./es-us": 56,
	"./es-us.js": 56,
	"./es.js": 54,
	"./et": 57,
	"./et.js": 57,
	"./eu": 58,
	"./eu.js": 58,
	"./fa": 59,
	"./fa.js": 59,
	"./fi": 60,
	"./fi.js": 60,
	"./fo": 61,
	"./fo.js": 61,
	"./fr": 62,
	"./fr-ca": 63,
	"./fr-ca.js": 63,
	"./fr-ch": 64,
	"./fr-ch.js": 64,
	"./fr.js": 62,
	"./fy": 65,
	"./fy.js": 65,
	"./ga": 66,
	"./ga.js": 66,
	"./gd": 67,
	"./gd.js": 67,
	"./gl": 68,
	"./gl.js": 68,
	"./gom-latn": 69,
	"./gom-latn.js": 69,
	"./gu": 70,
	"./gu.js": 70,
	"./he": 71,
	"./he.js": 71,
	"./hi": 72,
	"./hi.js": 72,
	"./hr": 73,
	"./hr.js": 73,
	"./hu": 74,
	"./hu.js": 74,
	"./hy-am": 75,
	"./hy-am.js": 75,
	"./id": 76,
	"./id.js": 76,
	"./is": 77,
	"./is.js": 77,
	"./it": 78,
	"./it-ch": 79,
	"./it-ch.js": 79,
	"./it.js": 78,
	"./ja": 80,
	"./ja.js": 80,
	"./jv": 81,
	"./jv.js": 81,
	"./ka": 82,
	"./ka.js": 82,
	"./kk": 83,
	"./kk.js": 83,
	"./km": 84,
	"./km.js": 84,
	"./kn": 85,
	"./kn.js": 85,
	"./ko": 86,
	"./ko.js": 86,
	"./ku": 87,
	"./ku.js": 87,
	"./ky": 88,
	"./ky.js": 88,
	"./lb": 89,
	"./lb.js": 89,
	"./lo": 90,
	"./lo.js": 90,
	"./lt": 91,
	"./lt.js": 91,
	"./lv": 92,
	"./lv.js": 92,
	"./me": 93,
	"./me.js": 93,
	"./mi": 94,
	"./mi.js": 94,
	"./mk": 95,
	"./mk.js": 95,
	"./ml": 96,
	"./ml.js": 96,
	"./mn": 97,
	"./mn.js": 97,
	"./mr": 98,
	"./mr.js": 98,
	"./ms": 99,
	"./ms-my": 100,
	"./ms-my.js": 100,
	"./ms.js": 99,
	"./mt": 101,
	"./mt.js": 101,
	"./my": 102,
	"./my.js": 102,
	"./nb": 103,
	"./nb.js": 103,
	"./ne": 104,
	"./ne.js": 104,
	"./nl": 105,
	"./nl-be": 106,
	"./nl-be.js": 106,
	"./nl.js": 105,
	"./nn": 107,
	"./nn.js": 107,
	"./pa-in": 108,
	"./pa-in.js": 108,
	"./pl": 109,
	"./pl.js": 109,
	"./pt": 110,
	"./pt-br": 111,
	"./pt-br.js": 111,
	"./pt.js": 110,
	"./ro": 112,
	"./ro.js": 112,
	"./ru": 113,
	"./ru.js": 113,
	"./sd": 114,
	"./sd.js": 114,
	"./se": 115,
	"./se.js": 115,
	"./si": 116,
	"./si.js": 116,
	"./sk": 117,
	"./sk.js": 117,
	"./sl": 118,
	"./sl.js": 118,
	"./sq": 119,
	"./sq.js": 119,
	"./sr": 120,
	"./sr-cyrl": 121,
	"./sr-cyrl.js": 121,
	"./sr.js": 120,
	"./ss": 122,
	"./ss.js": 122,
	"./sv": 123,
	"./sv.js": 123,
	"./sw": 124,
	"./sw.js": 124,
	"./ta": 125,
	"./ta.js": 125,
	"./te": 126,
	"./te.js": 126,
	"./tet": 127,
	"./tet.js": 127,
	"./tg": 128,
	"./tg.js": 128,
	"./th": 129,
	"./th.js": 129,
	"./tl-ph": 130,
	"./tl-ph.js": 130,
	"./tlh": 131,
	"./tlh.js": 131,
	"./tr": 132,
	"./tr.js": 132,
	"./tzl": 133,
	"./tzl.js": 133,
	"./tzm": 134,
	"./tzm-latn": 135,
	"./tzm-latn.js": 135,
	"./tzm.js": 134,
	"./ug-cn": 136,
	"./ug-cn.js": 136,
	"./uk": 137,
	"./uk.js": 137,
	"./ur": 138,
	"./ur.js": 138,
	"./uz": 139,
	"./uz-latn": 140,
	"./uz-latn.js": 140,
	"./uz.js": 139,
	"./vi": 141,
	"./vi.js": 141,
	"./x-pseudo": 142,
	"./x-pseudo.js": 142,
	"./yo": 143,
	"./yo.js": 143,
	"./zh-cn": 144,
	"./zh-cn.js": 144,
	"./zh-hk": 145,
	"./zh-hk.js": 145,
	"./zh-tw": 146,
	"./zh-tw.js": 146
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 161;

/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseStack__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Logger__ = __webpack_require__(1);




const ChromeStableStack = (specInput) => {
  __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info('Starting Chrome stable stack', specInput);
  const spec = specInput;
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__BaseStack__["a" /* default */])(specInput);
  const defaultSimulcastSpatialLayers = 2;

  that.enableSimulcast = (sdpInput) => {
    let result;
    let sdp = sdpInput;
    if (!spec.video) {
      return sdp;
    }
    if (!spec.simulcast) {
      return sdp;
    }
    that.simulcast = spec.simulcast;

    // TODO(javier): Improve the way we check for current video ssrcs
    const matchGroup = sdp.match(/a=ssrc-group:FID ([0-9]*) ([0-9]*)\r?\n/);
    if (!matchGroup || (matchGroup.length <= 0)) {
      return sdp;
    }
    // TODO (pedro): Consider adding these to SdpHelpers
    const numSpatialLayers = spec.simulcast.numSpatialLayers || defaultSimulcastSpatialLayers;
    const baseSsrc = parseInt(matchGroup[1], 10);
    const baseSsrcRtx = parseInt(matchGroup[2], 10);
    const cname = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} cname:(.*)\r?\n`))[1];
    const msid = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} msid:(.*)\r?\n`))[1];
    const mslabel = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} mslabel:(.*)\r?\n`))[1];
    const label = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} label:(.*)\r?\n`))[1];

    sdp.match(new RegExp(`a=ssrc:${matchGroup[1]}.*\r?\n`, 'g')).forEach((line) => {
      sdp = sdp.replace(line, '');
    });
    sdp.match(new RegExp(`a=ssrc:${matchGroup[2]}.*\r?\n`, 'g')).forEach((line) => {
      sdp = sdp.replace(line, '');
    });

    const spatialLayers = [baseSsrc];
    const spatialLayersRtx = [baseSsrcRtx];

    for (let i = 1; i < numSpatialLayers; i += 1) {
      spatialLayers.push(baseSsrc + (i * 1000));
      spatialLayersRtx.push(baseSsrcRtx + (i * 1000));
    }

    result = __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].addSim(spatialLayers);
    let spatialLayerId;
    let spatialLayerIdRtx;
    for (let i = 0; i < spatialLayers.length; i += 1) {
      spatialLayerId = spatialLayers[i];
      spatialLayerIdRtx = spatialLayersRtx[i];
      result += __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].addGroup(spatialLayerId, spatialLayerIdRtx);
    }

    for (let i = 0; i < spatialLayers.length; i += 1) {
      spatialLayerId = spatialLayers[i];
      spatialLayerIdRtx = spatialLayersRtx[i];
      result += __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].addSpatialLayer(cname,
        msid, mslabel, label, spatialLayerId, spatialLayerIdRtx);
    }
    result += 'a=x-google-flag:conference\r\n';
    return sdp.replace(matchGroup[0], result);
  };
  const setBitrateForVideoLayers = (sender) => {
    if (typeof sender.getParameters !== 'function' || typeof sender.setParameters !== 'function') {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].warning('Cannot set simulcast layers bitrate: getParameters or setParameters is not available');
      return;
    }
    const parameters = sender.getParameters();
    Object.keys(that.simulcast.spatialLayerBitrates).forEach((key) => {
      if (parameters.encodings[key] !== undefined) {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error(`Setting bitrate for layer ${key}, bps: ${that.simulcast.spatialLayerBitrates[key]}`);
        parameters.encodings[key].maxBitrate = that.simulcast.spatialLayerBitrates[key];
      }
    });
    sender.setParameters(parameters)
      .then((result) => {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info('Success setting simulcast layer bitrates', result);
      })
      .catch((e) => {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].warning('Error setting simulcast layer bitrates', e);
      });
  };

  that.setSimulcastLayersBitrate = () => {
    if (that.simulcast && that.simulcast.spatialLayerBitrates) {
      that.peerConnection.getSenders().forEach((sender) => {
        if (sender.track.kind === 'video') {
          setBitrateForVideoLayers(sender);
        }
      });
    }
  };
  that.setStartVideoBW = (sdpInfo) => {
    if (that.video && spec.startVideoBW) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug(`startVideoBW requested: ${spec.startVideoBW}`);
      __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].setParamForCodecs(sdpInfo, 'video', 'x-google-start-bitrate', spec.startVideoBW);
    }
  };

  that.setHardMinVideoBW = (sdpInfo) => {
    if (that.video && spec.hardMinVideoBW) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug(`hardMinVideoBW requested: ${spec.hardMinVideoBW}`);
      __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].setParamForCodecs(sdpInfo, 'video', 'x-google-min-bitrate', spec.hardMinVideoBW);
    }
  };


  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (ChromeStableStack);


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__BaseStack__ = __webpack_require__(147);



const FirefoxStack = (specInput) => {
  __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('Starting Firefox stack');
  const that = Object(__WEBPACK_IMPORTED_MODULE_1__BaseStack__["a" /* default */])(specInput);
  const spec = specInput;

  that.enableSimulcast = (sdp) => {
    if (!spec.video || !spec.simulcast) {
      return sdp;
    }
    that.peerConnection.getSenders().forEach((sender) => {
      if (sender.track.kind === 'video') {
        sender.getParameters();
        sender.setParameters({ encodings: [{
          rid: 'spam',
          active: true,
          priority: 'high',
          maxBitrate: 40000,
          maxHeight: 640,
          maxWidth: 480 }, {
            rid: 'egg',
            active: true,
            priority: 'medium',
            maxBitrate: 10000,
            maxHeight: 320,
            maxWidth: 240 }],
        });
      }
    });
    return sdp;
  };
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (FirefoxStack);


/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(1);


const FcStack = (spec) => {
  /*
  spec.callback({
      type: sessionDescription.type,
      sdp: sessionDescription.sdp
  });
  */
  const that = {};

  that.pcConfig = {};

  that.peerConnection = {};
  that.desc = {};
  that.signalCallback = undefined;

  that.close = () => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('Close FcStack');
  };

  that.createOffer = () => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug('FCSTACK: CreateOffer');
  };

  that.addStream = (stream) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug('FCSTACK: addStream', stream);
  };
  that.addTrack = (track) =>{
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug('FCSTACK: addTrack', stream);
  };

  that.processSignalingMessage = (msg) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug('FCSTACK: processSignaling', msg);
    if (that.signalCallback !== undefined) { that.signalCallback(msg); }
  };

  that.sendSignalingMessage = (msg) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug('FCSTACK: Sending signaling Message', msg);
    spec.callback(msg);
  };

  that.setSignalingCallback = (callback = () => {}) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug('FCSTACK: Setting signalling callback');
    that.signalCallback = callback;
  };
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (FcStack);


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SocketEvent */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Socket; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_socket_io__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_socket_io___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__lib_socket_io__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__customEvents__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EventLogger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Events__ = __webpack_require__(4);
/*
This file is for handle socket events.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 28/11/2017 11:14 AM
*/

/* global */
 // This package is for fetch global event nameProp
  // This package is to use socket library functions
 // This package is for manage console log.



 // This package is needed for managing events
const SocketEvent = ( type, specInput ) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_5__Events__["a" /* Event */])({ type });
  that.args = specInput.args;
  return that; // This is a object of events handler
};

/*
 * Class Stream represents a local or a remote Stream in the Room. It will handle the WebRTC
 * stream and identify the stream and where it should be drawn.
 */
const Socket = (newIo) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_5__Events__["b" /* EventDispatcher */])();
  const defaultCallback = () => {};
  const messageBuffer = [];			// This is an array to store event message as a buffer.

  that.CONNECTED = Symbol('connected');
  that.RECONNECTING = Symbol('reconnecting');
  that.DISCONNECTED = Symbol('disconnected');

  const WEBSOCKET_NORMAL_CLOSURE = 1000; // This is a variable used to store socket closure status code in normal state
										 // This can be modified and varry denpendending on webscket closure resons
  that.state = that.DISCONNECTED;
  that.IO = newIo === undefined ? __WEBPACK_IMPORTED_MODULE_1__lib_socket_io___default.a : newIo;

  let socket;

  const emit = (type, ...args) => {           // Function that calls Events' emit function
    that.emit(SocketEvent(type, { args }));
  };

  const addToBuffer = ( type, message, callback, error ) => { // Function defination that store a message in buffer array
    messageBuffer.push( [ type, message, callback, error ] );
  };

  const removeFromBuffer = ( type, message, callback, error ) => { // Function defination that removes a message from buffer array
    var index = messageBuffer.indexOf( [ type, message, callback, error ] );
	if (index !== -1) {						// Checking : If the message sent to remove is present in buffer array or not
		messageBuffer.splice( index, 1 );
	}
  };

  const executeBuffer = () => {
    __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info('execute buffer');					// Function to send all message to connected socket stored in buffer
    if ( that.state !== that.CONNECTED ) {
      return;
    }
    messageBuffer.forEach( ( message ) => {
      that.sendMessage( ...message );
    });
  };
  const checkSSL = () =>{
    return ((window.location.protocol=='https:') ? true : false) ;

  }
  that.connect = ( token, callback = defaultCallback, error = defaultCallback ) => {
      const options = {
          reconnection: false,
        //  reconnectionAttempts: 3,
          secure: token.secure,
          forceNew: true,
          transports: ['websocket'],
          rejectUnauthorized: true
      };
      const transport = checkSSL() ? 'wss://' : 'ws://';
      var host = token.host;
      if(token.gateway == undefined || token.gateway == null || token.gateway == ""){
          host = token.host;
      }else{
          host = token.gateway;
          options["query"] = 'X-Forwarded-Host='+token.host;
      }
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info('Connecting socket with option:- '+JSON.stringify(options));
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].info('Connecting socket with host:- '+host);
      socket = that.IO.connect( transport + host, options );

    // Hack to know the exact reason of the WS closure (socket.io does not publish it)
    let closeCode = WEBSOCKET_NORMAL_CLOSURE;
    const socketOnCloseFunction = socket.io.engine.transport.ws.onclose;
    socket.io.engine.transport.ws.onclose = ( closeEvent ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].warning( 'WebSocket closed, code:', closeEvent.code );
      closeCode = closeEvent.code;
      socketOnCloseFunction( closeEvent );
    };
      socket.io.engine.transport.ws.onerror = ( errorEvent ) => {
      };
    that.socket = socket;

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_awaited,emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_awaited ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_joined,emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_joined ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_connected,emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_connected ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.new_active_talker,emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.new_active_talker ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onAddStream,emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onAddStream ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.signaling_message_peer, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.signaling_message_peer ) );
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.publish_me, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.publish_me ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.unpublish_me, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.unpublish_me ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onBandwidthAlert, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onBandwidthAlert ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onSelfBandwidthAlert, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onSelfBandwidthAlert ));
	  socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onRemoveTrack, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onRemoveTrack ));
    // We receive an event of new data in one of the streams
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onDataStream, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onDataStream ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_awaited,              emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_awaited ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_record_on,            emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_record_on ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_record_off,           emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.room_record_off ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_mute_audio,           emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_mute_audio ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_unmute_audio,         emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_unmute_audio ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_mute_video,           emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_mute_video ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_unmute_video,         emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.hard_unmute_video ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.share_started,             emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.share_started ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.share_stopped,             emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.share_stopped ));

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.canvas_started,             emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.canvas_started ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.canvas_stopped,             emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.canvas_stopped ));

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_audio_muted,          emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_audio_muted ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_audio_unmuted,        emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_audio_unmuted ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_video_muted,          emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_video_muted ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_video_unmuted,        emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].UserEvent.user_video_unmuted ));

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.media_engine_connecting, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.media_engine_connecting ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onUpdateAttributeStream, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onUpdateAttributeStream ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onRemoveStream,          emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onRemoveStream ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.user_connected,          emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.user_connected ));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.user_disconnected,       emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.user_disconnected));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.user_subscribed,         emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.user_subscribed));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_requested,         emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_requested));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_granted,           emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_granted));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_not_granted,       emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_not_granted));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_released,          emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.floor_released));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.hard_mute,               emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.hard_mute));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.hard_mute_room,          emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.hard_mute_room));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.hard_unmute_room,        emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.hard_unmute_room));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.switched_room,           emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.switched_room));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.data_stream_room,           emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.data_stream_room));
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.user_role_changed,       emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.user_role_changed));
    // manu stats
    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onStatSubscription, emit.bind( that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.onStatSubscription ));
      socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.switch_codec,           emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.switch_codec));
      socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.generic_events,       emit.bind(that,__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].RoomEvent.generic_events));

      socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.disconnect, ( reason ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.disconnect, that.id, reason );
      if ( closeCode !== WEBSOCKET_NORMAL_CLOSURE ) {
        socket.close();
        emit( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.disconnect, reason );
        return ;
      /*  emit( VcxEventProperties.SocketEvent.disconnect, reason );
        that.state = that.RECONNECTING;
        return;  */
      }
      socket.close();
      emit( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.disconnect, reason );
    });

		/*  From here starts hadling different socket events which are called on socket   */
	socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.connect_timeout, ( err ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].warning( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.connect_timeout + ', id:', that.id, ', error:', err.message );
      socket.close();
      emit( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.disconnect, err.message );
      return ;
    });

	socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.connection_failed, () => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.connection_failed + ', id:', that.id );
      emit( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.connection_failed, { streamId: that.id });
    });

	socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.connect_error, ( err ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].warning( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.connect_error + ', id:', that.id, ', error:', err.message );
    });

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.error, (err) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].warning( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.error + ', id:', that.id, ', error:', err.message );
      emit( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.error );
    });

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnecting, ( attemptNumber ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnecting + ', id:', that.id, ', attempet:', attemptNumber );
    });

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect, ( attemptNumber ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnected + ', id:', that.id, ', attempet:', attemptNumber );
      that.state = that.CONNECTED;
      socket.emit( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnected, that.id );
      executeBuffer();
    });

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect_attempt, ( attemptNumber ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect_attempt + ', id:', that.id, ', attempet:', attemptNumber );
    });

	socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect_failed, () => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].warning( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect_failed + ', id:', that.id );
      that.state = that.DISCONNECTED;
      emit( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.disconnect, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect_failed );
    });

    socket.on( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect_error, ( err ) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug( __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties_js__["a" /* default */].SocketEvent.reconnect_error + ', id:', that.id, ', error:', err.message );
    });

    // First message with the token to the connected socket
    that.sendMessage( 'token', token, ( response ) => {
      that.state = that.CONNECTED;
      that.id = response.clientId;
      callback( response );
    }, error );
  };

  that.disconnect = () => {
    __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug('socket js disconnect the socket');
    that.state = that.DISCONNECTED;
    socket.disconnect();
  };

  // Function to send a message to the server socket using socket.io
  that.sendMessage = ( type, msg, callback = defaultCallback, error = defaultCallback ) => {
    if ( that.state === that.DISCONNECTED && type !== 'token' ) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error( 'Trying to send a message over a disconnected Socket' );
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, {type: type, error: 'Trying to send a message over a disconnected Socket'});
      return;
    }
    if ( that.state === that.RECONNECTING ) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].debug('sendmessage socket state is reconnecting');
      addToBuffer( type, msg, callback, error );
      return;
    }

    if(msg) {
        socket.emit(type, msg, (respType, resp) => {
            if (respType === 'success') {
                callback(resp);
            } else if (respType === 'error') {
                __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, {type: type, respType: respType, resp: resp});
                error(resp);
            } else {
                callback(respType, resp);
            }
        });
    }
  };

  // It sends a SDP message to the server using socket.io
  that.sendSDP = ( type, options, sdp, callback = defaultCallback ) => {
    if ( that.state === that.DISCONNECTED ) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error( 'Trying to send a message over a disconnected Socket' );
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, {error: 'Trying to send a message over a disconnected Socket'});
      return;
    }
    socket.emit( type, options, sdp, ( response, respCallback ) => {
      callback( response, respCallback );
    });
  };
  that.emitEvent = ( type, options, callback = defaultCallback ) => {
    if ( that.state === that.DISCONNECTED ) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error( 'Trying to send a message over a disconnected Socket' );
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, {error: 'Trying to send a message over a disconnected Socket'});
      return;
    }
    socket.emit( type, options,( response, respCallback ) => {
      callback( response, respCallback );
    });
  };


    that.sendEvent = ( type, callback = defaultCallback ) => {
        if ( that.state === that.DISCONNECTED ) {
            __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error( 'Trying to send a message over a disconnected Socket' );
            __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, {error: 'Trying to send a message over a disconnected Socket'});
            return;
        }
        socket.emit( type,(response) => {
             callback( response);
            });
    };
	that.sendParamEvent = ( type,clientId,callback = defaultCallback ) => {
        if ( that.state === that.DISCONNECTED ) {
            __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["a" /* default */].error( 'Trying to send a message over a disconnected Socket' );
            __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, {error: 'Trying to send a message over a disconnected Socket'});
            return;
        }
        socket.emit( type,clientId,(response) => {
             callback( response);
            });
    };
  return that;
};



/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){"use strict";function r(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var n,r=i(t),s=r.source,u=r.id,h=r.path,f=p[u]&&h in p[u].nsps,l=e.forceNew||e["force new connection"]||!1===e.multiplex||f;return l?(c("ignoring socket cache for %s",s),n=a(s,e)):(p[u]||(c("new io instance for %s",s),p[u]=a(s,e)),n=p[u]),r.query&&!e.query&&(e.query=r.query),n.socket(r.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(1),s=n(7),a=n(13),c=n(3)("socket.io-client");t.exports=e=r;var p=e.managers={};e.protocol=s.protocol,e.connect=r,e.Manager=n(13),e.Socket=n(39)},function(t,e,n){(function(e){"use strict";function r(t,n){var r=t;n=n||e.location,null==t&&(t=n.protocol+"//"+n.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?n.protocol+t:n.host+t),/^(https?|wss?):\/\//.test(t)||(i("protocol-less url %s",t),t="undefined"!=typeof n?n.protocol+"//"+t:"https://"+t),i("parse %s",t),r=o(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";var s=r.host.indexOf(":")!==-1,a=s?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+a+":"+r.port,r.href=r.protocol+"://"+a+(n&&n.port===r.port?"":":"+r.port),r}var o=n(2),i=n(3)("socket.io-client:url");t.exports=r}).call(e,function(){return this}())},function(t,e){var n=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,r=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=n.exec(t||""),a={},c=14;c--;)a[r[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e,n){(function(r){function o(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?"%c":"")+this.namespace+(n?" %c":" ")+t[0]+(n?"%c ":" ")+"+"+e.humanize(this.diff),n){var r="color: "+this.color;t.splice(1,0,r,"color: inherit");var o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,function(t){"%%"!==t&&(o++,"%c"===t&&(i=o))}),t.splice(i,0,r)}}function s(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function a(t){try{null==t?e.storage.removeItem("debug"):e.storage.debug=t}catch(n){}}function c(){var t;try{t=e.storage.debug}catch(n){}return!t&&"undefined"!=typeof r&&"env"in r&&(t=r.env.DEBUG),t}function p(){try{return window.localStorage}catch(t){}}e=t.exports=n(5),e.log=s,e.formatArgs=i,e.save=a,e.load=c,e.useColors=o,e.storage="undefined"!=typeof chrome&&"undefined"!=typeof chrome.storage?chrome.storage.local:p(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},e.enable(c())}).call(e,n(4))},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function o(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function i(t){if(h===clearTimeout)return clearTimeout(t);if((h===r||!h)&&clearTimeout)return h=clearTimeout,clearTimeout(t);try{return h(t)}catch(e){try{return h.call(null,t)}catch(e){return h.call(this,t)}}}function s(){y&&l&&(y=!1,l.length?d=l.concat(d):m=-1,d.length&&a())}function a(){if(!y){var t=o(s);y=!0;for(var e=d.length;e;){for(l=d,d=[];++m<e;)l&&l[m].run();m=-1,e=d.length}l=null,y=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function p(){}var u,h,f=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n}catch(t){u=n}try{h="function"==typeof clearTimeout?clearTimeout:r}catch(t){h=r}}();var l,d=[],y=!1,m=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];d.push(new c(t,e)),1!==d.length||y||o(a)},c.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=p,f.addListener=p,f.once=p,f.off=p,f.removeListener=p,f.removeAllListeners=p,f.emit=p,f.prependListener=p,f.prependOnceListener=p,f.listeners=function(t){return[]},f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e,n){function r(t){var n,r=0;for(n in t)r=(r<<5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function o(t){function n(){if(n.enabled){var t=n,r=+new Date,o=r-(p||r);t.diff=o,t.prev=p,t.curr=r,p=r;for(var i=new Array(arguments.length),s=0;s<i.length;s++)i[s]=arguments[s];i[0]=e.coerce(i[0]),"string"!=typeof i[0]&&i.unshift("%O");var a=0;i[0]=i[0].replace(/%([a-zA-Z%])/g,function(n,r){if("%%"===n)return n;a++;var o=e.formatters[r];if("function"==typeof o){var s=i[a];n=o.call(t,s),i.splice(a,1),a--}return n}),e.formatArgs.call(t,i);var c=n.log||e.log||console.log.bind(console);c.apply(t,i)}}return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),"function"==typeof e.init&&e.init(n),n}function i(t){e.save(t),e.names=[],e.skips=[];for(var n=("string"==typeof t?t:"").split(/[\s,]+/),r=n.length,o=0;o<r;o++)n[o]&&(t=n[o].replace(/\*/g,".*?"),"-"===t[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")))}function s(){e.enable("")}function a(t){var n,r;for(n=0,r=e.skips.length;n<r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n<r;n++)if(e.names[n].test(t))return!0;return!1}function c(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=o.debug=o["default"]=o,e.coerce=c,e.disable=s,e.enable=i,e.enabled=a,e.humanize=n(6),e.names=[],e.skips=[],e.formatters={};var p},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return n*u;case"days":case"day":case"d":return n*p;case"hours":case"hour":case"hrs":case"hr":case"h":return n*c;case"minutes":case"minute":case"mins":case"min":case"m":return n*a;case"seconds":case"second":case"secs":case"sec":case"s":return n*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return n;default:return}}}}function r(t){return t>=p?Math.round(t/p)+"d":t>=c?Math.round(t/c)+"h":t>=a?Math.round(t/a)+"m":t>=s?Math.round(t/s)+"s":t+"ms"}function o(t){return i(t,p,"day")||i(t,c,"hour")||i(t,a,"minute")||i(t,s,"second")||t+" ms"}function i(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+" "+n:Math.ceil(t/e)+" "+n+"s"}var s=1e3,a=60*s,c=60*a,p=24*c,u=365.25*p;t.exports=function(t,e){e=e||{};var i=typeof t;if("string"===i&&t.length>0)return n(t);if("number"===i&&isNaN(t)===!1)return e["long"]?o(t):r(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,n){function r(){}function o(t){var n=""+t.type;return e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(n+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(n+=t.nsp+","),null!=t.id&&(n+=t.id),null!=t.data&&(n+=JSON.stringify(t.data)),h("encoded %j as %s",t,n),n}function i(t,e){function n(t){var n=d.deconstructPacket(t),r=o(n.packet),i=n.buffers;i.unshift(r),e(i)}d.removeBlobs(t,n)}function s(){this.reconstructor=null}function a(t){var n=0,r={type:Number(t.charAt(0))};if(null==e.types[r.type])return u();if(e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type){for(var o="";"-"!==t.charAt(++n)&&(o+=t.charAt(n),n!=t.length););if(o!=Number(o)||"-"!==t.charAt(n))throw new Error("Illegal attachments");r.attachments=Number(o)}if("/"===t.charAt(n+1))for(r.nsp="";++n;){var i=t.charAt(n);if(","===i)break;if(r.nsp+=i,n===t.length)break}else r.nsp="/";var s=t.charAt(n+1);if(""!==s&&Number(s)==s){for(r.id="";++n;){var i=t.charAt(n);if(null==i||Number(i)!=i){--n;break}if(r.id+=t.charAt(n),n===t.length)break}r.id=Number(r.id)}return t.charAt(++n)&&(r=c(r,t.substr(n))),h("decoded %s as %j",t,r),r}function c(t,e){try{t.data=JSON.parse(e)}catch(n){return u()}return t}function p(t){this.reconPack=t,this.buffers=[]}function u(){return{type:e.ERROR,data:"parser error"}}var h=n(3)("socket.io-parser"),f=n(8),l=n(9),d=n(11),y=n(12);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=r,e.Decoder=s,r.prototype.encode=function(t,n){if(t.type!==e.EVENT&&t.type!==e.ACK||!l(t.data)||(t.type=t.type===e.EVENT?e.BINARY_EVENT:e.BINARY_ACK),h("encoding packet %j",t),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)i(t,n);else{var r=o(t);n([r])}},f(s.prototype),s.prototype.add=function(t){var n;if("string"==typeof t)n=a(t),e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type?(this.reconstructor=new p(n),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",n)):this.emit("decoded",n);else{if(!y(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");n=this.reconstructor.takeBinaryData(t),n&&(this.reconstructor=null,this.emit("decoded",n))}},s.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},p.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=d.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,n){function r(t){if(t)return o(t)}function o(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r,o=0;o<n.length;o++)if(r=n[o],r===e||r.fn===e){n.splice(o,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks["$"+t];if(n){n=n.slice(0);for(var r=0,o=n.length;r<o;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){(function(e){function r(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var n=0,i=t.length;n<i;n++)if(r(t[n]))return!0;return!1}if("function"==typeof e.Buffer&&e.Buffer.isBuffer&&e.Buffer.isBuffer(t)||"function"==typeof e.ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return r(t.toJSON(),!0);for(var c in t)if(Object.prototype.hasOwnProperty.call(t,c)&&r(t[c]))return!0;return!1}var o=n(10),i=Object.prototype.toString,s="function"==typeof e.Blob||"[object BlobConstructor]"===i.call(e.Blob),a="function"==typeof e.File||"[object FileConstructor]"===i.call(e.File);t.exports=r}).call(e,function(){return this}())},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e,n){(function(t){function r(t,e){if(!t)return t;if(s(t)){var n={_placeholder:!0,num:e.length};return e.push(t),n}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=r(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=r(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var n=0;n<t.length;n++)t[n]=o(t[n],e);else if("object"==typeof t)for(var r in t)t[r]=o(t[r],e);return t}var i=n(10),s=n(12),a=Object.prototype.toString,c="function"==typeof t.Blob||"[object BlobConstructor]"===a.call(t.Blob),p="function"==typeof t.File||"[object FileConstructor]"===a.call(t.File);e.deconstructPacket=function(t){var e=[],n=t.data,o=t;return o.data=r(n,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function n(t,a,u){if(!t)return t;if(c&&t instanceof Blob||p&&t instanceof File){r++;var h=new FileReader;h.onload=function(){u?u[a]=this.result:o=this.result,--r||e(o)},h.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)n(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)n(t[l],l,t)}var r=0,o=t;n(o),r||e(o)}}).call(e,function(){return this}())},function(t,e){(function(e){function n(t){return e.Buffer&&e.Buffer.isBuffer(t)||e.ArrayBuffer&&t instanceof ArrayBuffer}t.exports=n}).call(e,function(){return this}())},function(t,e,n){"use strict";function r(t,e){if(!(this instanceof r))return new r(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new l({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var n=e.parser||c;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(14),s=n(39),a=n(8),c=n(7),p=n(41),u=n(42),h=n(3)("socket.io-client:manager"),f=n(37),l=n(43),d=Object.prototype.hasOwnProperty;t.exports=r,r.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)d.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},r.prototype.updateSocketIds=function(){for(var t in this.nsps)d.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},r.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(r.prototype),r.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},r.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},r.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},r.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},r.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},r.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},r.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},r.prototype.open=r.prototype.connect=function(t,e){if(h("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;h("opening %s",this.uri),this.engine=i(this.uri,this.opts);var n=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var o=p(n,"open",function(){r.onopen(),t&&t()}),s=p(n,"error",function(e){if(h("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",e),t){var n=new Error("Connection error");n.data=e,t(n)}else r.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout;h("connect attempt will timeout after %d",a);var c=setTimeout(function(){h("connect attempt timed out after %d",a),o.destroy(),n.close(),n.emit("error","timeout"),r.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},r.prototype.onopen=function(){h("open"),this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(p(t,"data",u(this,"ondata"))),this.subs.push(p(t,"ping",u(this,"onping"))),this.subs.push(p(t,"pong",u(this,"onpong"))),this.subs.push(p(t,"error",u(this,"onerror"))),this.subs.push(p(t,"close",u(this,"onclose"))),this.subs.push(p(this.decoder,"decoded",u(this,"ondecoded")))},r.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},r.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},r.prototype.ondata=function(t){this.decoder.add(t)},r.prototype.ondecoded=function(t){this.emit("packet",t)},r.prototype.onerror=function(t){h("error",t),this.emitAll("error",t)},r.prototype.socket=function(t,e){function n(){~f(o.connecting,r)||o.connecting.push(r)}var r=this.nsps[t];if(!r){r=new s(this,t,e),this.nsps[t]=r;var o=this;r.on("connecting",n),r.on("connect",function(){r.id=o.generateId(t)}),this.autoConnect&&n()}return r},r.prototype.destroy=function(t){var e=f(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},r.prototype.packet=function(t){h("writing packet %j",t);var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(n){for(var r=0;r<n.length;r++)e.engine.write(n[r],t.options);e.encoding=!1,e.processPacketQueue()}))},r.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},r.prototype.cleanup=function(){h("cleanup");for(var t=this.subs.length,e=0;e<t;e++){var n=this.subs.shift();n.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},r.prototype.close=r.prototype.disconnect=function(){h("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},r.prototype.onclose=function(t){h("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},r.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)h("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();h("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var n=setTimeout(function(){t.skipReconnect||(h("attempting reconnect"),t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(h("reconnect attempt error"),t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):(h("reconnect success"),t.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(n)}})}},r.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,n){t.exports=n(15)},function(t,e,n){t.exports=n(16),t.exports.parser=n(23)},function(t,e,n){(function(e){function r(t,n){if(!(this instanceof r))return new r(t,n);n=n||{},t&&"object"==typeof t&&(n=t,t=null),t?(t=u(t),n.hostname=t.host,n.secure="https"===t.protocol||"wss"===t.protocol,n.port=t.port,t.query&&(n.query=t.query)):n.host&&(n.hostname=u(n.host).host),this.secure=null!=n.secure?n.secure:e.location&&"https:"===location.protocol,n.hostname&&!n.port&&(n.port=this.secure?"443":"80"),this.agent=n.agent||!1,this.hostname=n.hostname||(e.location?location.hostname:"localhost"),this.port=n.port||(e.location&&location.port?location.port:this.secure?443:80),this.query=n.query||{},"string"==typeof this.query&&(this.query=f.decode(this.query)),this.upgrade=!1!==n.upgrade,this.path=(n.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!n.forceJSONP,this.jsonp=!1!==n.jsonp,this.forceBase64=!!n.forceBase64,this.enablesXDR=!!n.enablesXDR,this.timestampParam=n.timestampParam||"t",this.timestampRequests=n.timestampRequests,this.transports=n.transports||["polling","websocket"],this.transportOptions=n.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=n.policyPort||843,this.rememberUpgrade=n.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=n.onlyBinaryUpgrades,this.perMessageDeflate=!1!==n.perMessageDeflate&&(n.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=n.pfx||null,this.key=n.key||null,this.passphrase=n.passphrase||null,this.cert=n.cert||null,this.ca=n.ca||null,this.ciphers=n.ciphers||null,this.rejectUnauthorized=void 0===n.rejectUnauthorized||n.rejectUnauthorized,this.forceNode=!!n.forceNode;var o="object"==typeof e&&e;o.global===o&&(n.extraHeaders&&Object.keys(n.extraHeaders).length>0&&(this.extraHeaders=n.extraHeaders),n.localAddress&&(this.localAddress=n.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e}var i=n(17),s=n(8),a=n(3)("engine.io-client:socket"),c=n(37),p=n(23),u=n(2),h=n(38),f=n(31);t.exports=r,r.priorWebsocketSuccess=!1,s(r.prototype),r.protocol=p.protocol,r.Socket=r,r.Transport=n(22),r.transports=n(17),r.parser=n(23),r.prototype.createTransport=function(t){a('creating transport "%s"',t);var e=o(this.query);e.EIO=p.protocol,e.transport=t;var n=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var r=new i[t]({query:e,socket:this,agent:n.agent||this.agent,hostname:n.hostname||this.hostname,port:n.port||this.port,secure:n.secure||this.secure,path:n.path||this.path,forceJSONP:n.forceJSONP||this.forceJSONP,jsonp:n.jsonp||this.jsonp,forceBase64:n.forceBase64||this.forceBase64,enablesXDR:n.enablesXDR||this.enablesXDR,timestampRequests:n.timestampRequests||this.timestampRequests,timestampParam:n.timestampParam||this.timestampParam,policyPort:n.policyPort||this.policyPort,pfx:n.pfx||this.pfx,key:n.key||this.key,passphrase:n.passphrase||this.passphrase,cert:n.cert||this.cert,ca:n.ca||this.ca,ciphers:n.ciphers||this.ciphers,rejectUnauthorized:n.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:n.perMessageDeflate||this.perMessageDeflate,extraHeaders:n.extraHeaders||this.extraHeaders,forceNode:n.forceNode||this.forceNode,localAddress:n.localAddress||this.localAddress,requestTimeout:n.requestTimeout||this.requestTimeout,protocols:n.protocols||void 0});return r},r.prototype.open=function(){var t;if(this.rememberUpgrade&&r.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(n){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},r.prototype.setTransport=function(t){a("setting transport %s",t.name);var e=this;this.transport&&(a("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},r.prototype.probe=function(t){function e(){if(f.onlyBinaryUpgrades){var e=!this.supportsBinary&&f.transport.supportsBinary;h=h||e}h||(a('probe transport "%s" opened',t),u.send([{type:"ping",data:"probe"}]),u.once("packet",function(e){if(!h)if("pong"===e.type&&"probe"===e.data){if(a('probe transport "%s" pong',t),f.upgrading=!0,f.emit("upgrading",u),!u)return;r.priorWebsocketSuccess="websocket"===u.name,a('pausing current transport "%s"',f.transport.name),f.transport.pause(function(){h||"closed"!==f.readyState&&(a("changing transport and sending upgrade packet"),p(),f.setTransport(u),u.send([{type:"upgrade"}]),f.emit("upgrade",u),u=null,f.upgrading=!1,f.flush())})}else{a('probe transport "%s" failed',t);var n=new Error("probe error");n.transport=u.name,f.emit("upgradeError",n)}}))}function n(){h||(h=!0,p(),u.close(),u=null)}function o(e){var r=new Error("probe error: "+e);r.transport=u.name,n(),a('probe transport "%s" failed because of error: %s',t,e),f.emit("upgradeError",r)}function i(){o("transport closed")}function s(){o("socket closed")}function c(t){u&&t.name!==u.name&&(a('"%s" works - aborting "%s"',t.name,u.name),n())}function p(){u.removeListener("open",e),u.removeListener("error",o),u.removeListener("close",i),f.removeListener("close",s),f.removeListener("upgrading",c)}a('probing transport "%s"',t);var u=this.createTransport(t,{probe:1}),h=!1,f=this;r.priorWebsocketSuccess=!1,u.once("open",e),u.once("error",o),u.once("close",i),this.once("close",s),this.once("upgrading",c),u.open()},r.prototype.onOpen=function(){if(a("socket open"),this.readyState="open",r.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause){a("starting upgrade probes");for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])}},r.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(a('socket receive: type "%s", data "%s"',t.type,t.data),this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(h(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}else a('packet received with socket readyState "%s"',this.readyState)},r.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},r.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},r.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){a("writing ping packet - expecting pong within %sms",t.pingTimeout),t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},r.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},r.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},r.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(a("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},r.prototype.write=r.prototype.send=function(t,e,n){return this.sendPacket("message",t,e,n),this},r.prototype.sendPacket=function(t,e,n,r){if("function"==typeof e&&(r=e,e=void 0),"function"==typeof n&&(r=n,n=null),"closing"!==this.readyState&&"closed"!==this.readyState){n=n||{},n.compress=!1!==n.compress;var o={type:t,data:e,options:n};this.emit("packetCreate",o),this.writeBuffer.push(o),r&&this.once("flush",r),this.flush()}},r.prototype.close=function(){function t(){r.onClose("forced close"),a("socket closing - telling transport to close"),r.transport.close()}function e(){r.removeListener("upgrade",e),r.removeListener("upgradeError",e),t()}function n(){r.once("upgrade",e),r.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var r=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?n():t()}):this.upgrading?n():t()}return this},r.prototype.onError=function(t){a("socket error %j",t),r.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},r.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){a('socket close with reason: "%s"',t);var n=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),n.writeBuffer=[],n.prevBufferLen=0}},r.prototype.filterUpgrades=function(t){for(var e=[],n=0,r=t.length;n<r;n++)~c(this.transports,t[n])&&e.push(t[n]);return e}}).call(e,function(){return this}())},function(t,e,n){(function(t){function r(e){var n,r=!1,a=!1,c=!1!==e.jsonp;if(t.location){var p="https:"===location.protocol,u=location.port;u||(u=p?443:80),r=e.hostname!==location.hostname||u!==e.port,a=e.secure!==p}if(e.xdomain=r,e.xscheme=a,n=new o(e),"open"in n&&!e.forceJSONP)return new i(e);if(!c)throw new Error("JSONP disabled");return new s(e)}var o=n(18),i=n(20),s=n(34),a=n(35);e.polling=r,e.websocket=a}).call(e,function(){return this}())},function(t,e,n){(function(e){var r=n(19);t.exports=function(t){var n=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!n||r))return new XMLHttpRequest}catch(s){}try{if("undefined"!=typeof XDomainRequest&&!o&&i)return new XDomainRequest}catch(s){}if(!n)try{
return new(e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(s){}}}).call(e,function(){return this}())},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(n){t.exports=!1}},function(t,e,n){(function(e){function r(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,e.location){var n="https:"===location.protocol,r=location.port;r||(r=n?443:80),this.xd=t.hostname!==e.location.hostname||r!==t.port,this.xs=t.secure!==n}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=n(18),c=n(21),p=n(8),u=n(32),h=n(3)("engine.io-client:polling-xhr");t.exports=o,t.exports.Request=i,u(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var n="string"!=typeof t&&void 0!==t,r=this.request({method:"POST",data:t,isBinary:n}),o=this;r.on("success",e),r.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=r},o.prototype.doPoll=function(){h("xhr poll");var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},p(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var n=this.xhr=new a(t),r=this;try{h("xhr open %s: %s",this.method,this.uri),n.open(this.method,this.uri,this.async);try{if(this.extraHeaders){n.setDisableHeaderCheck&&n.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&&n.setRequestHeader(o,this.extraHeaders[o])}}catch(s){}if("POST"===this.method)try{this.isBinary?n.setRequestHeader("Content-type","application/octet-stream"):n.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(s){}try{n.setRequestHeader("Accept","*/*")}catch(s){}"withCredentials"in n&&(n.withCredentials=!0),this.requestTimeout&&(n.timeout=this.requestTimeout),this.hasXDR()?(n.onload=function(){r.onLoad()},n.onerror=function(){r.onError(n.responseText)}):n.onreadystatechange=function(){if(2===n.readyState){var t;try{t=n.getResponseHeader("Content-Type")}catch(e){}"application/octet-stream"===t&&(n.responseType="arraybuffer")}4===n.readyState&&(200===n.status||1223===n.status?r.onLoad():setTimeout(function(){r.onError(n.status)},0))},h("xhr data %s",this.data),n.send(this.data)}catch(s){return void setTimeout(function(){r.onError(s)},0)}e.document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=r:this.xhr.onreadystatechange=r,t)try{this.xhr.abort()}catch(n){}e.document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(n){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(n){this.onError(n)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof e.XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&&(e.attachEvent?e.attachEvent("onunload",s):e.addEventListener&&e.addEventListener("beforeunload",s,!1))}).call(e,function(){return this}())},function(t,e,n){function r(t){var e=t&&t.forceBase64;u&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=n(22),i=n(31),s=n(23),a=n(32),c=n(33),p=n(3)("engine.io-client:polling");t.exports=r;var u=function(){var t=n(18),e=new t({xdomain:!1});return null!=e.responseType}();a(r,o),r.prototype.name="polling",r.prototype.doOpen=function(){this.poll()},r.prototype.pause=function(t){function e(){p("paused"),n.readyState="paused",t()}var n=this;if(this.readyState="pausing",this.polling||!this.writable){var r=0;this.polling&&(p("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){p("pre-pause polling complete"),--r||e()})),this.writable||(p("we are currently writing - waiting to pause"),r++,this.once("drain",function(){p("pre-pause writing complete"),--r||e()}))}else e()},r.prototype.poll=function(){p("polling"),this.polling=!0,this.doPoll(),this.emit("poll")},r.prototype.onData=function(t){var e=this;p("polling got data %s",t);var n=function(t,n,r){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,n),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState?this.poll():p('ignoring poll - transport state "%s"',this.readyState))},r.prototype.doClose=function(){function t(){p("writing close packet"),e.write([{type:"close"}])}var e=this;"open"===this.readyState?(p("transport open - closing"),t()):(p("transport not open - deferring close"),this.once("open",t))},r.prototype.write=function(t){var e=this;this.writable=!1;var n=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,n)})},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",n="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(n=":"+this.port),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t}},function(t,e,n){function r(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=n(23),i=n(8);t.exports=r,i(r.prototype),r.prototype.onError=function(t,e){var n=new Error(t);return n.type="TransportError",n.description=e,this.emit("error",n),this},r.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},r.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},r.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},r.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},r.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},r.prototype.onPacket=function(t){this.emit("packet",t)},r.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,n){(function(t){function r(t,n){var r="b"+e.packets[t.type]+t.data.data;return n(r)}function o(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return r(s.buffer)}function i(t,n,r){if(!n)return e.encodeBase64Packet(t,r);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,n,!0,r)},o.readAsArrayBuffer(t.data)}function s(t,n,r){if(!n)return e.encodeBase64Packet(t,r);if(g)return i(t,n,r);var o=new Uint8Array(1);o[0]=v[t.type];var s=new k([o.buffer,t.data]);return r(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(e){return!1}return t}function c(t,e,n){for(var r=new Array(t.length),o=l(t.length,n),i=function(t,n,o){e(n,function(e,n){r[t]=n,o(e,r)})},s=0;s<t.length;s++)i(s,t[s],o)}var p,u=n(24),h=n(9),f=n(25),l=n(26),d=n(27);t&&t.ArrayBuffer&&(p=n(29));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=u(v),w={type:"error",data:"parser error"},k=n(30);e.encodePacket=function(e,n,i,a){"function"==typeof n&&(a=n,n=!1),"function"==typeof i&&(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&&c instanceof ArrayBuffer)return o(e,n,a);if(k&&c instanceof t.Blob)return s(e,n,a);if(c&&c.base64)return r(e,a);var p=v[e.type];return void 0!==e.data&&(p+=i?d.encode(String(e.data),{strict:!1}):String(e.data)),a(""+p)},e.encodeBase64Packet=function(n,r){var o="b"+e.packets[n.type];if(k&&n.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];r(o+t)},i.readAsDataURL(n.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(n.data))}catch(a){for(var c=new Uint8Array(n.data),p=new Array(c.length),u=0;u<c.length;u++)p[u]=c[u];s=String.fromCharCode.apply(null,p)}return o+=t.btoa(s),r(o)},e.decodePacket=function(t,n,r){if(void 0===t)return w;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),n);if(r&&(t=a(t),t===!1))return w;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:w}var i=new Uint8Array(t),o=i[0],s=f(t,1);return k&&"blob"===n&&(s=new k([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var n=b[t.charAt(0)];if(!p)return{type:n,data:{base64:!0,data:t.substr(1)}};var r=p.decode(t.substr(1));return"blob"===e&&k&&(r=new k([r])),{type:n,data:r}},e.encodePayload=function(t,n,r){function o(t){return t.length+":"+t}function i(t,r){e.encodePacket(t,!!s&&n,!1,function(t){r(null,o(t))})}"function"==typeof n&&(r=n,n=null);var s=h(t);return n&&s?k&&!g?e.encodePayloadAsBlob(t,r):e.encodePayloadAsArrayBuffer(t,r):t.length?void c(t,i,function(t,e){return r(e.join(""))}):r("0:")},e.decodePayload=function(t,n,r){if("string"!=typeof t)return e.decodePayloadAsBinary(t,n,r);"function"==typeof n&&(r=n,n=null);var o;if(""===t)return r(w,0,1);for(var i,s,a="",c=0,p=t.length;c<p;c++){var u=t.charAt(c);if(":"===u){if(""===a||a!=(i=Number(a)))return r(w,0,1);if(s=t.substr(c+1,i),a!=s.length)return r(w,0,1);if(s.length){if(o=e.decodePacket(s,n,!1),w.type===o.type&&w.data===o.data)return r(w,0,1);var h=r(o,c+i,p);if(!1===h)return}c+=i,a=""}else a+=u}return""!==a?r(w,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){return n(null,t)})}return t.length?void c(t,r,function(t,e){var r=e.reduce(function(t,e){var n;return n="string"==typeof e?e.length:e.byteLength,t+n.toString().length+n+2},0),o=new Uint8Array(r),i=0;return e.forEach(function(t){var e="string"==typeof t,n=t;if(e){for(var r=new Uint8Array(t.length),s=0;s<t.length;s++)r[s]=t.charCodeAt(s);n=r.buffer}e?o[i++]=0:o[i++]=1;for(var a=n.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var r=new Uint8Array(n),s=0;s<r.length;s++)o[i++]=r[s]}),n(o.buffer)}):n(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,n){function r(t,n){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var r=new Uint8Array(t.length),o=0;o<t.length;o++)r[o]=t.charCodeAt(o);t=r.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,k){var c=new k([e.buffer,a.buffer,t]);n(null,c)}})}c(t,r,function(t,e){return n(new k(e))})},e.decodePayloadAsBinary=function(t,n,r){"function"==typeof n&&(r=n,n=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",p=1;255!==s[p];p++){if(c.length>310)return r(w,0,1);c+=s[p]}o=f(o,2+c.length),c=parseInt(c);var u=f(o,0,c);if(a)try{u=String.fromCharCode.apply(null,new Uint8Array(u))}catch(h){var l=new Uint8Array(u);u="";for(var p=0;p<l.length;p++)u+=String.fromCharCode(l[p])}i.push(u),o=f(o,c)}var d=i.length;i.forEach(function(t,o){r(e.decodePacket(t,n,!0),o,d)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],n=Object.prototype.hasOwnProperty;for(var r in t)n.call(t,r)&&e.push(r);return e}},function(t,e){t.exports=function(t,e,n){var r=t.byteLength;if(e=e||0,n=n||r,t.slice)return t.slice(e,n);if(e<0&&(e+=r),n<0&&(n+=r),n>r&&(n=r),e>=r||e>=n||0===r)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(n-e),s=e,a=0;s<n;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function n(t,e,n){function o(t,r){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=n):0!==o.count||i||e(null,r)}var i=!1;return n=n||r,o.count=t,0===t?e():o}function r(){}t.exports=n},function(t,e,n){var r;(function(t,o){!function(i){function s(t){for(var e,n,r=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(n=t.charCodeAt(o++),56320==(64512&n)?r.push(((1023&e)<<10)+(1023&n)+65536):(r.push(e),o--)):r.push(e);return r}function a(t){for(var e,n=t.length,r=-1,o="";++r<n;)e=t[r],e>65535&&(e-=65536,o+=w(e>>>10&1023|55296),e=56320|1023&e),o+=w(e);return o}function c(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function p(t,e){return w(t>>e&63|128)}function u(t,e){if(0==(4294967168&t))return w(t);var n="";return 0==(4294965248&t)?n=w(t>>6&31|192):0==(4294901760&t)?(c(t,e)||(t=65533),n=w(t>>12&15|224),n+=p(t,6)):0==(4292870144&t)&&(n=w(t>>18&7|240),n+=p(t,12),n+=p(t,6)),n+=w(63&t|128)}function h(t,e){e=e||{};for(var n,r=!1!==e.strict,o=s(t),i=o.length,a=-1,c="";++a<i;)n=o[a],c+=u(n,r);return c}function f(){if(b>=v)throw Error("Invalid byte index");var t=255&g[b];if(b++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function l(t){var e,n,r,o,i;if(b>v)throw Error("Invalid byte index");if(b==v)return!1;if(e=255&g[b],b++,0==(128&e))return e;if(192==(224&e)){if(n=f(),i=(31&e)<<6|n,i>=128)return i;throw Error("Invalid continuation byte")}if(224==(240&e)){if(n=f(),r=f(),i=(15&e)<<12|n<<6|r,i>=2048)return c(i,t)?i:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(n=f(),r=f(),o=f(),i=(7&e)<<18|n<<12|r<<6|o,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}function d(t,e){e=e||{};var n=!1!==e.strict;g=s(t),v=g.length,b=0;for(var r,o=[];(r=l(n))!==!1;)o.push(r);return a(o)}var y="object"==typeof e&&e,m=("object"==typeof t&&t&&t.exports==y&&t,"object"==typeof o&&o);m.global!==m&&m.window!==m||(i=m);var g,v,b,w=String.fromCharCode,k={version:"2.1.2",encode:h,decode:d};r=function(){return k}.call(e,n,e,t),!(void 0!==r&&(t.exports=r))}(this)}).call(e,n(28)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=new Uint8Array(256),r=0;r<t.length;r++)n[t.charCodeAt(r)]=r;e.encode=function(e){var n,r=new Uint8Array(e),o=r.length,i="";for(n=0;n<o;n+=3)i+=t[r[n]>>2],i+=t[(3&r[n])<<4|r[n+1]>>4],i+=t[(15&r[n+1])<<2|r[n+2]>>6],i+=t[63&r[n+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,r,o,i,s,a=.75*t.length,c=t.length,p=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var u=new ArrayBuffer(a),h=new Uint8Array(u);for(e=0;e<c;e+=4)r=n[t.charCodeAt(e)],o=n[t.charCodeAt(e+1)],i=n[t.charCodeAt(e+2)],s=n[t.charCodeAt(e+3)],h[p++]=r<<2|o>>4,h[p++]=(15&o)<<4|i>>2,h[p++]=(3&i)<<6|63&s;return u}}()},function(t,e){(function(e){function n(t){for(var e=0;e<t.length;e++){var n=t[e];if(n.buffer instanceof ArrayBuffer){var r=n.buffer;if(n.byteLength!==r.byteLength){var o=new Uint8Array(n.byteLength);o.set(new Uint8Array(r,n.byteOffset,n.byteLength)),r=o.buffer}t[e]=r}}}function r(t,e){e=e||{};var r=new i;n(t);for(var o=0;o<t.length;o++)r.append(t[o]);return e.type?r.getBlob(e.type):r.getBlob()}function o(t,e){return n(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(e){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(e){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?r:void 0}()}).call(e,function(){return this}())},function(t,e){e.encode=function(t){var e="";for(var n in t)t.hasOwnProperty(n)&&(e.length&&(e+="&"),e+=encodeURIComponent(n)+"="+encodeURIComponent(t[n]));return e},e.decode=function(t){for(var e={},n=t.split("&"),r=0,o=n.length;r<o;r++){var i=n[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}},function(t,e){"use strict";function n(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function r(t){var e=0;for(u=0;u<t.length;u++)e=e*a+c[t.charAt(u)];return e}function o(){var t=n(+new Date);return t!==i?(p=0,i=t):t+"."+n(p++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},p=0,u=0;u<a;u++)c[s[u]]=u;o.encode=n,o.decode=r,t.exports=o},function(t,e,n){(function(e){function r(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var n=this;a.push(function(t){n.onData(t)}),this.query.j=this.index,e.document&&e.addEventListener&&e.addEventListener("beforeunload",function(){n.script&&(n.script.onerror=r)},!1)}var i=n(21),s=n(32);t.exports=o;var a,c=/\n/g,p=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var n=document.getElementsByTagName("script")[0];n?n.parentNode.insertBefore(e,n):(document.head||document.body).appendChild(e),this.script=e;var r="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function n(){r(),e()}function r(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var e='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(e)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),u=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=u,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),r(),t=t.replace(p,"\\\n"),this.area.value=t.replace(c,"\\n");try{this.form.submit()}catch(h){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&n()}:this.iframe.onload=n}}).call(e,function(){return this}())},function(t,e,n){(function(e){function r(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=h&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(l=o),i.call(this,t)}var o,i=n(22),s=n(23),a=n(31),c=n(32),p=n(33),u=n(3)("engine.io-client:websocket"),h=e.WebSocket||e.MozWebSocket;if("undefined"==typeof window)try{o=n(36)}catch(f){}var l=h;l||"undefined"!=typeof window||(l=o),t.exports=r,c(r,i),r.prototype.name="websocket",r.prototype.supportsBinary=!0,r.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,n={agent:this.agent,perMessageDeflate:this.perMessageDeflate};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(n.headers=this.extraHeaders),this.localAddress&&(n.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?e?new l(t,e):new l(t):new l(t,e,n)}catch(r){return this.emit("error",r)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},r.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},r.prototype.write=function(t){function n(){r.emit("flush"),setTimeout(function(){r.writable=!0,r.emit("drain")},0)}var r=this;this.writable=!1;for(var o=t.length,i=0,a=o;i<a;i++)!function(t){s.encodePacket(t,r.supportsBinary,function(i){if(!r.usingBrowserWebSocket){var s={};if(t.options&&(s.compress=t.options.compress),r.perMessageDeflate){var a="string"==typeof i?e.Buffer.byteLength(i):i.length;a<r.perMessageDeflate.threshold&&(s.compress=!1)}}try{r.usingBrowserWebSocket?r.ws.send(i):r.ws.send(i,s)}catch(c){u("websocket closed before onclose event")}--o||n()})}(t[i])},r.prototype.onClose=function(){i.prototype.onClose.call(this)},r.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},r.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",n="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(n=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=p()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&&(t="?"+t);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+n+this.path+t},r.prototype.check=function(){return!(!l||"__initialize"in l&&this.name===r.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var n=[].indexOf;t.exports=function(t,e){if(n)return t.indexOf(e);for(var r=0;r<t.length;++r)if(t[r]===e)return r;return-1}},function(t,e){(function(e){var n=/^[\],:{}\s]*$/,r=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,o=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,i=/(?:^|:|,)(?:\s*\[)+/g,s=/^\s+/,a=/\s+$/;t.exports=function(t){return"string"==typeof t&&t?(t=t.replace(s,"").replace(a,""),e.JSON&&JSON.parse?JSON.parse(t):n.test(t.replace(r,"@").replace(o,"]").replace(i,""))?new Function("return "+t)():void 0):null}}).call(e,function(){return this}())},function(t,e,n){"use strict";function r(t,e,n){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,n&&n.query&&(this.query=n.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=n(7),s=n(8),a=n(40),c=n(41),p=n(42),u=n(3)("socket.io-client:socket"),h=n(31);t.exports=e=r;var f={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},l=s.prototype.emit;s(r.prototype),r.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",p(this,"onopen")),c(t,"packet",p(this,"onpacket")),c(t,"close",p(this,"onclose"))]}},r.prototype.open=r.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},r.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},r.prototype.emit=function(t){if(f.hasOwnProperty(t))return l.apply(this,arguments),this;var e=a(arguments),n={type:i.EVENT,data:e};return n.options={},n.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(u("emitting packet with ack id %d",this.ids),this.acks[this.ids]=e.pop(),n.id=this.ids++),this.connected?this.packet(n):this.sendBuffer.push(n),delete this.flags,this},r.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},r.prototype.onopen=function(){if(u("transport is open - connecting"),"/"!==this.nsp)if(this.query){var t="object"===o(this.query)?h.encode(this.query):this.query;u("sending connect packet with query %s",t),this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},r.prototype.onclose=function(t){u("close (%s)",t),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},r.prototype.onpacket=function(t){if(t.nsp===this.nsp)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},r.prototype.onevent=function(t){var e=t.data||[];u("emitting event %j",e),null!=t.id&&(u("attaching ack callback to event"),e.push(this.ack(t.id))),this.connected?l.apply(this,e):this.receiveBuffer.push(e)},r.prototype.ack=function(t){var e=this,n=!1;return function(){if(!n){n=!0;var r=a(arguments);u("sending ack %j",r),e.packet({type:i.ACK,id:t,data:r})}}},r.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e?(u("calling ack %s with %j",t.id,t.data),e.apply(this,t.data),delete this.acks[t.id]):u("bad ack %s",t.id)},r.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},r.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)l.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},r.prototype.ondisconnect=function(){u("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},r.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},r.prototype.close=r.prototype.disconnect=function(){return this.connected&&(u("performing disconnect (%s)",this.nsp),this.packet({type:i.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},r.prototype.compress=function(t){return this.flags=this.flags||{},this.flags.compress=t,this}},function(t,e){function n(t,e){var n=[];e=e||0;for(var r=e||0;r<t.length;r++)n[r-e]=t[r];return n}t.exports=n},function(t,e){"use strict";function n(t,e,n){return t.on(e,n),{destroy:function(){t.removeListener(e,n)}}}t.exports=n},function(t,e){var n=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var r=n.call(arguments,2);return function(){return e.apply(t,r.concat(n.call(arguments)))}}},function(t,e){function n(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=n,n.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),n=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-n:t+n}return 0|Math.min(t,this.max)},n.prototype.reset=function(){this.attempts=0},n.prototype.setMin=function(t){this.ms=t},n.prototype.setMax=function(t){this.max=t},n.prototype.setJitter=function(t){this.jitter=t}}])});
//# sourceMappingURL=socket.io.js.map

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Bar__ = __webpack_require__(150);
/* global document */




/*
 * AudioPlayer represents a Audio component that shows either a local or a remote Audio.
 * Ex.: var player = AudioPlayer({id: id, stream: stream, elementID: elementID});
 * A AudioPlayer is also a View component.
 */

const AudioPlayer = (spec) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__View__["a" /* default */])({});
  let onmouseover;
  let onmouseout;

  // Variables

  // AudioPlayer ID
  that.id = spec.id;

  // Stream that the AudioPlayer will play
  that.stream = spec.stream.stream;

  // DOM element in which the AudioPlayer will be appended
  that.elementID = spec.elementID;


    // Audio tag
  that.audio = document.createElement('audio');
  that.audio.setAttribute('id', `stream${that.id}`);
  that.audio.setAttribute('class', 'vcx_stream');
  that.audio.setAttribute('style', 'width: 100%; height: 100%; position: absolute');
  that.audio.setAttribute('autoplay', 'autoplay');

  if (spec.stream.local) { that.audio.volume = 0; }

  if (that.elementID !== undefined) {
    // It will stop the AudioPlayer and remove it from the HTML
    that.destroy = () => {
      that.audio.pause();
      that.parentNode.removeChild(that.div);
    };

    // Container
    that.div = document.createElement('div');
    that.div.setAttribute('id', `player_${that.id}`);
    that.div.setAttribute('class', 'vcx_player');
    that.div.setAttribute('style', 'width: 100%; height: 100%; position: relative; ' +
                              'overflow: hidden;');

    // Check for a passed DOM node.
    if (typeof that.elementID === 'object' &&
          typeof that.elementID.appendChild === 'function') {
      that.container = that.elementID;
    } else {
      that.container = document.getElementById(that.elementID);
    }
    that.container.appendChild(that.div);

    that.parentNode = that.div.parentNode;
    that.div.appendChild(that.audio);

    // Bottom Bar
    if (spec.options.bar !== false) {
      that.bar = Object(__WEBPACK_IMPORTED_MODULE_1__Bar__["a" /* default */])({ elementID: `player_${that.id}`,
        id: that.id,
        stream: spec.stream,
        media: that.audio,
        options: spec.options });

      that.div.onmouseover = onmouseover;
      that.div.onmouseout = onmouseout;
    } else {
      // Expose a consistent object to manipulate the media.
      that.media = that.audio;
    }
  } else {
    // It will stop the AudioPlayer and remove it from the HTML
    that.destroy = () => {
      that.audio.pause();
      that.parentNode.removeChild(that.audio);
    };

    document.body.appendChild(that.audio);
    that.parentNode = document.body;
  }

    // player stats button

    let statsContainer = document.createElement('div');
    statsContainer.setAttribute('id', `stats-container-${that.id}`);
    statsContainer.setAttribute('class', 'stats-container');
    statsContainer.setAttribute('style', 'display:none;');


    let playerButton = document.createElement('div');
    playerButton.setAttribute('id', `stats-button-${that.id}`);
    playerButton.setAttribute('class', 'stats-button');
    playerButton.setAttribute('title', 'Click to see stats');
    playerButton.innerHTML = window.statsIcon;

    statsContainer.appendChild(playerButton);

    let statsOverlay = document.createElement('div');
    statsOverlay.setAttribute('class', 'stats-overlay');
    statsOverlay.setAttribute('id', `stats-overlay-${that.id}`);
    statsOverlay.setAttribute('style', 'display:none;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');

    let statsOverlayInner = document.createElement('div');
    statsOverlayInner.setAttribute('class', 'stats-overlay-inner');
    statsOverlayInner.setAttribute('id', `stats-overlay-inner-${that.id}`);
    // statsOverlayInner.setAttribute('style', `display:flex;flex-direction:row;`);


    let leftPartition = document.createElement('div'),
      rightPartition = document.createElement('div');
    leftPartition.setAttribute('class', 'stats-left-partition');
    leftPartition.setAttribute('id', `stats-left-part-${that.id}`);

    rightPartition.setAttribute('class', 'stats-right-partition');
    rightPartition.setAttribute('id', `stats-right-part-${that.id}`);

    playerButton.addEventListener('click', () => {
      if (statsOverlay.style.display === 'none')
        statsOverlay.style.display = 'block';
      else
        statsOverlay.style.display = 'none';
    });

    that.div.parentNode.style.position = 'relative';
    // Appending Stats container to main player container
    that.div.parentNode.appendChild(statsContainer);
    // appending overlay to container
    that.div.parentNode.appendChild(statsOverlay);
    statsOverlay.appendChild(statsOverlayInner);


    // partitions of overlay
    statsOverlayInner.appendChild(leftPartition);
    statsOverlayInner.appendChild(rightPartition);

  that.audio.srcObject = that.stream;
  that.ShowSessionStats = (statsEnabled) => {
    if (statsEnabled) {
      // show stats UI
      statsContainer.setAttribute('style', 'display:block;');
      statsOverlay.setAttribute('style', 'display:block;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
    } else {
      // hide stats UI
      statsContainer.setAttribute('style', 'display:none;');
      statsOverlay.setAttribute('style', 'display:none;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
    }
  };
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (AudioPlayer);


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__ = __webpack_require__(8);
/*
This file is for handle Speaker.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */




/*
 * Speaker represents the volume icon that will be shown in the mediaPlayer, for example.
 * It manages the volume level of the media tag given in the constructor.
 * Every Speaker is a View.
 * Ex.: var speaker = Speaker({elementID: element, media: mediaTag, id: id});
 */
const Speaker = (spec) =>
{
    const that = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    let lastVolume = 50;
    var isDefaultSkin = spec.skin === 'default';
    const mute = () =>
    {
        that.media.muted = true;
        that.div.classList.remove('fa-volume-up');
        that.div.classList.add('fa-volume-off');
        if (that.stream.local) {
            that.stream.stream.getAudioTracks()[0].enabled = false;
        } else {
            lastVolume = that.picker.value;
            that.picker.value = 0;
            that.media.volume = 0;
        }
    }
    ;

    const unmute = () =>
    {
        that.media.muted = false;
        that.div.classList.remove('fa-volume-off');
        that.div.classList.add('fa-volume-up');
        //that.div.setAttribute('src', `${that.url}/assets/sound48.png`);
        if (that.stream.local) {
            that.stream.stream.getAudioTracks()[0].enabled = true;
        } else {
            that.picker.value = lastVolume;
            that.media.volume = that.picker.value / 100;
        }
    }

    // Variables
    // DOM element in which the Speaker will be appended
    that.elementID = spec.elementID;

    // media tag
    that.media = spec.media;

    // Speaker id
    that.id = spec.id;

    // MediaStream
    that.stream = spec.stream;

    let spkr_pos = spec.position;
    // Container
    if (isDefaultSkin)
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            'class': 'fa fa-volume-up fa-fw fa-lg',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon_volume),
            'id': `volume_${that.id}`
        });
    else
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            'class': 'fa fa-volume-up fa-fw fa-lg ' + spec.skin + '_icon ' + spec.skin + '_icon_volume',
            'id': `volume_${that.id}`
        });
    __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].setStyle(that.div, spec.position, '0');


    that.div.onclick = () =>
    {
        if (that.media.muted) {
            unmute();
        } else {
            mute();
        }
    }

    if (!that.stream.local) {
        // Volume bar
        that.picker = document.createElement('input');
        that.picker.setAttribute('id', `picker_${that.id}`);
        that.picker.setAttribute('style', 'position: absolute;max-width: 50px;margin: 1.1%;top:0;');
        that.picker.type = 'range';
        that.picker.min = 0;
        that.picker.max = 1;
        that.picker.step = 0.1;
        that.picker.value = lastVolume;
        //  FireFox supports range sliders as of version 23
        that.picker.setAttribute('orient', 'vertical');
        that.div.appendChild(that.picker);
        that.media.volume = that.picker.value;
        that.media.muted = false;

        that.picker.onclick = () =>
        {
            if (that.picker.value > 0) {
                that.media.muted = false;
                that.div.classList.remove('fa-volume-off');
                that.div.classList.add('fa-volume-up');
            } else {
                that.media.muted = true;
                that.div.classList.remove('fa-volume-up');
                that.div.classList.add('fa-volume-off');
            }
            that.media.volume = that.picker.value;
        }


        // Private functions
        const show = (displaying) =>
        {
            that.picker.setAttribute('style', `position: absolute;max-width: 50px;margin: 1.1%;margin-left:32px;top:0;display: ${displaying}`);
        }

//	Element.setStyle(that.picker,spec.position,`${that.div.offsetHeight}px`);
        // Public functions
        that.div.onmouseover = () =>
        {
            show('block');
        }


        that.picker.onmouseout = () =>
        {
            show('none');
        }
        show('none');
    }

    document.getElementById(that.elementID).appendChild(that.div);
    return that;
}

/* harmony default export */ __webpack_exports__["a"] = (Speaker);


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__ = __webpack_require__(8);
/*
This file is for handle Zoom / fullscreen button.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */





var isDefaultSkin = false;
const Zoomer = (spec) => {
    const that = {};
    isDefaultSkin = spec.skin === 'default';
    if (isDefaultSkin)
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'zoom',
            class: 'fa fa-expand  fa-lg icon_zoom ',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon_zoom)
        });
    else
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'zoom',
            class: 'fa fa-expand icon_zoom ' + spec.skin + '_icon fa-lg ' + spec.skin + '_icon_zoom'
        });

    that.div.onclick = function (e) {
        e.stopPropagation();
        Zoomer.click(e, spec);
    }
    return that.div;
}

Zoomer.click = function (e, spec) {
    var skin = spec.skin;
    var player = {
        height: spec.player.height,
        width: spec.player.width,
        position: 'relative'
    };
    var className = e.currentTarget.classList;
    if (className.contains("fa-expand")) {
        e.currentTarget.classList.remove("fa-expand");
        e.currentTarget.classList.add("fa-arrows-alt");
        if (isDefaultSkin)
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.setAttribute('style', __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getStyle(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].full_view));
        else
            e.currentTarget.parentNode.parentNode.parentNode.classList.add(skin + "_theater_view");
    }
    else if (className.contains("fa-arrows-alt")) {
        e.currentTarget.classList.remove("fa-arrows-alt");
        e.currentTarget.classList.add("fa-compress");
        if (isDefaultSkin) {
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.removeAttribute('style');
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.setAttribute('style', __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getStyle(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].full_view));
        } else {
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.classList.remove(skin + "_theater_view");
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.classList.add(skin + "_full_view");
        }
    }
    else if (className.contains("fa-compress")) {
        e.currentTarget.classList.remove("fa-compress");
        e.currentTarget.classList.add("fa-expand");
        if (isDefaultSkin) {
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.removeAttribute('style');
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.setAttribute('style', __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getStyle(player));
        } else
            e.currentTarget.parentNode.parentNode.parentNode.classList.remove(skin + "_full_view");
    }
}

/* harmony default export */ __webpack_exports__["a"] = (Zoomer);


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ViewProperties__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__ = __webpack_require__(8);
/*
This file is for handle Brand Logo and Icon.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */






const Branding = (spec) =>
{
    const view = Object(__WEBPACK_IMPORTED_MODULE_2__View__["a" /* default */])({});
    const that = {};
    var isDefaultSkin = false;
    var brand = Object(__WEBPACK_IMPORTED_MODULE_0__ViewProperties__["a" /* default */])().brand.default;
    if (spec) {
        if (__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(spec.clickthru))
            brand.url = spec.clickthru;
        if (spec.target && spec.target == 'current')
            brand.target = '_self';
        if (__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(spec.logo))
            brand.logo = spec.logo;
        if (__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(spec.title))
            brand.title = spec.title;
        if (spec.display !== undefined)
            brand.display = spec.display;
        isDefaultSkin = spec.skin === 'default';
    }
    that.link = Object(__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */])({name: 'a', title: brand.title, href: brand.url, target: brand.target});
    if (isDefaultSkin)
        that.brandIcon = Object(__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */])({name: 'img', src: brand.logo, style: __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__["a" /* default */].brand_logo});
    else
        that.brandIcon = Object(__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */])({name: 'img', class: spec.skin + '_brand_logo', src: brand.logo});
    that.link.appendChild(that.brandIcon);
    if (!__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(brand.display)) {
        that.link.style.display = 'none';
    }
    return that.link;
}

/* harmony default export */ __webpack_exports__["a"] = (Branding);


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/*
This file is for handle Recorder.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */





const Recorder = (spec) => {
  const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
  const that = {};
  that.recorder = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({name:'i',title:'record',class:'fa fa-circle fa-fw fa-lg icon_record '+spec.skin+'_icon '+spec.skin+'_icon_record'});

    that.recorder.onclick = function(e){
        Recorder.click(e,spec.stream);
    }
    return that.recorder;
};
Recorder.click = function(e,stream){

    var className = e.currentTarget.classList;
    if(className.contains("fa-circle") ){
        e.currentTarget.classList.remove("fa-circle");
        e.currentTarget.classList.add("fa-stop-circle");
        if(!stream.local){
            stream.room.startRecording(stream,function(id){
            });
        }else{
        }
    }
    else if(className.contains("fa-stop-circle") ){
        e.currentTarget.classList.remove("fa-stop-circle");
        e.currentTarget.classList.add("fa-circle");
        if(stream.recordingId)
            stream.room.stopRecording(stream.recordingId,function(bool){
                if(bool)
                    stream.recordingId = undefined;
            });
    }
}
/* harmony default export */ __webpack_exports__["a"] = (Recorder);


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/*
This file is for handle Recorder.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */





const Share = (spec) => {
  const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
  const that = {};
  that.stream = spec.stream;
  that.share = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({name:'i',title:'share screen',class:'fa fa-share-alt fa-fw fa-lg icon_share '+spec.skin+'_icon '+spec.skin+'_icon_share'});
  that.share.onclick =function(e){Share.click(e,that.stream);}
  return that.share;
};
Share.click = function(e,stream){
    var streamShare = VcxRtc.Stream({screen: true, data: true,attributes: {name: "shareStream"}});
    streamShare.init();
    streamShare.addEventListener('media-access-allowed', function () {
        stream.room.publish(streamShare, {maxVideoBW: 300}, function (id, error) {
        });
    });
    streamShare.addEventListener('media-access-denied', function (error) {
    });

}
/* harmony default export */ __webpack_exports__["a"] = (Share);


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Room__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__ = __webpack_require__(8);
/*
This file is for handle Recorder.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */






const Play = (spec) => {
    const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    const that = {};
    that.stream = spec.stream;
    if (spec.skin === 'default')
        that.play = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'pause',
            class: 'fa fa-pause fa-lg icon_play',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__["a" /* default */].icon_play)
        });
    else
        that.play = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'pause',
            class: 'fa fa-pause fa-lg ' + spec.skin + '_icon icon_play ' + spec.skin + '_icon_play'
        });
    that.play.onclick = function (e) {
        Play.click(e)
    };
    var css = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getCss
    return that.play;
}

Play.toggleVideo = (video) => {
    video.srcObject.getTracks().forEach(t => t.enabled = !t.enabled);
}
Play.click = function (e) {
    var className = e.currentTarget.classList;
    if (className.contains("fa-pause")) {
        e.currentTarget.classList.remove("fa-pause");
        e.currentTarget.classList.add("fa-play");
        var playerDiv = e.currentTarget.parentNode.parentNode.parentNode;
        var videoTag = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById('stream' + playerDiv.id.split("_")[1]);
        var screenSaver = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById('screen_saver_' + playerDiv.id.split("_")[1]);
        Play.toggleVideo(videoTag);
        if (screenSaver.src !== '')
            screenSaver.style.display = 'block';
        else
            videoTag.pause();
    }
    else if (className.contains("fa-play")) {
        e.currentTarget.classList.remove("fa-play");
        e.currentTarget.classList.add("fa-pause");
        var playerDiv = e.currentTarget.parentNode.parentNode.parentNode;
        var videoTag = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById('stream' + playerDiv.id.split("_")[1]);
        var screenSaver = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById('screen_saver_' + playerDiv.id.split("_")[1]);
        Play.toggleVideo(videoTag);
        if (screenSaver.src !== '')
            screenSaver.style.display = 'none';
        else
            videoTag.play();
    }
}

/* harmony default export */ __webpack_exports__["a"] = (Play);


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__ = __webpack_require__(8);
/*
This file is for handle Microphone.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */






const Mic = (spec) =>
{
    const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    const that = {};
    var isDefaultSkin = spec.skin === 'default';
    that.stream = spec.stream;
    if (isDefaultSkin)
        that.mic = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'microphone',
            class: 'fa fa-microphone fa-fw fa-lg icon_mic',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon_mic)
        });
    else
        that.mic = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'microphone',
            class: 'fa fa-microphone fa-fw fa-lg icon_mic ' + spec.skin + '_icon ' + spec.skin + '_icon_mic'
        });
    that.mic.onclick = function (e) {
        Mic.click(e, that.stream);
    }
    return that.mic;
}

Mic.click = function (e, stream) {
    var className = e.currentTarget.classList;
    if (className.contains("fa-microphone")) {
        stream.muteAudio();
        e.currentTarget.classList.remove("fa-microphone");
        e.currentTarget.classList.add("fa-microphone-slash");
    }
    else if (className.contains("fa-microphone-slash")) {
        stream.unmuteAudio();
        e.currentTarget.classList.remove("fa-microphone-slash");
        e.currentTarget.classList.add("fa-microphone");
    }
}
/* harmony default export */ __webpack_exports__["a"] = (Mic);


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* global unescape */

const VcxRtcMap = () => {
  const that = {};
  const values = {};

  that.add = (id, value) => {
    values[id] = value;
  };

  that.get = id => values[id];

  that.getAll = () => values;

  that.has = id => values[id] !== undefined;

  that.forEach = (func) => {
    const keys = Object.keys(values);
    for (let index = 0; index < keys.length; index += 1) {
      const key = keys[index];
      const value = values[key];
      func(value, key);
    }
  };

  that.keys = () => Object.keys(values);

  that.remove = (id) => {
    delete values[id];
  };
  // find the size of object
  that.size = function () {
    let obj=values;
    let size = 0, key;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        size++
      };
    }
    return size;
  };

  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (VcxRtcMap);


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(178)))

/***/ }),
/* 178 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 179 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 180 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_nanobus__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ownedFile__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__keychain__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__api__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_Logger__ = __webpack_require__(1);








class FileSender extends __WEBPACK_IMPORTED_MODULE_0_nanobus___default.a {

  constructor() {
    super('FileSender');
    this.keychain = new __WEBPACK_IMPORTED_MODULE_2__keychain__["a" /* default */]();
    this.reset();
  }

  get progressRatio() {
    return this.progress[0] / this.progress[1];
  }

  get progressIndefinite() {
    return (
      ['fileSizeProgress', 'notifyUploadEncryptDone'].indexOf(this.msg) === -1
    );
  }

  get sizes() {
    return {
      partialSize: Object(__WEBPACK_IMPORTED_MODULE_3__utils__["bytes"])(this.progress[0]),
      totalSize: Object(__WEBPACK_IMPORTED_MODULE_3__utils__["bytes"])(this.progress[1])
    };
  }

  reset() {
    this.uploadRequest = null;
    this.msg = 'importingFile';
    this.progress = [0, 1];
    this.cancelled = false;
  }

  cancel() {
    this.cancelled = true;
    if (this.uploadRequest) {
      this.uploadRequest.cancel();
    }
  }

  async upload(archive, bearerToken) {
    if (this.cancelled) {
    //  Logger.info('upload cancelled', archive);
      throw new Error(0);
    }
    this.msg = 'encryptingFile';
    this.emit('encrypting');
    const totalSize = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["encryptedSize"])(archive.size);
    const encStream = await this.keychain.encryptStream(archive.stream);
    const metadata = await this.keychain.encryptMetadata(archive);
    const authKeyB64 = await this.keychain.authKeyB64();
    const file_info = {
      name: archive.name,
      plainSize: archive.size,
      type: archive.type,
      totalSize: totalSize
    };

    this.uploadRequest = Object(__WEBPACK_IMPORTED_MODULE_4__api__["i" /* uploadWs */])(
      encStream,
      metadata,
      authKeyB64,
      archive.timeLimit,
      archive.dlimit,
      bearerToken,
      file_info,
      p => {
        this.progress = [p, totalSize];
        this.emit('progress');
      }
    );

    if (this.cancelled) {
      throw new Error(0);
    }

    this.msg = 'fileSizeProgress';
    this.emit('progress'); // HACK to kick MS Edge
    try {
      const result = await this.uploadRequest.result;
      this.msg = 'notifyUploadEncryptDone';
      this.uploadRequest = null;
      this.progress = [1, 1];
      const secretKey = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["arrayToB64"])(this.keychain.rawSecret);
      const ownedFile = new __WEBPACK_IMPORTED_MODULE_1__ownedFile__["a" /* default */]({
        id: result.id,
        url: `${result.url}#${secretKey}`,
        name: archive.name,
        size: archive.size,
        manifest: archive.manifest,
        time: result.duration,
        speed: archive.size / (result.duration / 1000),
        createdAt: Date.now(),
        expiresAt: Date.now() + archive.timeLimit * 1000,
        secretKey: secretKey,
        nonce: this.keychain.nonce,
        ownerToken: result.ownerToken,
        dlimit: archive.dlimit,
        timeLimit: archive.timeLimit,
        mnounce: result.mnounce
      });

      return ownedFile;
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_5__utils_Logger__["a" /* default */].info("upload request failed", e);
      this.msg = 'errorPageHeader';
      this.uploadRequest = null;
      throw e;
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FileSender;



/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Remove a range of items from an array
 *
 * @function removeItems
 * @param {Array<*>} arr The target array
 * @param {number} startIdx The index to begin removing from (inclusive)
 * @param {number} removeCount How many items to remove
 */
module.exports = function removeItems (arr, startIdx, removeCount) {
  var i, length = arr.length

  if (startIdx >= length || removeCount === 0) {
    return
  }

  removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount)

  var len = length - removeCount

  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount]
  }

  arr.length = len
}


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var scheduler = __webpack_require__(184)()
var assert = __webpack_require__(18)

var perf
nanotiming.disabled = true
try {
  perf = window.performance
  nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === 'true' || !perf.mark
} catch (e) { }

module.exports = nanotiming

function nanotiming (name) {
  assert.equal(typeof name, 'string', 'nanotiming: name should be type string')

  if (nanotiming.disabled) return noop

  var uuid = (perf.now() * 10000).toFixed() % Number.MAX_SAFE_INTEGER
  var startName = 'start-' + uuid + '-' + name
  perf.mark(startName)

  function end (cb) {
    var endName = 'end-' + uuid + '-' + name
    perf.mark(endName)

    scheduler.push(function () {
      var err = null
      try {
        var measureName = name + ' [' + uuid + ']'
        perf.measure(measureName, startName, endName)
        perf.clearMarks(startName)
        perf.clearMarks(endName)
      } catch (e) { err = e }
      if (cb) cb(err, name)
    })
  }

  end.uuid = uuid
  return end
}

function noop (cb) {
  if (cb) {
    scheduler.push(function () {
      cb(new Error('nanotiming: performance API unavailable'))
    })
  }
}


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(18)

var hasWindow = typeof window !== 'undefined'

function createScheduler () {
  var scheduler
  if (hasWindow) {
    if (!window._nanoScheduler) window._nanoScheduler = new NanoScheduler(true)
    scheduler = window._nanoScheduler
  } else {
    scheduler = new NanoScheduler()
  }
  return scheduler
}

function NanoScheduler (hasWindow) {
  this.hasWindow = hasWindow
  this.hasIdle = this.hasWindow && window.requestIdleCallback
  this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout
  this.scheduled = false
  this.queue = []
}

NanoScheduler.prototype.push = function (cb) {
  assert.equal(typeof cb, 'function', 'nanoscheduler.push: cb should be type function')

  this.queue.push(cb)
  this.schedule()
}

NanoScheduler.prototype.schedule = function () {
  if (this.scheduled) return

  this.scheduled = true
  var self = this
  this.method(function (idleDeadline) {
    var cb
    while (self.queue.length && idleDeadline.timeRemaining() > 0) {
      cb = self.queue.shift()
      cb(idleDeadline)
    }
    self.scheduled = false
    if (self.queue.length) self.schedule()
  })
}

NanoScheduler.prototype.setTimeout = function (cb) {
  setTimeout(cb, 0, {
    timeRemaining: function () {
      return 1
    }
  })
}

module.exports = createScheduler


/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__keychain__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__api__ = __webpack_require__(13);




class OwnedFile {
  constructor(obj) {
    if (!obj.manifest) {
      throw new Error('invalid file object');
    }
    this.id = obj.id;
    this.url = obj.url;
    this.name = obj.name;
    this.size = obj.size;
    this.manifest = obj.manifest;
    this.time = obj.time;
    this.speed = obj.speed;
    this.createdAt = obj.createdAt;
    this.expiresAt = obj.expiresAt;
    this.ownerToken = obj.ownerToken;
    this.dlimit = obj.dlimit || 1;
    this.dtotal = obj.dtotal || 0;
    this.keychain = new __WEBPACK_IMPORTED_MODULE_0__keychain__["a" /* default */](obj.secretKey, obj.nonce);
    this._hasPassword = !!obj.hasPassword;
    this.timeLimit = obj.timeLimit;
    this.mnounce=obj.mnounce;
  }

  get hasPassword() {
    return !!this._hasPassword;
  }

  get expired() {
    return this.dlimit === this.dtotal || Date.now() > this.expiresAt;
  }

  async setPassword(password) {
    try {
      this.password = password;
      this._hasPassword = true;
      this.keychain.setPassword(password, this.url);
      const result = await Object(__WEBPACK_IMPORTED_MODULE_2__api__["h" /* setPassword */])(this.id, this.ownerToken, this.keychain);
      return result;
    } catch (e) {
      this.password = null;
      this._hasPassword = false;
      throw e;
    }
  }

  del() {
    return Object(__WEBPACK_IMPORTED_MODULE_2__api__["a" /* del */])(this.id, this.ownerToken);
  }

  changeLimit(dlimit, user = {}) {
    if (this.dlimit !== dlimit) {
      this.dlimit = dlimit;
      return Object(__WEBPACK_IMPORTED_MODULE_2__api__["g" /* setParams */])(this.id, this.ownerToken, user.bearerToken, { dlimit });
    }
    return Promise.resolve(true);
  }

  async updateDownloadCount() {
    const oldTotal = this.dtotal;
    const oldLimit = this.dlimit;
    try {
      const result = await Object(__WEBPACK_IMPORTED_MODULE_2__api__["c" /* fileInfo */])(this.id, this.ownerToken);
      this.dtotal = result.dtotal;
      this.dlimit = result.dlimit;
    } catch (e) {
      if (e.message === '404') {
        this.dtotal = this.dlimit;
      }
      // ignore other errors
    }
    return oldTotal !== this.dtotal || oldLimit !== this.dlimit;
  }

  toJSON() {
    return {
      id: this.id,
      url: this.url,
      name: this.name,
      size: this.size,
      manifest: this.manifest,
      time: this.time,
      speed: this.speed,
      createdAt: this.createdAt,
      expiresAt: this.expiresAt,
      secretKey: Object(__WEBPACK_IMPORTED_MODULE_1__utils__["arrayToB64"])(this.keychain.rawSecret),
      ownerToken: this.ownerToken,
      dlimit: this.dlimit,
      dtotal: this.dtotal,
      hasPassword: this.hasPassword,
      timeLimit: this.timeLimit,
      mnounce:this.mnounce
    };
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = OwnedFile;



/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__streams__ = __webpack_require__(17);


function isDupe(newFile, array) {
  for (const file of array) {
    if (
      newFile.name === file.name &&
      newFile.size === file.size &&
      newFile.lastModified === file.lastModified
    ) {
      return true;
    }
  }
  return false;
}

class Archive {
  constructor(files = [], defaultTimeLimit = 86400,roomMeta ={}) {
    this.files = Array.from(files);
    this.defaultTimeLimit = defaultTimeLimit;
    this.timeLimit = defaultTimeLimit;
    this.dlimit = 10;
    this.password = null;
    this.roomMeta = roomMeta;

  }

  get name() {
    return this.files.length > 1 ? 'Send-Archive.zip' : this.files[0].name;
  }

  get type() {
    return this.files.length > 1 ? 'send-archive' : this.files[0].type;
  }

  get size() {
    return this.files.reduce((total, file) => total + file.size, 0);
  }

  get numFiles() {
    return this.files.length;
  }

  get manifest() {
    return {
      files: this.files.map(file => ({
        name: file.name,
        size: file.size,
        type: file.type
      }))
    };
  }

  get stream() {
    return Object(__WEBPACK_IMPORTED_MODULE_0__streams__["b" /* concatStream */])(this.files.map(file => Object(__WEBPACK_IMPORTED_MODULE_0__streams__["a" /* blobStream */])(file)));
  }

  addFiles(files, maxSize, maxFiles) {
    if (this.files.length + files.length > maxFiles) {
      throw new Error('tooManyFiles');
    }
    const newFiles = files.filter(
      file => file.size > 0 && !isDupe(file, this.files)
    );
    const newSize = newFiles.reduce((total, file) => total + file.size, 0);
    if (this.size + newSize > maxSize) {
      throw new Error('fileTooBig');
    }
    this.files = this.files.concat(newFiles);
    return true;
  }

  remove(file) {
    const index = this.files.indexOf(file);
    if (index > -1) {
      this.files.splice(index, 1);
    }
  }

  clear() {
    this.files = [];
    this.dlimit = 1;
    this.timeLimit = this.defaultTimeLimit;
    this.password = null;
    this.roomMeta ={};
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Archive;



/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_nanobus__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keychain__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__api__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__streams__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__zip__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_Logger__ = __webpack_require__(1);








class FileReceiver extends __WEBPACK_IMPORTED_MODULE_0_nanobus___default.a {
  constructor(fileInfo) {
    super('FileReceiver');

    this.keychain = new __WEBPACK_IMPORTED_MODULE_1__keychain__["a" /* default */](fileInfo.secretKey, fileInfo.nonce);
    if (fileInfo.requiresPassword) {
      this.keychain.setPassword(fileInfo.password, fileInfo.url);
    }
    this.fileInfo = fileInfo;
    this.reset();
  }

  get progressRatio() {
    return this.progress[0] / this.progress[1];
  }

  get progressIndefinite() {
    return this.state !== 'downloading';
  }

  get sizes() {
    return {
      partialSize: Object(__WEBPACK_IMPORTED_MODULE_2__utils__["bytes"])(this.progress[0]),
      totalSize: Object(__WEBPACK_IMPORTED_MODULE_2__utils__["bytes"])(this.progress[1])
    };
  }

  cancel() {
    if (this.downloadRequest) {
      this.downloadRequest.cancel();
    }
  }

  reset() {
    this.msg = 'fileSizeProgress';
    this.state = 'initialized';
    this.progress = [0, 1];
  }

  async getMetadata() {
    const meta = await Object(__WEBPACK_IMPORTED_MODULE_3__api__["e" /* metadata */])(this.fileInfo.id, this.keychain);
    this.fileInfo.name = meta.name;
    this.fileInfo.type = meta.type;
    this.fileInfo.iv = meta.iv;
    this.fileInfo.size = +meta.size;
    this.fileInfo.manifest = meta.manifest;
    this.state = 'ready';
  }

  sendMessageToSw(msg) {
    return new Promise((resolve, reject) => {
      const channel = new MessageChannel();

      channel.port1.onmessage = function(event) {
        if (event.data === undefined) {
          reject('bad response from serviceWorker');
        } else if (event.data.error !== undefined) {
          reject(event.data.error);
        } else {
          resolve(event.data);
        }
      };

      navigator.serviceWorker.controller.postMessage(msg, [channel.port2]);
    });
  }

  async downloadBlob(noSave = false, isMobile = false) {
    this.state = 'downloading';
    this.downloadRequest = await Object(__WEBPACK_IMPORTED_MODULE_3__api__["b" /* downloadFile */])(
      this.fileInfo.id,
      this.keychain,
      p => {
        this.progress = [p, this.fileInfo.size];
        this.emit('progress');
      }
    );
    try {
      const ciphertext = await this.downloadRequest.result;
      this.downloadRequest = null;
      this.msg = 'decryptingFile';
      this.state = 'decrypting';
      this.emit('decrypting');
      let size = this.fileInfo.size;
      let plainStream = this.keychain.decryptStream(Object(__WEBPACK_IMPORTED_MODULE_4__streams__["a" /* blobStream */])(ciphertext));
      if (this.fileInfo.type === 'send-archive') {
        const zip = new __WEBPACK_IMPORTED_MODULE_5__zip__["a" /* default */](this.fileInfo.manifest, plainStream);
        plainStream = zip.stream;
        size = zip.size;
      }
      const plaintext = await Object(__WEBPACK_IMPORTED_MODULE_2__utils__["streamToArrayBuffer"])(plainStream, size);
      let resp ={};
      if (!noSave) {
      resp=  await saveFile({
          plaintext,
          name: decodeURIComponent(this.fileInfo.name),
          type: this.fileInfo.type
        }, isMobile);
      }
      this.msg = 'downloadFinish';
      this.emit('complete');
      this.state = 'complete';
      return resp ;
    } catch (e) {
      this.downloadRequest = null;
      throw e;
    }
  }

  async downloadStream(noSave = false) {
    const start = Date.now();
    const onprogress = p => {
      this.progress = [p, this.fileInfo.size];
      this.emit('progress');
    };

    this.downloadRequest = {
      cancel: () => {
        this.sendMessageToSw({ request: 'cancel', id: this.fileInfo.id });
      }
    };

    try {
      this.state = 'downloading';

      const info = {
        request: 'init',
        id: this.fileInfo.id,
        filename: this.fileInfo.name,
        type: this.fileInfo.type,
        manifest: this.fileInfo.manifest,
        key: this.fileInfo.secretKey,
        requiresPassword: this.fileInfo.requiresPassword,
        password: this.fileInfo.password,
        url: this.fileInfo.url,
        size: this.fileInfo.size,
        nonce: this.keychain.nonce,
        noSave
      };
      await this.sendMessageToSw(info);

      onprogress(0);

      if (noSave) {
        const res = await fetch(Object(__WEBPACK_IMPORTED_MODULE_3__api__["d" /* getApiUrl */])(`/api/download/${this.fileInfo.id}`));
        if (res.status !== 200) {
          throw new Error(res.status);
        }
      } else {
        const downloadPath = `/api/download/${this.fileInfo.id}`;
        let downloadUrl = Object(__WEBPACK_IMPORTED_MODULE_3__api__["d" /* getApiUrl */])(downloadPath);
        if (downloadUrl === downloadPath) {
          downloadUrl = `${location.protocol}//${location.host}${downloadPath}`;
        }
        const a = document.createElement('a');
        a.href = downloadUrl;
        document.body.appendChild(a);
        a.click();
      }

      let prog = 0;
      let hangs = 0;
      while (prog < this.fileInfo.size) {
        const msg = await this.sendMessageToSw({
          request: 'progress',
          id: this.fileInfo.id
        });
        if (msg.progress === prog) {
          hangs++;
        } else {
          hangs = 0;
        }
        if (hangs > 30) {
          // TODO: On Chrome we don't get a cancel
          // signal so one is indistinguishable from
          // a hang. We may be able to detect
          // which end is hung in the service worker
          // to improve on this.
          const e = new Error('hung download');
          e.duration = Date.now() - start;
          e.size = this.fileInfo.size;
          e.progress = prog;
          throw e;
        }
        prog = msg.progress;
        onprogress(prog);
        await Object(__WEBPACK_IMPORTED_MODULE_2__utils__["delay"])(1000);
      }

      this.downloadRequest = null;
      this.msg = 'downloadFinish';
      this.emit('complete');
      this.state = 'complete';
    } catch (e) {
      this.downloadRequest = null;
      if (e === 'cancelled' || e.message === '400') {
        throw new Error(0);
      }
      throw e;
    }
  }

  download(options) {
    if (options.stream) {
      return this.downloadStream(options.noSave);
    }
    return this.downloadBlob(options.noSave, options.isMobile);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FileReceiver;


async function saveFile(file, isMobile = false) {
  return new Promise(function(resolve, reject) {
    let fdownloadResult ={};
    const dataView = new DataView(file.plaintext);
    const blob = new Blob([dataView], { type: file.type });
    if (isMobile === true){
      __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["a" /* default */].info(' download file mobile device', isMobile);
      fdownloadResult = {
        messageType: 'download-success', result: 0, description: 'download-success', response: {
          downloadStatus: 'success',
          name: file.name,
          type: file.type,
          size: file.size,
          blob:blob
        }
      };
      return resolve(fdownloadResult);
    }
    if (navigator.msSaveBlob) {
      console.log('nagivator service worker is present');
      navigator.msSaveBlob(blob, file.name);
      return resolve();
    } else if (/iPhone|fxios/i.test(navigator.userAgent)) {
    //  console.log('checking about iphone');
      // This method is much slower but createObjectURL
      // is buggy on iOS
      const reader = new FileReader();
      reader.addEventListener('loadend', function() {
        if (reader.error) {
          return reject(reader.error);
        }
        if (reader.result) {
          const a = document.createElement('a');
          a.href = reader.result;
          a.download = file.name;
          document.body.appendChild(a);
          a.click();
        }
        resolve();
      });
      reader.readAsDataURL(blob);
    } else {
      const downloadUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = file.name;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(downloadUrl);
      fdownloadResult = {
        messageType: 'download-success', result: 0, description: 'download-success', response: {
          downloadStatus: 'success',
          name: file.name,
          type: file.type,
          size: file.size,
        //  blob:blob
          }
        };

      setTimeout(resolve(fdownloadResult), 100);
    }
  });
}


/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crc_crc32__ = __webpack_require__(189);


const encoder = new TextEncoder();

function dosDateTime(dateTime = new Date()) {
  const year = (dateTime.getFullYear() - 1980) << 9;
  const month = (dateTime.getMonth() + 1) << 5;
  const day = dateTime.getDate();
  const date = year | month | day;
  const hour = dateTime.getHours() << 11;
  const minute = dateTime.getMinutes() << 5;
  const second = Math.floor(dateTime.getSeconds() / 2);
  const time = hour | minute | second;

  return { date, time };
}

class File {
  constructor(info) {
    this.name = encoder.encode(info.name);
    this.size = info.size;
    this.bytesRead = 0;
    this.crc = null;
    this.dateTime = dosDateTime();
  }

  get header() {
    const h = new ArrayBuffer(30 + this.name.byteLength);
    const v = new DataView(h);
    v.setUint32(0, 0x04034b50, true); // sig
    v.setUint16(4, 20, true); // version
    v.setUint16(6, 8, true); // bit flags (8 = use data descriptor)
    v.setUint16(8, 0, true); // compression
    v.setUint16(10, this.dateTime.time, true); // modified time
    v.setUint16(12, this.dateTime.date, true); // modified date
    v.setUint32(14, 0, true); // crc32 (in descriptor)
    v.setUint32(18, 0, true); // compressed size (in descriptor)
    v.setUint32(22, 0, true); // uncompressed size (in descriptor)
    v.setUint16(26, this.name.byteLength, true); // name length
    v.setUint16(28, 0, true); // extra field length
    for (let i = 0; i < this.name.byteLength; i++) {
      v.setUint8(30 + i, this.name[i]);
    }
    return new Uint8Array(h);
  }

  get dataDescriptor() {
    const dd = new ArrayBuffer(16);
    const v = new DataView(dd);
    v.setUint32(0, 0x08074b50, true); // sig
    v.setUint32(4, this.crc, true); // crc32
    v.setUint32(8, this.size, true); // compressed size
    v.setUint32(12, this.size, true); // uncompressed size
    return new Uint8Array(dd);
  }

  directoryRecord(offset) {
    const dr = new ArrayBuffer(46 + this.name.byteLength);
    const v = new DataView(dr);
    v.setUint32(0, 0x02014b50, true); // sig
    v.setUint16(4, 20, true); // version made
    v.setUint16(6, 20, true); // version required
    v.setUint16(8, 8, true); // bit flags (8 = use data descriptor)
    v.setUint16(10, 0, true); // compression
    v.setUint16(12, this.dateTime.time, true); // modified time
    v.setUint16(14, this.dateTime.date, true); // modified date
    v.setUint32(16, this.crc, true); // crc
    v.setUint32(20, this.size, true); // compressed size
    v.setUint32(24, this.size, true); // uncompressed size
    v.setUint16(28, this.name.byteLength, true); // name length
    v.setUint16(30, 0, true); // extra length
    v.setUint16(32, 0, true); // comment length
    v.setUint16(34, 0, true); // disk number
    v.setUint16(36, 0, true); // internal file attrs
    v.setUint32(38, 0, true); // external file attrs
    v.setUint32(42, offset, true); // file offset
    for (let i = 0; i < this.name.byteLength; i++) {
      v.setUint8(46 + i, this.name[i]);
    }
    return new Uint8Array(dr);
  }

  get byteLength() {
    return this.size + this.name.byteLength + 30 + 16;
  }

  append(data, controller) {
    this.bytesRead += data.byteLength;
    const endIndex = data.byteLength - Math.max(this.bytesRead - this.size, 0);
    const buf = data.slice(0, endIndex);
    this.crc = Object(__WEBPACK_IMPORTED_MODULE_0_crc_crc32__["a" /* default */])(buf, this.crc);
    controller.enqueue(buf);
    if (endIndex < data.byteLength) {
      return data.slice(endIndex, data.byteLength);
    }
  }
}

function centralDirectory(files, controller) {
  let directoryOffset = 0;
  let directorySize = 0;
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const record = file.directoryRecord(directoryOffset);
    directoryOffset += file.byteLength;
    controller.enqueue(record);
    directorySize += record.byteLength;
  }
  controller.enqueue(eod(files.length, directorySize, directoryOffset));
}

function eod(fileCount, directorySize, directoryOffset) {
  const e = new ArrayBuffer(22);
  const v = new DataView(e);
  v.setUint32(0, 0x06054b50, true); // sig
  v.setUint16(4, 0, true); // disk number
  v.setUint16(6, 0, true); // directory disk
  v.setUint16(8, fileCount, true); // number of records
  v.setUint16(10, fileCount, true); // total records
  v.setUint32(12, directorySize, true); // size of directory
  v.setUint32(16, directoryOffset, true); // offset of directory
  v.setUint16(20, 0, true); // comment length
  return new Uint8Array(e);
}

class ZipStreamController {
  constructor(files, source) {
    this.files = files;
    this.fileIndex = 0;
    this.file = null;
    this.reader = source.getReader();
    this.nextFile();
    this.extra = null;
  }

  nextFile() {
    this.file = this.files[this.fileIndex++];
  }

  async pull(controller) {
    if (!this.file) {
      // end of archive
      centralDirectory(this.files, controller);
      return controller.close();
    }
    if (this.file.bytesRead === 0) {
      // beginning of file
      controller.enqueue(this.file.header);
      if (this.extra) {
        this.extra = this.file.append(this.extra, controller);
      }
    }
    if (this.file.bytesRead >= this.file.size) {
      // end of file
      controller.enqueue(this.file.dataDescriptor);
      this.nextFile();
      return this.pull(controller);
    }
    const data = await this.reader.read();
    if (data.done) {
      this.nextFile();
      return this.pull(controller);
    }
    this.extra = this.file.append(data.value, controller);
  }
}

class Zip {
  constructor(manifest, source) {
    this.files = manifest.files.map(info => new File(info));
    this.source = source;
  }

  get stream() {
    return new ReadableStream(new ZipStreamController(this.files, this.source));
  }

  get size() {
    const entries = this.files.reduce(
      (total, file) => total + file.byteLength * 2 - file.size,
      0
    );
    const eod = 22;
    return entries + eod;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Zip;



/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__create_buffer__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__define_crc__ = __webpack_require__(191);




// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`
// prettier-ignore
let TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
  0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
  0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
  0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
  0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
  0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
  0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
  0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
  0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
  0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
  0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
  0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
  0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
  0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
  0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
  0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
  0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
  0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
  0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
  0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
  0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
  0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
  0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
  0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
  0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
  0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
  0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
  0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
  0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
  0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
  0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
  0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
  0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
  0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
  0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

const crc32 = Object(__WEBPACK_IMPORTED_MODULE_2__define_crc__["a" /* default */])('crc-32', function(buf, previous) {
  if (!__WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].isBuffer(buf)) buf = Object(__WEBPACK_IMPORTED_MODULE_1__create_buffer__["a" /* default */])(buf);

  let crc = previous === 0 ? 0 : ~~previous ^ -1;

  for (let index = 0; index < buf.length; index++) {
    const byte = buf[index];
    crc = TABLE[(crc ^ byte) & 0xff] ^ (crc >>> 8);
  }

  return crc ^ -1;
});

/* harmony default export */ __webpack_exports__["a"] = (crc32);


/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer__);


const createBuffer =
  __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].from && __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].alloc && __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].allocUnsafe && __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].allocUnsafeSlow
    ? __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].from
    : // support for Node < 5.10
      val => new __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"](val);

/* harmony default export */ __webpack_exports__["a"] = (createBuffer);


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(model, calc) {
  const fn = (buf, previous) => calc(buf, previous) >>> 0;
  fn.signed = calc;
  fn.unsigned = fn;
  fn.model = model;

  return fn;
});


/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Pair__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Room__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Base64__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Stream__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Enx_config_js__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Enx_config_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__Enx_config_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__customErrors__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__EventLogger__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__customEvents__ = __webpack_require__(6);












/*
 *   Author: Avnish
 *   Description: Merge all method in a singel class
 */
const VcxQuickApi = {};
VcxQuickApi.default = {
    minVideoBW: 200,
    maxVideoBW: 2046,
    scheme: 'notify-break-recover'
}
//////////disconnect Room///////////////
VcxQuickApi.disconnectRoom = (room) => {
    if (room) {
        room.disconnect();
    }
}
/////////Get Device List//////////////
VcxQuickApi.getDevice = (callback) => {
    __WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].getDeviceList(callback);
}

VcxQuickApi.notifyDeviceUpdate = (roomHandle) => {
    roomHandle.notifyDeviceUpdate();
}

VcxQuickApi.switchMediaDevice = (stream, audioDeviceId, videoDeviceId, callback) => {
    if ((audioDeviceId && typeof audioDeviceId === 'string') && (videoDeviceId && typeof videoDeviceId === 'string')) {
        stream.switchMediaDevices(stream, audioDeviceId, videoDeviceId, callback);
    } else {
        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info("Invalid Device Id");
        callback(false);
    }
}

///////////Join Room/////////////
VcxQuickApi.joinRoom = (token, streamInfo, callback,reconnectInfo={'allow_reconnect':true,'number_of_attempts':3,'timeout_interval':45000}) => {
    var room, localStream, error = null, success = null;
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('SDK version is: ', __WEBPACK_IMPORTED_MODULE_5__Enx_config_js___default.a.product.version);
    if (token != null) {
        console.log("=========== port of hope");
        var tok = JSON.parse(window.atob(token));
        __WEBPACK_IMPORTED_MODULE_9__EventLogger__["a" /* default */].init(tok);
        tok['version'] = __WEBPACK_IMPORTED_MODULE_5__Enx_config_js___default.a.product.version;
        room = Object(__WEBPACK_IMPORTED_MODULE_2__Room__["a" /* default */])(undefined, undefined, { token: window.btoa(JSON.stringify(tok)),reconnectInfo });
        const onAccessSuccess = () => {
            if (__WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
                var plugin = document.getElementById('WebrtcEverywherePluginId');
                plugin.addEventListener('room-connected', function (streamEvent) {
                    if (room.reconnectionState === false) {
                        var maxBW = streamInfo.maxVideoBW;
                        var minBW = streamInfo.minVideoBW;
                        var scheme = streamInfo.scheme;
                        if (!maxBW) { maxBW = VcxQuickApi.default.maxVideoBW }
                        if (!minBW) { minBW = VcxQuickApi.default.minVideoBW }
                        if (!scheme) { scheme = VcxQuickApi.default.scheme }
                        success = { "streams": streamEvent.data.streams, "room": room, "roomData": streamEvent.data.room, "localStream": localStream };
                        room.publish(localStream, { maxVideoBW: maxBW, minVideoBW: minBW, scheme: scheme }, function (response) {
                            if (response.result === 0) {
                                success['publishId'] = response.id;
                                callback(success, null);
                            } else {

                                callback(null, response);
                            }
                        });

                    }
                    else {
                        // handle here for Reconnection case
                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('handle reconnection: on room-connected');
                        success = { "streams": streamEvent.streams, "room": room, "roomData": streamEvent.room, "localStream": localStream };

                        for (var i = 0; i < success.streams.length; i++) {
                            room.subscribe(success.streams[i]);
                        }

                    }

                });
                plugin.addEventListener('room-error', function (err) {
                    callback(success, err.data);
                });
                plugin.addEventListener('stream-added', function (streamEvent) {
                    room.subscribe(streamEvent.data.stream);
                });
            } else {
                room.addEventListener('room-connected', function (streamEvent) {
                    if (room.reconnectionState === false) {
                        if (streamInfo.video && room.subscription && !room.subscription.audio_video){
                          __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].error ("Licence error : video not supported, ignoring video option");
                          streamInfo.video = false;
                        }
                        if (streamInfo.audio && room.subscription && !room.subscription.audio_only &&
                            !room.subscription.audio_video){
                          __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].error ("Licence error : audio not supported, ignoring audio option");
                          streamInfo.audio = false;
                        }
                        success = { "streams": streamEvent.streams, "room": room,
                                    "roomData": streamEvent.room, "localStream": localStream };

                        if ((!streamInfo.audio  && !streamInfo.video) ||
                            (streamEvent.room.mode === 'lecture' && streamEvent.me.role === 'participant' &&
                             (streamEvent.me !== undefined || streamEvent.me !== null))){
                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info( true ? "no audioi and video " :
                                                                                    " lecture mode publisher");
                            callback(success, null);
                        } else {
                          var maxBW = streamInfo.maxVideoBW ? streamInfo.maxVideoBW : VcxQuickApi.default.maxVideoBW;
                          var minBW = streamInfo.minVideoBW ? streamInfo.minVideoBW : VcxQuickApi.default.minVideoBW;
                          var scheme = streamInfo.scheme ? streamInfo.scheme : VcxQuickApi.default.scheme;
                          var maxLayers = streamInfo.maxVideoLayers;
                            room.publish(localStream, {
                                maxVideoBW: maxBW,
                                minVideoBW: minBW,
                                scheme: scheme,
                                maxVideoLayers: maxLayers,
                                forceTurn:streamInfo.forceTurn
                            }, function (response) {
                                if (response.result === 0) {
                                    success['publishId'] = response.id;
                                    // if mediaConfig is default and browser is safari and safari version <= 12.0
                                    // then show the audioOnly calls supported message
                                    if (room.mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.H264_CODEC
                                        && __WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].browserEngineCheck() === 'safari'
                                        && __WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].getBrowserVersion() <= __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_NOT_SUPPORTING_VP8
                                    ) {
                                        callback(success, __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1152);
                                    }
                                    else {
                                        callback(success, null);
                                    }
                                    if (streamEvent.mediaRecord) {
                                        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-record-on', message: 'Room Recording is in progress' });
                                        room.dispatchEvent(connectEvt);
                                    }
                                    if (streamEvent.room.mute) {
                                        const mutedEvent = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-muted', message: 'Room is muted' });
                                        room.dispatchEvent(mutedEvent);
                                    }
                                } else {
                                    callback(null, response);
                                }
                            });
                        }

                    } else {
                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('handle reconnection: for room-connected ');
                        // subcribe all remote streams and show them accrodingly in player
                        success = { "streams": streamEvent.streams, "room": room, "roomData": streamEvent.room, "localStream": localStream };

                        for (var i = 0; i < success.streams.length; i++) {
                            let optionsInput = {};
                            room.subscribe(success.streams[i], optionsInput, function (res) {
                                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('subscribe callback', res)
                                if (res === true) {
                                    // check if all the streams have been subscribed properly and flag that subscribed streams are fine
                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('reconnect subscriber callback success');
                                }
                                else{
                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('reconnect subscriber callback failed, could not reconnect',res);
                                    room.reconPubSubFailed(res);
                                    let reConnectFailEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-error', message: res });
                                    room.dispatchEvent(reConnectFailEvt);


                                }
                            });
                        }


                        // publish all local streams
                        var maxBW = streamInfo.maxVideoBW;
                        var minBW = streamInfo.minVideoBW;
                        var scheme = streamInfo.scheme;
                        var maxLayers = streamInfo.maxVideoLayers;
                        console.info('Msg::  maxVideoLayers:' + maxLayers);
                        if (!maxBW) { maxBW = VcxQuickApi.default.maxVideoBW }
                        if (!minBW) { minBW = VcxQuickApi.default.minVideoBW }
                        if (!scheme) { scheme = VcxQuickApi.default.scheme }
                        if (streamEvent.room.mode === 'lecture'
                            && (streamEvent.me !== undefined || streamEvent.me !== null)
                            && streamEvent.me.role === 'participant' && room.floorGranted !== true) {
                            console.info('Msg:  No publish for participant in lecture mode.');
                        } else {
                            // for all previously published local streams publish them and update the localstreams map
                            room.localStreamsBeforeReconnect.forEach((localStream, id) => {
                                if ((localStream.canvas === undefined) && (localStream.screen === undefined)) {
                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publish, audio video data stream');
                                    room.localStreamsBeforeReconnect.remove(id);

                                    room.publish(localStream, {
                                        maxVideoBW: maxBW,
                                        minVideoBW: minBW,
                                        scheme: scheme,
                                        maxVideoLayers: maxLayers
                                    }, function (response) {
                                        if (response.result === 0) {
                                            success['publishId'] = response.id;
                                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('reconnected and stream published successfully');
                                            room.manageStatsSubscription(localStream);
                                            room.manageRecordingStatus();
                                            if (streamEvent.mediaRecord) {
                                                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('reconnect publish success handle media record');
                                                const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-record-on', message: 'Room Recording is in progress' });
                                                room.dispatchEvent(connectEvt);
                                            }
                                            if (streamEvent.room.mute) {
                                                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('reconnect publish success handle room mute ');
                                                const mutedEvent = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-muted', message: 'Room is muted' });
                                                room.dispatchEvent(mutedEvent);
                                            }
                                            if(localStream.selfMuteAudio === true) {
                                              __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('reconnect. sending mute self audio ');
                                              localStream.sendEvent('user-audio-muted');
                                            }
                                            if(localStream.selfMuteVideo == true) {
                                              __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('reconnect. sending mute self video ');
                                              localStream.sendEvent('user-video-muted');
                                            }
                                            // ugly hack for fixing ATVAV restriction at server side
                                            // server says first published stream can not be canvas or share
                                            room.localStreamsBeforeReconnect.forEach((localStream, id) => {

                                                if (localStream.canvas === true) {
                                                    // publish canvas stream , may be we need to set specific config params like bandwidth etc
                                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publish, canvas stream');
                                                    room.localStreamsBeforeReconnect.remove(id);
                                                    room.publish(localStream, {maxVideoBW: 4096, minVideoBW:1024}, function (response) {
                                                        if (response.result === 0) {
                                                            success['publishId'] = response.id;

                                                        } else {
                                                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publish failed forcanvas stream failed', response);
                                                            room.reconPubSubFailed(response);
                                                            let  reConnectFailEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-error', message: response });
                                                            room.dispatchEvent(reConnectFailEvt);

                                                        }
                                                    });

                                                }
                                                else if (localStream.screen === true) {
                                                    // publish share stream , may be we need to set specific config params like bandwidth etc
                                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publish, share stream');
                                                    room.localStreamsBeforeReconnect.remove(id);

                                                    room.publish(localStream, { /*maxVideoBW: 300*/ share:true }, function (response) {
                                                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publish response for share stream', response);
                                                        // do additional stuff
                                                        if (response.result === 0) {
                                                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publish share successful', response);
                                                            room.localStreams.forEach((stream, id) => {
                                                                if (stream && stream.ifVideo()) {
                                                                    stream.setQualityLayers(2);
                                                                }
                                                            });
                                                         //   createEventLog('clientStreamShareSuccess', additionalOptions);
                                                        }
                                                        else {
                                                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publish share failed with reason', response);
                                                            room.reconPubSubFailed(response);
                                                            let reConnectFailEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-error', message: response });
                                                            room.dispatchEvent(reConnectFailEvt);

                                                        }
                                                    });


                                                }
                                                else {
                                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' unknown stream type ????????????');
                                                }


                                            });
                                        } else {
                                            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' reconnect publishing failed, response for publish', response);
                                            room.reconPubSubFailed(response);
                                            let reConnectFailEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'room-error', message: response });
                                            room.dispatchEvent(reConnectFailEvt);
                                        }
                                    });
                                }
                            });

                        }
                        // consider reconnection is successfull , need to do handling only when all are successfully subscribed and published
                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug( ' setting reconnection state as false ');
                        room.reconnectionState = false;
                        // reset the preferred number of active talkers
                        room.manageNumTalker();
                        // Send reconnected event
                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info('send network reconnected event');
                        let networkReconnected = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({ type: 'network-reconnected', error: __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1164.result, message: __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1164.error });
                        room.dispatchEvent(networkReconnected);
                        // end dispatching the event
                    }
                });
                room.addEventListener('room-error', function (err) {
                    callback(success, err);
                });
                room.addEventListener('stream-added', function (streamEvent) {
                    room.subscribe(streamEvent.stream);
                });

                room.addEventListener('active-talkers-updated', function (event) {
                    let activeList = event.message.activeList;
                    let activeListLength = activeList.length;
                    if (activeListLength > 0) {
                        for (let index = 0; index < activeListLength; index++) {
                            if (activeList[index].mediatype === 'audio' && activeList[index].muteDueToBw === true) {
                                room.remoteStreams.getAll()[activeList[index].streamId].audioOnly = true;
                                const userMutedEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["d" /* RoomEvent */])({
                                    type: 'user-muted-due-to-bw-crunch',
                                    message: { streamId: activeList[index].streamId, clientId: activeList[index].clientId, name: activeList[index].name }
                                });
                                room.dispatchEvent(userMutedEvt);
                            }
                        }
                    }
                });
            }
            if (room.reconnectionState === false && room.reconnectAttempt==0) {
                room.connect(reconnectInfo);
            }
            else {
                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].debug(' Reconnection case in join room public api')
            }
        }
        const onAccessError = (err) => {
            error = err;
            callback(success, error);
        }
        if (streamInfo.audio || streamInfo.video)
          localStream = room.initPublishStream(streamInfo.div, streamInfo, onAccessSuccess, onAccessError);
        else {
            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["a" /* default */].info(' No publish stream. audio and video are disabled..');
            onAccessSuccess();
        }
    }
    return localStream;
}
////////////////List Participants/////////////////
VcxQuickApi.listParticipants = (room) => {
    var users = [];
    if (room) {
        users = room.userList;
    }
    return users;
}
const socketEventToArgs = (func, event) => {
    if (event.args) {
        func(...event.args);
    } else {
        func();
    }
};
////////////////ReceiveMessage/////////////////
VcxQuickApi.ReceiveMessage = (stream, div) => {
    if (stream) {
        stream.addEventListener("stream-data", function (evt) {
        });
    }
}
////////////////Send Message/////////////////
VcxQuickApi.sendMessage = (stream, data) => {
    if (stream) {
        stream.sendData(data);
    }
}

/* harmony default export */ __webpack_exports__["a"] = (VcxQuickApi);


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["adapter"] = __webpack_require__(194);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(157)))

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */

'use strict';

var _adapter_factory = require('./adapter_factory.js');

var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
module.exports = adapter; // this is the difference from adapter_core.

},{"./adapter_factory.js":2}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapterFactory = adapterFactory;

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _chrome_shim = require('./chrome/chrome_shim');

var chromeShim = _interopRequireWildcard(_chrome_shim);

var _edge_shim = require('./edge/edge_shim');

var edgeShim = _interopRequireWildcard(_edge_shim);

var _firefox_shim = require('./firefox/firefox_shim');

var firefoxShim = _interopRequireWildcard(_firefox_shim);

var _safari_shim = require('./safari/safari_shim');

var safariShim = _interopRequireWildcard(_safari_shim);

var _common_shim = require('./common_shim');

var commonShim = _interopRequireWildcard(_common_shim);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Shimming starts here.
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
function adapterFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      window = _ref.window;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true
  };

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimGetStats(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimConnectionState(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimGetDisplayMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCreateOfferLegacy(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      commonShim.removeAllowExtmapMixed(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
}

// Browser shims.

},{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimMediaStream = shimMediaStream;
exports.shimOnTrack = shimOnTrack;
exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
exports.shimGetStats = shimGetStats;
exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.fixNegotiationNeeded = fixNegotiationNeeded;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimMediaStream(window) {
  window.MediaStream = window.MediaStream || window.webkitMediaStream;
}

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
      get: function get() {
        return this._ontrack;
      },
      set: function set(f) {
        if (this._ontrack) {
          this.removeEventListener('track', this._ontrack);
        }
        this.addEventListener('track', this._ontrack = f);
      },

      enumerable: true,
      configurable: true
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var _this = this;

      if (!this._ontrackpoly) {
        this._ontrackpoly = function (e) {
          // onaddstream does not fire when a track is added to an existing
          // stream. But stream.onaddtrack is implemented so we use that.
          e.stream.addEventListener('addtrack', function (te) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === te.track.id;
              });
            } else {
              receiver = { track: te.track };
            }

            var event = new Event('track');
            event.track = te.track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
          e.stream.getTracks().forEach(function (track) {
            var receiver = void 0;
            if (window.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function (r) {
                return r.track && r.track.id === track.id;
              });
            } else {
              receiver = { track: track };
            }
            var event = new Event('track');
            event.track = track;
            event.receiver = receiver;
            event.transceiver = { receiver: receiver };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
        };
        this.addEventListener('addstream', this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    // even if RTCRtpTransceiver is in window, it is only used and
    // emitted in unified-plan. Unfortunately this means we need
    // to unconditionally wrap the event.
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      if (!e.transceiver) {
        Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
      }
      return e;
    });
  }
}

function shimGetSendersWithDtmf(window) {
  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
    var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
      return {
        track: track,
        get dtmf() {
          if (this._dtmf === undefined) {
            if (track.kind === 'audio') {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };

    // augment addTrack when getSenders is not available.
    if (!window.RTCPeerConnection.prototype.getSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice(); // return a copy of the internal state.
      };
      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        var sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };

      var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        var idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this2 = this;

      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach(function (track) {
        _this2._senders.push(shimSenderWithDtmf(_this2, track));
      });
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;

      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);

      stream.getTracks().forEach(function (track) {
        var sender = _this3._senders.find(function (s) {
          return s.track === track;
        });
        if (sender) {
          // remove sender
          _this3._senders.splice(_this3._senders.indexOf(sender), 1);
        }
      });
    };
  } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this4 = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this4;
      });
      return senders;
    };

    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}

function shimGetStats(window) {
  if (!window.RTCPeerConnection) {
    return;
  }

  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _this5 = this;

    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    // If selector is a function then we are in the old style stats so just
    // pass back the original getStats format to avoid breaking old users.


    if (arguments.length > 0 && typeof selector === 'function') {
      return origGetStats.apply(this, arguments);
    }

    // When spec-style getStats is supported, return those when called with
    // either no arguments or the selector argument is null.
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
      return origGetStats.apply(this, []);
    }

    var fixChromeStats_ = function fixChromeStats_(response) {
      var standardReport = {};
      var reports = response.result();
      reports.forEach(function (report) {
        var standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          }[report.type] || report.type
        };
        report.names().forEach(function (name) {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });

      return standardReport;
    };

    // shim getStats with maplike support
    var makeMapStats = function makeMapStats(stats) {
      return new Map(Object.keys(stats).map(function (key) {
        return [key, stats[key]];
      }));
    };

    if (arguments.length >= 2) {
      var successCallbackWrapper_ = function successCallbackWrapper_(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };

      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
    }

    // promise-support
    return new Promise(function (resolve, reject) {
      origGetStats.apply(_this5, [function (response) {
        resolve(makeMapStats(fixChromeStats_(response)));
      }, reject]);
    }).then(onSucc, onErr);
  };
}

function shimSenderReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
    return;
  }

  // shim sender stats.
  if (!('getStats' in window.RTCRtpSender.prototype)) {
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function getSenders() {
        var _this6 = this;

        var senders = origGetSenders.apply(this, []);
        senders.forEach(function (sender) {
          return sender._pc = _this6;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function addTrack() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function getStats() {
      var sender = this;
      return this._pc.getStats().then(function (result) {
        return (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          utils.filterStats(result, sender.track, true)
        );
      });
    };
  }

  // shim receiver stats.
  if (!('getStats' in window.RTCRtpReceiver.prototype)) {
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        var _this7 = this;

        var receivers = origGetReceivers.apply(this, []);
        receivers.forEach(function (receiver) {
          return receiver._pc = _this7;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function (e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function getStats() {
      var receiver = this;
      return this._pc.getStats().then(function (result) {
        return utils.filterStats(result, receiver.track, false);
      });
    };
  }

  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
    return;
  }

  // shim RTCPeerConnection.getStats(track).
  var origGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
      var track = arguments[0];
      var sender = void 0;
      var receiver = void 0;
      var err = void 0;
      this.getSenders().forEach(function (s) {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach(function (r) {
        if (r.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
    }
    return origGetStats.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrackWithNative(window) {
  // shim addTrack/removeTrack with native variants in order to make
  // the interactions with legacy getLocalStreams behave as in other browsers.
  // Keeps a mapping stream.id => [stream, rtpsenders...]
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this8 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
      return _this8._shimmedLocalStreams[streamId][0];
    });
  };

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    var sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this9 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this9.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    var existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    var newSenders = this.getSenders().filter(function (newSender) {
      return existingSenders.indexOf(newSender) === -1;
    });
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };

  var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this10 = this;

    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
        var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          _this10._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (_this10._shimmedLocalStreams[streamId].length === 1) {
          delete _this10._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}

function shimAddTrackRemoveTrack(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  // shim addTrack and removeTrack.
  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window);
  }

  // also shim pc.getLocalStreams when addTrack is shimmed
  // to return the original streams.
  var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this11 = this;

    var nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map(function (stream) {
      return _this11._reverseStreams[stream.id];
    });
  };

  var origAddStream = window.RTCPeerConnection.prototype.addStream;
  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this12 = this;

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    stream.getTracks().forEach(function (track) {
      var alreadyExists = _this12.getSenders().find(function (s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.', 'InvalidAccessError');
      }
    });
    // Add identity mapping for consistency with addTrack.
    // Unless this is being used with a stream from addTrack.
    if (!this._reverseStreams[stream.id]) {
      var newStream = new window.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };

  var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};

    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };

  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    var _this13 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    var streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
      return t === track;
    })) {
      // this is not fully correct but all we can manage without
      // [[associated MediaStreams]] internal slot.
      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
    }

    var alreadyExists = this.getSenders().find(function (s) {
      return s.track === track;
    });
    if (alreadyExists) {
      throw new DOMException('Track already exists.', 'InvalidAccessError');
    }

    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    var oldStream = this._streams[stream.id];
    if (oldStream) {
      // this is using odd Chrome behaviour, use with caution:
      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
      // Note: we rely on the high-level addTrack/dtmf shim to
      // create the sender with a dtmf sender.
      oldStream.addTrack(track);

      // Trigger ONN async.
      Promise.resolve().then(function () {
        _this13.dispatchEvent(new Event('negotiationneeded'));
      });
    } else {
      var newStream = new window.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find(function (s) {
      return s.track === track;
    });
  };

  // replace the internal stream id with the external one and
  // vice versa.
  function replaceInternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  function replaceExternalStreamId(pc, description) {
    var sdp = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp
    });
  }
  ['createOffer', 'createAnswer'].forEach(function (method) {
    var nativeMethod = window.RTCPeerConnection.prototype[method];
    var methodObj = _defineProperty({}, method, function () {
      var _this14 = this;

      var args = arguments;
      var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
      if (isLegacyCall) {
        return nativeMethod.apply(this, [function (description) {
          var desc = replaceInternalStreamId(_this14, description);
          args[0].apply(null, [desc]);
        }, function (err) {
          if (args[1]) {
            args[1].apply(null, err);
          }
        }, arguments[2]]);
      }
      return nativeMethod.apply(this, arguments).then(function (description) {
        return replaceInternalStreamId(_this14, description);
      });
    });
    window.RTCPeerConnection.prototype[method] = methodObj[method];
  });

  var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };

  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

  var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
    get: function get() {
      var description = origLocalDescription.get.apply(this);
      if (description.type === '') {
        return description;
      }
      return replaceInternalStreamId(this, description);
    }
  });

  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this15 = this;

    if (this.signalingState === 'closed') {
      throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
    }
    // We can not yet check for sender instanceof RTCRtpSender
    // since we shim RTPSender. So we check if sender._pc is set.
    if (!sender._pc) {
      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
    }
    var isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
    }

    // Search for the native stream the senders track belongs to.
    this._streams = this._streams || {};
    var stream = void 0;
    Object.keys(this._streams).forEach(function (streamid) {
      var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
        return sender.track === track;
      });
      if (hasTrack) {
        stream = _this15._streams[streamid];
      }
    });

    if (stream) {
      if (stream.getTracks().length === 1) {
        // if this is the last track of the stream, remove the stream. This
        // takes care of any shimmed _senders.
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        // relying on the same odd chrome behaviour as above.
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event('negotiationneeded'));
    }
  };
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.webkitRTCPeerConnection;
  }
  if (!window.RTCPeerConnection) {
    return;
  }

  // shim implicit creation of RTCSessionDescription/RTCIceCandidate
  if (browserDetails.version < 53) {
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    // Firefox 68+ emits and processes {candidate: "", ...}, ignore
    // in older versions. Native support planned for Chrome M77.
    if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}

function fixNegotiationNeeded(window) {
  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
    var pc = e.target;
    if (pc.signalingState !== 'stable') {
      return;
    }
    return e;
  });
}

},{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, getSourceId) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  // getSourceId is a function that returns a promise resolving with
  // the sourceId of the screen/window/tab to be shared.
  if (typeof getSourceId !== 'function') {
    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then(function (sourceId) {
      var widthSpecified = constraints.video && constraints.video.width;
      var heightSpecified = constraints.video && constraints.video.height;
      var frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}

},{}],5:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils.js');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var logging = utils.log;

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (!navigator.mediaDevices) {
    return;
  }

  var browserDetails = utils.detectBrowser(window);

  var constraintsToChrome_ = function constraintsToChrome_(c) {
    if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function (key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function oldname_(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === 'deviceId' ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function (mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function shimConstraints_(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && _typeof(constraints.audio) === 'object') {
      var remap = function remap(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && _typeof(constraints.video) === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches = void 0;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices().then(function (devices) {
            devices = devices.filter(function (d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function (d) {
              return matches.some(function (match) {
                return d.label.toLowerCase().includes(match);
              });
            });
            if (!dev && devices.length && matches.includes('back')) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function shimError_(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function toString() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function (c) {
      navigator.webkitGetUserMedia(c, onSuccess, function (e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator.getUserMedia = getUserMedia_.bind(navigator);

  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
  // function which returns a Promise, it does not accept spec-style
  // constraints.
  if (navigator.mediaDevices.getUserMedia) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (cs) {
      return shimConstraints_(cs, function (c) {
        return origGetUserMedia(c).then(function (stream) {
          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function (track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function (e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }
}

},{"../utils.js":15}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimRTCIceCandidate = shimRTCIceCandidate;
exports.shimMaxMessageSize = shimMaxMessageSize;
exports.shimSendThrowTypeError = shimSendThrowTypeError;
exports.shimConnectionState = shimConnectionState;
exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

var _sdp = require('sdp');

var _sdp2 = _interopRequireDefault(_sdp);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shimRTCIceCandidate(window) {
  // foundation is arbitrarily chosen as an indicator for full support for
  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
    return;
  }

  var NativeRTCIceCandidate = window.RTCIceCandidate;
  window.RTCIceCandidate = function RTCIceCandidate(args) {
    // Remove the a= which shouldn't be part of the candidate string.
    if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }

    if (args.candidate && args.candidate.length) {
      // Augment the native candidate with the parsed fields.
      var nativeCandidate = new NativeRTCIceCandidate(args);
      var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
      var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

      // Add a serializer that does not serialize the extra attributes.
      augmentedCandidate.toJSON = function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment
        };
      };
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

  // Hook up the augmented candidate in onicecandidate and
  // addEventListener('icecandidate', ...)
  utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
    if (e.candidate) {
      Object.defineProperty(e, 'candidate', {
        value: new window.RTCIceCandidate(e.candidate),
        writable: 'false'
      });
    }
    return e;
  });
}

function shimMaxMessageSize(window) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);

  if (!('sctp' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
      get: function get() {
        return typeof this._sctp === 'undefined' ? null : this._sctp;
      }
    });
  }

  var sctpInDescription = function sctpInDescription(description) {
    if (!description || !description.sdp) {
      return false;
    }
    var sections = _sdp2.default.splitSections(description.sdp);
    sections.shift();
    return sections.some(function (mediaSection) {
      var mLine = _sdp2.default.parseMLine(mediaSection);
      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
    });
  };

  var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
    // TODO: Is there a better solution for detecting Firefox?
    var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    var version = parseInt(match[1], 10);
    // Test for NaN (yes, this is ugly)
    return version !== version ? -1 : version;
  };

  var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
    // Every implementation we know can send at least 64 KiB.
    // Note: Although Chrome is technically able to send up to 256 KiB, the
    //       data does not reach the other peer reliably.
    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
    var canSendMaxMessageSize = 65536;
    if (browserDetails.browser === 'firefox') {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          // FF < 57 will send in 16 KiB chunks using the deprecated PPID
          // fragmentation.
          canSendMaxMessageSize = 16384;
        } else {
          // However, other FF (and RAWRTC) can reassemble PPID-fragmented
          // messages. Thus, supporting ~2 GiB when sending.
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        // Currently, all FF >= 57 will reset the remote maximum message size
        // to the default value when a data channel is created at a later
        // stage. :(
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        // FF >= 60 supports sending ~2 GiB
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };

  var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
    // Note: 65536 bytes is the default value from the SDP spec. Also,
    //       every implementation we know supports receiving 65536 bytes.
    var maxMessageSize = 65536;

    // FF 57 has a slightly incorrect default remote max message size, so
    // we need to adjust it here to avoid a failure when sending.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }

    var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
      // If the maximum message size is not present in the remote SDP and
      // both local and remote are Firefox, the remote peer can receive
      // ~2 GiB.
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };

  var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    // Chrome decided to not expose .sctp in plan-b mode.
    // As usual, adapter.js has to do an 'ugly worakaround'
    // to cover up the mess.
    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
      var _getConfiguration = this.getConfiguration(),
          sdpSemantics = _getConfiguration.sdpSemantics;

      if (sdpSemantics === 'plan-b') {
        Object.defineProperty(this, 'sctp', {
          get: function get() {
            return typeof this._sctp === 'undefined' ? null : this._sctp;
          },

          enumerable: true,
          configurable: true
        });
      }
    }

    if (sctpInDescription(arguments[0])) {
      // Check if the remote is FF.
      var isFirefox = getRemoteFirefoxVersion(arguments[0]);

      // Get the maximum message size the local peer is capable of sending
      var canSendMMS = getCanSendMaxMessageSize(isFirefox);

      // Get the maximum message size of the remote peer.
      var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

      // Determine final maximum message size
      var maxMessageSize = void 0;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }

      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
      // attribute.
      var sctp = {};
      Object.defineProperty(sctp, 'maxMessageSize', {
        get: function get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }

    return origSetRemoteDescription.apply(this, arguments);
  };
}

function shimSendThrowTypeError(window) {
  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
    return;
  }

  // Note: Although Firefox >= 57 has a native implementation, the maximum
  //       message size can be reset for all data channels at a later stage.
  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

  function wrapDcSend(dc, pc) {
    var origDataChannelSend = dc.send;
    dc.send = function send() {
      var data = arguments[0];
      var length = data.length || data.size || data.byteLength;
      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    var dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}

/* shims RTCConnectionState by pretending it is the same as iceConnectionState.
 * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
 * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
 * since DTLS failures would be hidden. See
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
 * for the Firefox tracking bug.
 */
function shimConnectionState(window) {
  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  Object.defineProperty(proto, 'connectionState', {
    get: function get() {
      return {
        completed: 'connected',
        checking: 'connecting'
      }[this.iceConnectionState] || this.iceConnectionState;
    },

    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, 'onconnectionstatechange', {
    get: function get() {
      return this._onconnectionstatechange || null;
    },
    set: function set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
      }
    },

    enumerable: true,
    configurable: true
  });

  ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
    var origMethod = proto[method];
    proto[method] = function () {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = function (e) {
          var pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            var newEvent = new Event('connectionstatechange', e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}

function removeAllowExtmapMixed(window) {
  /* remove a=extmap-allow-mixed for Chrome < M71 */
  if (!window.RTCPeerConnection) {
    return;
  }
  var browserDetails = utils.detectBrowser(window);
  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
    return;
  }
  var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
      desc.sdp = desc.sdp.split('\n').filter(function (line) {
        return line.trim() !== 'a=extmap-allow-mixed';
      }).join('\n');
    }
    return nativeSRD.apply(this, arguments);
  };
}

},{"./utils":15,"sdp":17}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimPeerConnection = shimPeerConnection;
exports.shimReplaceTrack = shimReplaceTrack;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _filtericeservers = require('./filtericeservers');

var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if (window.RTCIceGatherer) {
    if (!window.RTCIceCandidate) {
      window.RTCIceCandidate = function RTCIceCandidate(args) {
        return args;
      };
    }
    if (!window.RTCSessionDescription) {
      window.RTCSessionDescription = function RTCSessionDescription(args) {
        return args;
      };
    }
    // this adds an additional event listener to MediaStrackTrack that signals
    // when a tracks enabled property was changed. Workaround for a bug in
    // addStream, see below. No longer required in 15025+
    if (browserDetails.version < 15025) {
      var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
        set: function set(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }
  }

  // ORTC defines the DTMF sender a bit different.
  // https://github.com/w3c/ortc/issues/714
  if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
      get: function get() {
        if (this._dtmf === undefined) {
          if (this.track.kind === 'audio') {
            this._dtmf = new window.RTCDtmfSender(this);
          } else if (this.track.kind === 'video') {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
  // Edge currently only implements the RTCDtmfSender, not the
  // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
  if (window.RTCDtmfSender && !window.RTCDTMFSender) {
    window.RTCDTMFSender = window.RTCDtmfSender;
  }

  var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
  window.RTCPeerConnection = function RTCPeerConnection(config) {
    if (config && config.iceServers) {
      config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
      utils.log('ICE servers after filtering:', config.iceServers);
    }
    return new RTCPeerConnectionShim(config);
  };
  window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
}

function shimReplaceTrack(window) {
  // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
  if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
    window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
  }
}

},{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterIceServers = filterIceServers;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function (server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function (url) {
        // filter STUN unconditionally.
        if (url.indexOf('stun:') === 0) {
          return false;
        }

        var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
        if (validTurn && !hasTurn) {
          hasTurn = true;
          return true;
        }
        return validTurn && !hasTurn;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

},{"../utils":15}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window) {
  if (!('getDisplayMedia' in window.navigator)) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
}

},{}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetUserMedia = shimGetUserMedia;
function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  var shimError_ = function shimError_(e) {
    return {
      name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function toString() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function (c) {
    return origGetUserMedia(c).catch(function (e) {
      return Promise.reject(shimError_(e));
    });
  };
}

},{}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _getusermedia = require('./getusermedia');

Object.defineProperty(exports, 'shimGetUserMedia', {
  enumerable: true,
  get: function get() {
    return _getusermedia.shimGetUserMedia;
  }
});

var _getdisplaymedia = require('./getdisplaymedia');

Object.defineProperty(exports, 'shimGetDisplayMedia', {
  enumerable: true,
  get: function get() {
    return _getdisplaymedia.shimGetDisplayMedia;
  }
});
exports.shimOnTrack = shimOnTrack;
exports.shimPeerConnection = shimPeerConnection;
exports.shimSenderGetStats = shimSenderGetStats;
exports.shimReceiverGetStats = shimReceiverGetStats;
exports.shimRemoveStream = shimRemoveStream;
exports.shimRTCDataChannel = shimRTCDataChannel;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function shimOnTrack(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimPeerConnection(window) {
  var browserDetails = utils.detectBrowser(window);

  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
    return; // probably media.peerconnection.enabled=false in about:config
  }
  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
    // very basic support for old versions.
    window.RTCPeerConnection = window.mozRTCPeerConnection;
  }

  if (browserDetails.version < 53) {
    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function () {
        arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }

  // support for addIceCandidate(null or undefined)
  // as well as ignoring {sdpMid, candidate: ""}
  if (browserDetails.version < 68) {
    var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      // Firefox 68+ emits and processes {candidate: "", ...}, ignore
      // in older versions.
      if (arguments[0] && arguments[0].candidate === '') {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }

  var modernStatsTypes = {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  };

  var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
  window.RTCPeerConnection.prototype.getStats = function getStats() {
    var _arguments = Array.prototype.slice.call(arguments),
        selector = _arguments[0],
        onSucc = _arguments[1],
        onErr = _arguments[2];

    return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
      if (browserDetails.version < 53 && !onSucc) {
        // Shim only promise getStats with spec-hyphens in type names
        // Leave callback version alone; misc old uses of forEach before Map
        try {
          stats.forEach(function (stat) {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e) {
          if (e.name !== 'TypeError') {
            throw e;
          }
          // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
          stats.forEach(function (stat, i) {
            stats.set(i, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}

function shimSenderGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
    return;
  }
  var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this = this;

      var senders = origGetSenders.apply(this, []);
      senders.forEach(function (sender) {
        return sender._pc = _this;
      });
      return senders;
    };
  }

  var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window.RTCPeerConnection.prototype.addTrack = function addTrack() {
      var sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
  };
}

function shimReceiverGetStats(window) {
  if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
    return;
  }
  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
    return;
  }
  var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      var _this2 = this;

      var receivers = origGetReceivers.apply(this, []);
      receivers.forEach(function (receiver) {
        return receiver._pc = _this2;
      });
      return receivers;
    };
  }
  utils.wrapPeerConnectionEvent(window, 'track', function (e) {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}

function shimRemoveStream(window) {
  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
    return;
  }
  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    var _this3 = this;

    utils.deprecated('removeStream', 'removeTrack');
    this.getSenders().forEach(function (sender) {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        _this3.removeTrack(sender);
      }
    });
  };
}

function shimRTCDataChannel(window) {
  // rename DataChannel to RTCDataChannel (native fix in FF60):
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
  if (window.DataChannel && !window.RTCDataChannel) {
    window.RTCDataChannel = window.DataChannel;
  }
}

},{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shimGetDisplayMedia = shimGetDisplayMedia;
function shimGetDisplayMedia(window, preferredMediaSource) {
  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
    return;
  }
  if (!window.navigator.mediaDevices) {
    return;
  }
  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
      err.name = 'NotFoundError';
      // from https://heycam.github.io/webidl/#idl-DOMException-error-names
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window.navigator.mediaDevices.getUserMedia(constraints);
  };
}

},{}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimGetUserMedia = shimGetUserMedia;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimGetUserMedia(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  navigator.getUserMedia = function (constraints, onSuccess, onError) {
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };

  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function remap(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function (c) {
      if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function () {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function (c) {
        if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}

},{"../utils":15}],14:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
exports.shimCallbacksAPI = shimCallbacksAPI;
exports.shimGetUserMedia = shimGetUserMedia;
exports.shimConstraints = shimConstraints;
exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function shimLocalStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!('addStream' in window.RTCPeerConnection.prototype)) {
    var _addTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      // Try to emulate Chrome's behaviour of adding in audio-video order.
      // Safari orders by track id.
      stream.getAudioTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
      stream.getVideoTracks().forEach(function (track) {
        return _addTrack.call(_this, track, stream);
      });
    };

    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
      var stream = arguments[1];
      if (stream) {
        if (!this._localStreams) {
          this._localStreams = [stream];
        } else if (!this._localStreams.includes(stream)) {
          this._localStreams.push(stream);
        }
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!('removeStream' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this2 = this;

      if (!this._localStreams) {
        this._localStreams = [];
      }
      var index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      var tracks = stream.getTracks();
      this.getSenders().forEach(function (sender) {
        if (tracks.includes(sender.track)) {
          _this2.removeTrack(sender);
        }
      });
    };
  }
}

function shimRemoteStreamsAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
      get: function get() {
        return this._onaddstream;
      },
      set: function set(f) {
        var _this3 = this;

        if (this._onaddstream) {
          this.removeEventListener('addstream', this._onaddstream);
          this.removeEventListener('track', this._onaddstreampoly);
        }
        this.addEventListener('addstream', this._onaddstream = f);
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!_this3._remoteStreams) {
              _this3._remoteStreams = [];
            }
            if (_this3._remoteStreams.includes(stream)) {
              return;
            }
            _this3._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            _this3.dispatchEvent(event);
          });
        });
      }
    });
    var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener('track', this._onaddstreampoly = function (e) {
          e.streams.forEach(function (stream) {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            var event = new Event('addstream');
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}

function shimCallbacksAPI(window) {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
    return;
  }
  var prototype = window.RTCPeerConnection.prototype;
  var origCreateOffer = prototype.createOffer;
  var origCreateAnswer = prototype.createAnswer;
  var setLocalDescription = prototype.setLocalDescription;
  var setRemoteDescription = prototype.setRemoteDescription;
  var addIceCandidate = prototype.addIceCandidate;

  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };

  var withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;

  withCallback = function withCallback(description, successCallback, failureCallback) {
    var promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;

  withCallback = function withCallback(candidate, successCallback, failureCallback) {
    var promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}

function shimGetUserMedia(window) {
  var navigator = window && window.navigator;

  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // shim not needed in Safari 12.1
    var mediaDevices = navigator.mediaDevices;
    var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator.mediaDevices.getUserMedia = function (constraints) {
      return _getUserMedia(shimConstraints(constraints));
    };
  }

  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }.bind(navigator);
  }
}

function shimConstraints(constraints) {
  if (constraints && constraints.video !== undefined) {
    return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
  }

  return constraints;
}

function shimRTCIceServerUrls(window) {
  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
  var OrigPeerConnection = window.RTCPeerConnection;
  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      var newIceServers = [];
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        var server = pcConfig.iceServers[i];
        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
          utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  // wrap static methods. Currently just generateCertificate.
  if ('generateCertificate' in window.RTCPeerConnection) {
    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
      get: function get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}

function shimTrackEventTransceiver(window) {
  // Add event.transceiver member over deprecated event.receiver
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
      get: function get() {
        return { receiver: this.receiver };
      }
    });
  }
}

function shimCreateOfferLegacy(window) {
  var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      var audioTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'audio';
      });
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === 'sendrecv') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('sendonly');
          } else {
            audioTransceiver.direction = 'sendonly';
          }
        } else if (audioTransceiver.direction === 'recvonly') {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection('inactive');
          } else {
            audioTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver('audio');
      }

      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
        // support bit values
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      var videoTransceiver = this.getTransceivers().find(function (transceiver) {
        return transceiver.receiver.track.kind === 'video';
      });
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === 'sendrecv') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('sendonly');
          } else {
            videoTransceiver.direction = 'sendonly';
          }
        } else if (videoTransceiver.direction === 'recvonly') {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection('inactive');
          } else {
            videoTransceiver.direction = 'inactive';
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver('video');
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}

},{"../utils":15}],15:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
/* eslint-env node */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.extractVersion = extractVersion;
exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
exports.disableLog = disableLog;
exports.disableWarnings = disableWarnings;
exports.log = log;
exports.deprecated = deprecated;
exports.detectBrowser = detectBrowser;
exports.compactObject = compactObject;
exports.walkStats = walkStats;
exports.filterStats = filterStats;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function wrappedCallback(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        cb(modifiedEvent);
      }
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function (nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function get() {
      return this['_on' + eventNameToWrap];
    },
    set: function set(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
      }
    },

    enumerable: true,
    configurable: true
  });
}

function disableLog(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  logDisabled_ = bool;
  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
}

/**
 * Disable or enable deprecation warnings
 * @param {!boolean} bool set to true to disable warnings.
 */
function disableWarnings(bool) {
  if (typeof bool !== 'boolean') {
    return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
  }
  deprecationWarnings_ = !bool;
  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
}

function log() {
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== 'undefined' && typeof console.log === 'function') {
      console.log.apply(console, arguments);
    }
  }
}

/**
 * Shows a deprecation warning suggesting the modern and spec-compatible API.
 */
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
}

/**
 * Browser detector.
 *
 * @return {object} result containing browser and version
 *     properties.
 */
function detectBrowser(window) {
  var navigator = window.navigator;

  // Returned result object.

  var result = { browser: null, version: null };

  // Fail early if it's not a browser
  if (typeof window === 'undefined' || !window.navigator) {
    result.browser = 'Not a browser.';
    return result;
  }

  if (navigator.mozGetUserMedia) {
    // Firefox.
    result.browser = 'firefox';
    result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
    // Chrome, Chromium, Webview, Opera.
    // Version matches Chrome/WebRTC version.
    // Chrome 74 removed webkitGetUserMedia on http as well so we need the
    // more complicated fallback to webkitRTCPeerConnection.
    result.browser = 'chrome';
    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
    // Edge.
    result.browser = 'edge';
    result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    // Safari.
    result.browser = 'safari';
    result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
  } else {
    // Default fallthrough: not supported.
    result.browser = 'Not a supported browser.';
    return result;
  }

  return result;
}

/**
 * Checks if something is an object.
 *
 * @param {*} val The something you want to check.
 * @return true if val is an object, false otherwise.
 */
function isObject(val) {
  return Object.prototype.toString.call(val) === '[object Object]';
}

/**
 * Remove all empty objects and undefined values
 * from a nested object -- an enhanced and vanilla version
 * of Lodash's `compact`.
 */
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }

  return Object.keys(data).reduce(function (accumulator, key) {
    var isObj = isObject(data[key]);
    var value = isObj ? compactObject(data[key]) : data[key];
    var isEmptyObject = isObj && !Object.keys(value).length;
    if (value === undefined || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, _defineProperty({}, key, value));
  }, {});
}

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function (name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function (id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function (value) {
    if (value.type === 'track' && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function (trackStat) {
    result.forEach(function (stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

},{}],16:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all field are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this._localDescription = null;
    this._remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
    configurable: true,
    get: function() {
      return this._localDescription;
    }
  });
  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
    configurable: true,
    get: function() {
      return this._remoteDescription;
    }
  });

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // dpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc._localDescription.sdp =
          SDPUtils.getDescription(pc._localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc._localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
          protocol === 'UDP/DTLS/SCTP'))) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          protocol: protocol,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        // If the offer contained RTX but the answer did not,
        // remove RTX from sendEncodingParameters.
        var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

        var hasRtx = commonCapabilities.codecs.filter(function(c) {
          return c.name.toLowerCase() === 'rtx';
        }).length;
        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
          delete transceiver.sendEncodingParameters[0].rtx;
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc._remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
      }
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && transceiver.dtlsTransport &&
          !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      }
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc._remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
            sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
          } else {
            sdp += 'm=application 0 ' + transceiver.protocol +
                ' webrtc-datachannel\r\n';
          }
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc._remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":17}],17:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.substr(17).split(' ');
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(msidParts) {
    return msidParts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  var user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}]},{},[1])(1)
});


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(196)(__webpack_require__(197))

/***/ }),
/* 196 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),
/* 197 */
/***/ (function(module, exports) {

module.exports = "/* globals $$, jQuery, Elements, document, window, L */\n\n/**\n* Copyright 2013 Marc J. Schmidt. See the LICENSE file at the top-level\n* directory of this distribution and at\n* https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n*/\nthis.L = this.L || {};\n\n/**\n * @param {HTMLElement} element\n * @param {String}      prop\n * @returns {String|Number}\n */\nL.GetComputedStyle = (computedElement, prop) => {\n  if (computedElement.currentStyle) {\n    return computedElement.currentStyle[prop];\n  } else if (window.getComputedStyle) {\n    return window.getComputedStyle(computedElement, null).getPropertyValue(prop);\n  }\n  return computedElement.style[prop];\n};\n\n  /**\n   *\n   * @type {Function}\n   * @constructor\n   */\nL.ElementQueries = function ElementQueries() {\n      /**\n       *\n       * @param element\n       * @returns {Number}\n       */\n  function getEmSize(element = document.documentElement) {\n    const fontSize = L.GetComputedStyle(element, 'fontSize');\n    return parseFloat(fontSize) || 16;\n  }\n\n      /**\n       *\n       * @copyright https://github.com/Mr0grog/element-query/blob/master/LICENSE\n       *\n       * @param element\n       * @param value\n       * @param units\n       * @returns {*}\n       */\n  function convertToPx(element, originalValue) {\n    let vh;\n    let vw;\n    let chooser;\n    const units = originalValue.replace(/[0-9]*/, '');\n    const value = parseFloat(originalValue);\n    switch (units) {\n      case 'px':\n        return value;\n      case 'em':\n        return value * getEmSize(element);\n      case 'rem':\n        return value * getEmSize();\n              // Viewport units!\n              // According to http://quirksmode.org/mobile/tableViewport.html\n              // documentElement.clientWidth/Height gets us the most reliable info\n      case 'vw':\n        return (value * document.documentElement.clientWidth) / 100;\n      case 'vh':\n        return (value * document.documentElement.clientHeight) / 100;\n      case 'vmin':\n      case 'vmax':\n        vw = document.documentElement.clientWidth / 100;\n        vh = document.documentElement.clientHeight / 100;\n        chooser = Math[units === 'vmin' ? 'min' : 'max'];\n        return value * chooser(vw, vh);\n      default:\n        return value;\n              // for now, not supporting physical units (since they are just a set number of px)\n              // or ex/ch (getting accurate measurements is hard)\n    }\n  }\n\n      /**\n       *\n       * @param {HTMLElement} element\n       * @constructor\n       */\n  function SetupInformation(element) {\n    this.element = element;\n    this.options = [];\n    let i;\n    let j;\n    let option;\n    let width = 0;\n    let height = 0;\n    let value;\n    let actualValue;\n    let attrValues;\n    let attrValue;\n    let attrName;\n\n          /**\n           * @param option {mode: 'min|max', property: 'width|height', value: '123px'}\n           */\n    this.addOption = (newOption) => {\n      this.options.push(newOption);\n    };\n\n    const attributes = ['min-width', 'min-height', 'max-width', 'max-height'];\n\n          /**\n           * Extracts the computed width/height and sets to min/max- attribute.\n           */\n    this.call = () => {\n              // extract current dimensions\n      width = this.element.offsetWidth;\n      height = this.element.offsetHeight;\n\n      attrValues = {};\n\n      for (i = 0, j = this.options.length; i < j; i += 1) {\n        option = this.options[i];\n        value = convertToPx(this.element, option.value);\n\n        actualValue = option.property === 'width' ? width : height;\n        attrName = `${option.mode}-${option.property}`;\n        attrValue = '';\n\n        if (option.mode === 'min' && actualValue >= value) {\n          attrValue += option.value;\n        }\n\n        if (option.mode === 'max' && actualValue <= value) {\n          attrValue += option.value;\n        }\n\n        if (!attrValues[attrName]) attrValues[attrName] = '';\n        if (attrValue && (` ${attrValues[attrName]} `)\n                                            .indexOf(` ${attrValue} `) === -1) {\n          attrValues[attrName] += ` ${attrValue}`;\n        }\n      }\n\n      for (let k = 0; k < attributes.length; k += 1) {\n        if (attrValues[attributes[k]]) {\n          this.element.setAttribute(attributes[k],\n                                                attrValues[attributes[k]].substr(1));\n        } else {\n          this.element.removeAttribute(attributes[k]);\n        }\n      }\n    };\n  }\n\n      /**\n       * @param {HTMLElement} element\n       * @param {Object}      options\n       */\n  function setupElement(originalElement, options) {\n    const element = originalElement;\n    if (element.elementQueriesSetupInformation) {\n      element.elementQueriesSetupInformation.addOption(options);\n    } else {\n      element.elementQueriesSetupInformation = new SetupInformation(element);\n      element.elementQueriesSetupInformation.addOption(options);\n      element.sensor = new L.ResizeSensor(element, () => {\n        element.elementQueriesSetupInformation.call();\n      });\n    }\n    element.elementQueriesSetupInformation.call();\n    return element;\n  }\n\n      /**\n       * @param {String} selector\n       * @param {String} mode min|max\n       * @param {String} property width|height\n       * @param {String} value\n       */\n  function queueQuery(selector, mode, property, value) {\n    let query;\n    if (document.querySelectorAll) query = document.querySelectorAll.bind(document);\n    if (!query && typeof $$ !== 'undefined') query = $$;\n    if (!query && typeof jQuery !== 'undefined') query = jQuery;\n\n    if (!query) {\n      throw new Error('No document.querySelectorAll, jQuery or Mootools\\'s $$ found.');\n    }\n\n    const elements = query(selector) || [];\n    for (let i = 0, j = elements.length; i < j; i += 1) {\n      elements[i] = setupElement(elements[i], {\n        mode,\n        property,\n        value,\n      });\n    }\n  }\n\n  const regex = /,?([^,\\n]*)\\[[\\s\\t]*(min|max)-(width|height)[\\s\\t]*[~$^]?=[\\s\\t]*\"([^\"]*)\"[\\s\\t]*]([^\\n\\s{]*)/mgi;  // jshint ignore:line\n\n      /**\n       * @param {String} css\n       */\n  function extractQuery(originalCss) {\n    let match;\n    const css = originalCss.replace(/'/g, '\"');\n    while ((match = regex.exec(css)) !== null) {\n      if (match.length > 5) {\n        queueQuery(match[1] || match[5], match[2], match[3], match[4]);\n      }\n    }\n  }\n\n      /**\n       * @param {CssRule[]|String} rules\n       */\n  function readRules(originalRules) {\n    if (!originalRules) {\n      return;\n    }\n    let selector = '';\n    let rules = originalRules;\n    if (typeof originalRules === 'string') {\n      rules = originalRules.toLowerCase();\n      if (rules.indexOf('min-width') !== -1 || rules.indexOf('max-width') !== -1) {\n        extractQuery(rules);\n      }\n    } else {\n      for (let i = 0, j = rules.length; i < j; i += 1) {\n        if (rules[i].type === 1) {\n          selector = rules[i].selectorText || rules[i].cssText;\n          if (selector.indexOf('min-height') !== -1 ||\n                          selector.indexOf('max-height') !== -1) {\n            extractQuery(selector);\n          } else if (selector.indexOf('min-width') !== -1 ||\n                                 selector.indexOf('max-width') !== -1) {\n            extractQuery(selector);\n          }\n        } else if (rules[i].type === 4) {\n          readRules(rules[i].cssRules || rules[i].rules);\n        }\n      }\n    }\n  }\n\n      /**\n       * Searches all css rules and setups the event listener\n       * to all elements with element query rules..\n       */\n  this.init = () => {\n    const styleSheets = document.styleSheets || [];\n    for (let i = 0, j = styleSheets.length; i < j; i += 1) {\n      readRules(styleSheets[i].cssText ||\n                        styleSheets[i].cssRules ||\n                        styleSheets[i].rules);\n    }\n  };\n};\n\nfunction init() {\n  (new L.ElementQueries()).init();\n}\n\nif (window.addEventListener) {\n  window.addEventListener('load', init, false);\n} else {\n  window.attachEvent('onload', init);\n}\n\n  /**\n   * Iterate over each of the provided element(s).\n   *\n   * @param {HTMLElement|HTMLElement[]} elements\n   * @param {Function}                  callback\n   */\nfunction forEachElement(elements, callback = () => {}) {\n  const elementsType = Object.prototype.toString.call(elements);\n  const isCollectionTyped = (elementsType === '[object Array]' ||\n          (elementsType === '[object NodeList]') ||\n          (elementsType === '[object HTMLCollection]') ||\n          (typeof jQuery !== 'undefined' && elements instanceof jQuery) || // jquery\n          (typeof Elements !== 'undefined' && elements instanceof Elements) // mootools\n      );\n  let i = 0;\n  const j = elements.length;\n  if (isCollectionTyped) {\n    for (; i < j; i += 1) {\n      callback(elements[i]);\n    }\n  } else {\n    callback(elements);\n  }\n}\n  /**\n   * Class for dimension change detection.\n   *\n   * @param {Element|Element[]|Elements|jQuery} element\n   * @param {Function} callback\n   *\n   * @constructor\n   */\nL.ResizeSensor = function ResizeSensor(element, callback = () => {}) {\n      /**\n       *\n       * @constructor\n       */\n  function EventQueue() {\n    let q = [];\n    this.add = (ev) => {\n      q.push(ev);\n    };\n\n    let i;\n    let j;\n    this.call = () => {\n      for (i = 0, j = q.length; i < j; i += 1) {\n        q[i].call();\n      }\n    };\n\n    this.remove = (ev) => {\n      const newQueue = [];\n      for (i = 0, j = q.length; i < j; i += 1) {\n        if (q[i] !== ev) newQueue.push(q[i]);\n      }\n      q = newQueue;\n    };\n\n    this.length = () => q.length;\n  }\n\n      /**\n       *\n       * @param {HTMLElement} element\n       * @param {Function}    resized\n       */\n  function attachResizeEvent(htmlElement, resized) {\n    // Only used for the dirty checking, so the event callback count is limted\n    //  to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time,\n    // because the sensor is too fast and\n    // would generate too many unnecessary events.\n    const customRequestAnimationFrame = window.requestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    function delay(fn) {\n      return window.setTimeout(fn, 20);\n    };\n\n    const newElement = htmlElement;\n    if (!newElement.resizedAttached) {\n      newElement.resizedAttached = new EventQueue();\n      newElement.resizedAttached.add(resized);\n    } else if (newElement.resizedAttached) {\n      newElement.resizedAttached.add(resized);\n      return;\n    }\n\n    newElement.resizeSensor = document.createElement('div');\n    newElement.resizeSensor.className = 'resize-sensor';\n    const style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; ' +\n                      'overflow: hidden; z-index: -1; visibility: hidden;';\n    const styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n    newElement.resizeSensor.style.cssText = style;\n    newElement.resizeSensor.innerHTML =\n              `<div class=\"resize-sensor-expand\" style=\"${style}\">` +\n                  `<div style=\"${styleChild}\"></div>` +\n              '</div>' +\n              `<div class=\"resize-sensor-shrink\" style=\"${style}\">` +\n                  `<div style=\"${styleChild} width: 200%; height: 200%\"></div>` +\n              '</div>';\n    newElement.appendChild(newElement.resizeSensor);\n\n    if (L.GetComputedStyle(newElement, 'position') === 'static') {\n      newElement.style.position = 'relative';\n    }\n\n    const expand = newElement.resizeSensor.childNodes[0];\n    const expandChild = expand.childNodes[0];\n    const shrink = newElement.resizeSensor.childNodes[1];\n\n    const reset = () => {\n      expandChild.style.width = `${100000}px`;\n      expandChild.style.height = `${100000}px`;\n\n      expand.scrollLeft = 100000;\n      expand.scrollTop = 100000;\n\n      shrink.scrollLeft = 100000;\n      shrink.scrollTop = 100000;\n    };\n\n    reset();\n    let dirty = false;\n\n    const dirtyChecking = () => {\n      if (!newElement.resizedAttached) return;\n\n      if (dirty) {\n        newElement.resizedAttached.call();\n        dirty = false;\n      }\n\n      customRequestAnimationFrame(dirtyChecking);\n    };\n\n    customRequestAnimationFrame(dirtyChecking);\n    let lastWidth;\n    let lastHeight;\n    let cachedWidth;\n    let cachedHeight; // useful to not query offsetWidth twice\n\n    const onScroll = () => {\n      if ((cachedWidth = newElement.offsetWidth) !== lastWidth ||\n                (cachedHeight = newElement.offsetHeight) !== lastHeight) {\n        dirty = true;\n\n        lastWidth = cachedWidth;\n        lastHeight = cachedHeight;\n      }\n      reset();\n    };\n\n    const addEvent = (el, name, cb) => {\n      if (el.attachEvent) {\n        el.attachEvent(`on${name}`, cb);\n      } else {\n        el.addEventListener(name, cb);\n      }\n    };\n\n    addEvent(expand, 'scroll', onScroll);\n    addEvent(shrink, 'scroll', onScroll);\n  }\n\n  forEachElement(element, (elem) => {\n    attachResizeEvent(elem, callback);\n  });\n\n  this.detach = (ev) => {\n    L.ResizeSensor.detach(element, ev);\n  };\n};\n\nL.ResizeSensor.detach = (element, ev) => {\n  forEachElement(element, (elem) => {\n    const elementItem = elem;\n    if (elementItem.resizedAttached && typeof ev === 'function') {\n      elementItem.resizedAttached.remove(ev);\n      if (elementItem.resizedAttached.length()) return;\n    }\n    if (elementItem.resizeSensor) {\n      if (elementItem.contains(elementItem.resizeSensor)) {\n        elementItem.removeChild(elementItem.resizeSensor);\n      }\n      delete elementItem.resizeSensor;\n      delete elementItem.resizedAttached;\n    }\n  });\n};\n"

/***/ })
/******/ ])["default"];
//# sourceMappingURL=EnxRtc.js.map